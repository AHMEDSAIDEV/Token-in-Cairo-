<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Starknet Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Starknet Book</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="ch02-00-starknet-tooling.html"><strong aria-hidden="true">2.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-basic-installation.html"><strong aria-hidden="true">2.1.</strong> Basic Installation</a></li><li class="chapter-item expanded "><a href="ch02-02-compile-deploy-interact.html"><strong aria-hidden="true">2.2.</strong> Compile, Deploy, Interact</a></li><li class="chapter-item expanded "><a href="ch02-03-scarb.html"><strong aria-hidden="true">2.3.</strong> Scarb: The Package Manager</a></li><li class="chapter-item expanded "><a href="ch02-04-starkli.html"><strong aria-hidden="true">2.4.</strong> Starkli: A CLI interface 🚧</a></li><li class="chapter-item expanded "><a href="ch02-05-katana.html"><strong aria-hidden="true">2.5.</strong> Katana: A Local Node</a></li><li class="chapter-item expanded "><a href="ch02-06-starknet-devnet.html"><strong aria-hidden="true">2.6.</strong> Starknet Devnet 🚧</a></li><li class="chapter-item expanded "><a href="ch02-07-starknet-js.html"><strong aria-hidden="true">2.7.</strong> Starknet-js: Javascript SDK</a></li><li class="chapter-item expanded "><a href="ch02-08-starknet-react.html"><strong aria-hidden="true">2.8.</strong> Starknet-React: React Integration</a></li><li class="chapter-item expanded "><a href="ch02-09-starknet-py.html"><strong aria-hidden="true">2.9.</strong> Starknet-py: Python SDK 🚧</a></li><li class="chapter-item expanded "><a href="ch02-10-starknet-rs.html"><strong aria-hidden="true">2.10.</strong> Starknet-rs: Rust SDK 🚧</a></li><li class="chapter-item expanded "><a href="ch02-11-foundry-cast.html"><strong aria-hidden="true">2.11.</strong> Foundry Cast: Interacting with Starknet 🚧</a></li><li class="chapter-item expanded "><a href="ch02-12-foundry-forge.html"><strong aria-hidden="true">2.12.</strong> Foundry Forge: Testing 🚧</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-architecture.html"><strong aria-hidden="true">3.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-transactions.html"><strong aria-hidden="true">3.1.</strong> Transactions</a></li><li class="chapter-item expanded "><a href="ch03-02-sequencers.html"><strong aria-hidden="true">3.2.</strong> Sequencers</a></li><li class="chapter-item expanded "><a href="ch03-03-provers.html"><strong aria-hidden="true">3.3.</strong> Provers 🚧</a></li><li class="chapter-item expanded "><a href="ch03-04-nodes.html"><strong aria-hidden="true">3.4.</strong> Nodes 🚧</a></li><li class="chapter-item expanded "><a href="ch03-05-layer-3.html"><strong aria-hidden="true">3.5.</strong> Layer 3 and App Chains 🚧  </a></li><li class="chapter-item expanded "><a href="ch03-06-solidity-verifier.html"><strong aria-hidden="true">3.6.</strong> Solidity Verifier 🚧</a></li><li class="chapter-item expanded "><a href="ch03-07-decentralization.html"><strong aria-hidden="true">3.7.</strong> Decentralization 🚧</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-account-abstraction.html"><strong aria-hidden="true">4.</strong> Account Abstraction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-accounts.html"><strong aria-hidden="true">4.1.</strong> Accounts</a></li><li class="chapter-item expanded "><a href="ch04-02-hello-account.html"><strong aria-hidden="true">4.2.</strong> Hello, Account! 🚧</a></li><li class="chapter-item expanded "><a href="ch04-03-standard-account.html"><strong aria-hidden="true">4.3.</strong> Standard AccounT 🚧</a></li><li class="chapter-item expanded "><a href="ch04-04-examples.html"><strong aria-hidden="true">4.4.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-04-01-multicaller.html"><strong aria-hidden="true">4.4.1.</strong> Multicaller 🚧</a></li><li class="chapter-item expanded "><a href="ch04-04-02-multisig.html"><strong aria-hidden="true">4.4.2.</strong> Multisig 🚧</a></li><li class="chapter-item expanded "><a href="ch04-04-03-auto-payments.html"><strong aria-hidden="true">4.4.3.</strong> Auto-Payments 🚧</a></li><li class="chapter-item expanded "><a href="ch04-04-04-alternative-signature-schemes.html"><strong aria-hidden="true">4.4.4.</strong> Alternative Signature Schemes 🚧</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-starks.html"><strong aria-hidden="true">5.</strong> STARKs 🚧</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-basics.html"><strong aria-hidden="true">5.1.</strong> Basics 🚧</a></li><li class="chapter-item expanded "><a href="ch05-02-math-primer.html"><strong aria-hidden="true">5.2.</strong> Math Primer 🚧</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-02-01-number-theory.html"><strong aria-hidden="true">5.2.1.</strong> Number Theory 🚧</a></li><li class="chapter-item expanded "><a href="ch05-02-02-geometry.html"><strong aria-hidden="true">5.2.2.</strong> Geometry 🚧</a></li><li class="chapter-item expanded "><a href="ch05-02-03-cryptographic-primitives.html"><strong aria-hidden="true">5.2.3.</strong> Cryptographic Primitives 🚧</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-03-arithimization.html"><strong aria-hidden="true">5.3.</strong> Arithimization 🚧</a></li><li class="chapter-item expanded "><a href="ch05-04-low-degree-testing.html"><strong aria-hidden="true">5.4.</strong> Low Degree Testing 🚧</a></li><li class="chapter-item expanded "><a href="ch05-05-fri-protocol.html"><strong aria-hidden="true">5.5.</strong> FRI Protocol 🚧</a></li><li class="chapter-item expanded "><a href="ch05-06-efficient-starks.html"><strong aria-hidden="true">5.6.</strong> Efficient STARKs</a></li><li class="chapter-item expanded "><a href="ch05-07-starks-protocol-python.html"><strong aria-hidden="true">5.7.</strong> STARKs Protocol (Python) 🚧</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-07-01-trace-low-degree-extension-python.html"><strong aria-hidden="true">5.7.1.</strong> Trace/Low Degree Extension 🚧</a></li><li class="chapter-item expanded "><a href="ch05-07-02-constraints-python.html"><strong aria-hidden="true">5.7.2.</strong> Constraints 🚧</a></li><li class="chapter-item expanded "><a href="ch05-07-03-fri-commitments-python.html"><strong aria-hidden="true">5.7.3.</strong> FRI Commitments 🚧</a></li><li class="chapter-item expanded "><a href="ch05-07-04-query-phase-python.html"><strong aria-hidden="true">5.7.4.</strong> Query Phase 🚧</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-08-starks-protocol-rust.html"><strong aria-hidden="true">5.8.</strong> STARKs Protocol (Rust) 🚧</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-08-01-trace-low-degree-extension-rust.html"><strong aria-hidden="true">5.8.1.</strong> Trace/Low Degree Extension 🚧</a></li><li class="chapter-item expanded "><a href="ch05-08-02-constraints-rust.html"><strong aria-hidden="true">5.8.2.</strong> Constraints 🚧</a></li><li class="chapter-item expanded "><a href="ch05-08-03-fri-commitments-rust.html"><strong aria-hidden="true">5.8.3.</strong> FRI Commitments 🚧</a></li><li class="chapter-item expanded "><a href="ch05-08-04-query-phase-rust.html"><strong aria-hidden="true">5.8.4.</strong> Query Phase 🚧</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Starknet Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-starknet-book"><a class="header" href="#the-starknet-book">The Starknet Book</a></h1>
<p>The Starknet Book is a work in progress, shaped by ongoing community
input. Some sections may be incomplete or still under review and are
marked under a 🚧 emoji. We welcome your suggestions, feedback, and
content contributions to make this book a reliable guide for everyone.</p>
<p>The Starknet Book is a step-by-step guide aimed at teaching you the
essentials of Starknet development. It’s a community effort, with each
chapter guiding you through the Starknet ecosystem.</p>
<p>Understanding Cairo, the key programming language for Starknet smart
contracts, is crucial. That’s why this book works hand-in-hand with the
Cairo Book, another community resource. You can access the Cairo Book
<a href="https://book.cairo-lang.org/"><strong>here</strong></a>.</p>
<p>In short, the Cairo Book helps you master Cairo, while The Starknet Book
focuses on Starknet’s specific features. For a well-rounded
understanding, we recommend exploring both. This book will introduce you
to tools, architecture, account setups, STARKs, and Starknet-specific
apps.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<p><strong>Chapter Titles</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Chapter</th><th>Description</th></tr></thead><tbody>
<tr><td>1: Starknet Introduction</td><td>Delve into the fundamental concepts of Starknet and acquaint yourself with the deployment of smart contracts.</td></tr>
<tr><td>2: Starknet Tooling</td><td>Familiarize yourself with vital tools, such as Protostar and Hardhat, and explore how languages like Javascript, Python, and Rust can be leveraged for Starknet interactions.</td></tr>
<tr><td>3: Starknet Architecture</td><td>Uncover Starknet’s core structure, gaining insights into the transaction lifecycle and the interplay between the Sequencer, Prover, and Nodes.</td></tr>
<tr><td>4: Account Abstraction</td><td>Delve deep into Starknet’s unique approach to user accounts, and master the art of crafting custom accounts.</td></tr>
<tr><td>5: STARKs</td><td>Dive into the intricacies of STARKs and their pivotal role in shaping Starknet’s landscape.</td></tr>
</tbody></table>
</div>
<h1 id="where-to-start"><a class="header" href="#where-to-start">Where to Start?</a></h1>
<p>Depending on your goals and interests, you can choose different paths
through the Starknet Book. Here are some recommendations based on
various objectives:</p>
<ul>
<li>
<p>If you’re a <strong>complete beginner</strong> and want to start learning about
Cairo and Starknet from scratch, follow the book in its entirety,
starting with <strong>Introduction to Starknet</strong>.</p>
</li>
<li>
<p>If you’re an <strong>experienced developer</strong> looking to quickly dive into
writing scalable and decentralized smart contracts, focus on the
Cairo Book, particularly <strong>chapter 12: Starknet Smart Contracts</strong>
(<a href="https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html">link</a>).</p>
</li>
<li>
<p>If you’re a <strong>frontend developer</strong> wanting to integrate Starknet
with a React frontend using Javascript, prioritize the
<strong>starknet-js</strong> and <strong>starknet-react</strong> subchapters in <strong>Starknet
Tooling</strong></p>
</li>
<li>
<p>If you’re a <strong>DevOps engineer</strong> or <strong>node operator</strong> interested in
running a Starknet node and indexer, head straight to <strong>Starknet
Architecture</strong>.</p>
</li>
<li>
<p>If you’re a <strong>security researcher</strong> or <strong>smart contract auditor</strong>
wanting to learn about the Account Abstraction feature and its
implications, go for <strong>Account Abstraction</strong>.</p>
</li>
<li>
<p>If you’re a <strong>blockchain enthusiast</strong> curious about the underlying
architecture and mechanics of Starknet and Cairo, explore <strong>Starknet
Architecture</strong>.</p>
</li>
<li>
<p>If you’re a <strong>cryptography expert</strong> or <strong>researcher</strong> eager to
understand the fundamentals of STARKs and their connection to the
Starknet ecosystem, delve into <strong>STARKs</strong>.</p>
</li>
</ul>
<p>Feel free to mix and match these paths based on your unique interests
and requirements.</p>
<h1 id="your-contributions-matter"><a class="header" href="#your-contributions-matter">Your Contributions Matter</a></h1>
<p>Welcome aboard! By contributing to the Starknet Book, you’re doing more
than sharing expertise—you’re shaping the future of decentralized tech.
Let’s build a guide that helps developers unlock Starknet’s potential.</p>
<p>For detailed contribution guidelines, visit the <a href="https://github.com/starknet-edu/starknetbook/blob/main/CONTRIBUTING.adoc">Contributors
Guide</a>.
Every contribution counts. Your skills and passion will help make this
book an invaluable tool.</p>
<h2 id="how-you-can-help"><a class="header" href="#how-you-can-help">How You Can Help</a></h2>
<ul>
<li>
<p>Found an empty section? Fill it in!</p>
</li>
<li>
<p>Think we need a new section? Suggest one.</p>
</li>
<li>
<p>See room for improvement? Go ahead and tweak it.</p>
</li>
<li>
<p>Want to add code in a new programming language? Go for it.</p>
</li>
<li>
<p>Found a bug? Fix it.</p>
</li>
<li>
<p>Exercises unclear? Add explanations.</p>
</li>
<li>
<p>Show off your favorite Cairo features through new exercises.</p>
</li>
</ul>
<h1 id="additional-key-educational-resources"><a class="header" href="#additional-key-educational-resources">Additional Key Educational Resources</a></h1>
<p>We’ve compiled a list of valuable educational resources that will help
deepen your understanding and enhance your skills in coding with Cairo
and staying abreast with Starknet developments:</p>
<ol>
<li>
<p><strong>Cairo Book</strong>: A comprehensive guide to Cairo, the programming
language for Starknet smart contracts. You can access it
<a href="https://book.cairo-lang.org/">here</a>.</p>
</li>
<li>
<p><strong>Starklings</strong>: A resource specifically designed to guide you
through learning Cairo programming, ensuring that you reach a
proficient level. You can access it
<a href="https://github.com/shramee/starklings-cairo1">here</a>.</p>
</li>
<li>
<p><strong>Starknet Community Forum</strong>: An online platform where you can
engage in discussions about the latest developments in Starknet.
Join the conversation <a href="https://community.starknet.io/">here</a>.</p>
</li>
<li>
<p><strong>Starknet Documentation</strong>: You can browse through the documentation
<a href="https://docs.starknet.io/">here</a>.</p>
</li>
<li>
<p><strong>Cairo Documentation</strong>: Explore it
<a href="https://www.cairo-lang.org/docs">here</a>.</p>
</li>
<li>
<p><strong>Starknet Developer Telegram (English)</strong>: A community for
English-speaking Starknet developers. This is a great platform for
networking, sharing ideas, and troubleshooting together. Join us on
Telegram <a href="https://t.me/starknetna">here</a>.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-starknet-network"><a class="header" href="#the-starknet-network">The Starknet Network</a></h1>
<p>Welcome to the Starknet Book. This is your roadmap to Starknet’s key
features, its core philosophy, and its unique language, Cairo. Whether
you’re a developer, a crypto fan, or just curious, this book is your
starting point.</p>
<h1 id="what-is-starknet"><a class="header" href="#what-is-starknet">What is Starknet?</a></h1>
<p>Starknet is a Layer-2 network that makes Ethereum transactions faster,
cheaper, and more secure using zk-STARKs technology. Think of it as a
boosted layer on top of Ethereum, optimized for speed and cost.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<p>These are some key features of Starknet:</p>
<ul>
<li>
<p>Low Costs: Transactions on Starknet cost less than on Ethereum.
Future updates like Volition and EIP 4844 will make it even cheaper.</p>
</li>
<li>
<p>Developer-Friendly: Starknet lets developers easily build
decentralized apps using its native language, Cairo.</p>
</li>
<li>
<p>Speed and Efficiency: Upcoming releases aim to make transactions
even faster and cheaper.</p>
</li>
<li>
<p>CVM: Thanks to Cairo, Starknet runs on it´s own VM, called Cairo VM
(CVM), that allow us to innovate beyond the Ethereum Virtual Machine
(EVM) and create a new paradigm for decentralized applications.</p>
</li>
</ul>
<p>Here some of them:</p>
<ul>
<li>
<p>Account Abstraction: Implemented at the protocol level, this
facilitates diverse signing schemes while ensuring user security and
self-custody of assets.</p>
</li>
<li>
<p>Volition: Will be implemented on testnet during Q4 2023 will allow
developers to regulate data availability on Ethereum (L1) or on
Starknet (L2). Reducing L1 onchain data can radically reduce costs.</p>
</li>
<li>
<p>Paymaster: StarkNet will allow users to choose how to pay for
transaction fee, follows the guidelines laid out in EIP 4337 and
allows the transaction to specify a specific contract, a
<strong>Paymaster</strong>, to pay for their transaction. Supports gasless
transactions, enhancing user accessibility.</p>
</li>
</ul>
<h1 id="starknet-philosophy-built-for-developers"><a class="header" href="#starknet-philosophy-built-for-developers">Starknet Philosophy: Built for Developers</a></h1>
<p>Starknet is all about being developer-friendly. It’s a high-performance
platform designed to make building decentralized apps easier and more
powerful. Here are its pillars:</p>
<ul>
<li>
<p>Speed and Cost: Fast transactions and low fees make it ideal for
resource-heavy apps.</p>
</li>
<li>
<p>Cairo: This evolving language makes it easier to use validity proofs
and zk-STARKs tech.</p>
</li>
<li>
<p>Community: Active communication with developers through Telegram and
Discord.</p>
</li>
<li>
<p>Freedom: No more tech limitations. Build what you’ve always wanted.</p>
</li>
<li>
<p>Tools: A full suite of dev tools, including multiple SDKs and
testing frameworks.</p>
</li>
</ul>
<p>This philosophy drives Starknet’s roadmap.</p>
<h1 id="cairo-the-language-of-starknet"><a class="header" href="#cairo-the-language-of-starknet">Cairo: The Language of Starknet</a></h1>
<p>Cairo is tailor-made for creating STARK-based smart contracts. As
Starknet’s native language, it’s central to building scalable and secure
decentralized apps. To start learning now, check out the <a href="https://cairo-book.github.io/">Cairo
Book</a> and
<a href="https://github.com/shramee/starklings-cairo1">Starklings</a>.</p>
<p>Inspired by Rust, Cairo lets you write contracts safely and
conveniently.</p>
<h2 id="why-choose-cairo"><a class="header" href="#why-choose-cairo">Why Choose Cairo?</a></h2>
<p>Cairo is designed for <em>Provable Computation,</em> a new paradigm that lets
programs prove their correctness without re-running them. Here’s why it
stands out:</p>
<ul>
<li>
<p>Purpose-Built: Designed specifically for smart contracts.</p>
</li>
<li>
<p>No EVM Limits: Goes beyond what the Ethereum Virtual Machine can do.</p>
</li>
<li>
<p>Flexibility: Uses traits for more flexibility than inheritance.</p>
</li>
</ul>
<h1 id="governance"><a class="header" href="#governance">Governance</a></h1>
<p>The Starknet Foundation oversees Starknet’s governance. Its duties
include:</p>
<ul>
<li>
<p>Managing Starknet’s development and operations</p>
</li>
<li>
<p>Overseeing the Starknet DAO, which enables community involvement</p>
</li>
<li>
<p>Setting rules to maintain network integrity</p>
</li>
</ul>
<p>Our focus is on technical input and debate for improving the protocol.
While we value all perspectives, it’s often the technical insights that
steer us forward.</p>
<p>Members can influence Starknet by voting on changes. Here’s the process:
A new version is tested on the Goerli Testnet. Members then have six
days to review it. A Snapshot proposal is made, and the community votes.
A majority of <em>YES</em> votes means an upgrade to the Mainnet.</p>
<p>In short, governance is key to Starknet’s evolution.</p>
<p>To propose an improvement, create a SNIP.</p>
<h2 id="snip-starknet-improvement-proposals"><a class="header" href="#snip-starknet-improvement-proposals">SNIP: StarkNet Improvement Proposals</a></h2>
<p>SNIP is short for StarkNet Improvement Proposal. It’s essentially a
blueprint that details proposed enhancements or changes to the StarkNet
ecosystem. A well-crafted SNIP includes both the technical
specifications of the change and the reasons behind it. If you’re
proposing a SNIP, it’s your job to rally community support and document
any objections (more details
<a href="https://community.starknet.io/t/draft-simp-1-simp-purpose-and-guidelines/1197#what-is-a-snip-2">here</a>).
Once a SNIP is approved, it becomes a part of the Starknet protocol. All
the SNIPs can be found in <a href="https://github.com/starknet-io/SNIPs">this
repository</a>.</p>
<p>SNIPs serve three crucial roles:</p>
<ol>
<li>
<p>They are the main avenue for proposing new features or changes.</p>
</li>
<li>
<p>They act as a platform for technical discussions within the
community.</p>
</li>
<li>
<p>They document the decision-making process, offering a historical
view of how StarkNet has evolved.</p>
</li>
</ol>
<p>Because SNIPs are stored as text files in a <a href="https://github.com/starknet-io/SNIPs">version-controlled
repository</a>, you can easily track
changes and understand the history of proposals.</p>
<p>For those who are building on Starknet, SNIPs aren’t just
suggestions—they’re a roadmap. It’s beneficial for implementers to keep
a list of the SNIPs they’ve executed. This transparency helps users
gauge the state of a particular implementation or software library.</p>
<h1 id="development"><a class="header" href="#development">Development</a></h1>
<p>The Starknet Foundation actively nurtures the ecosystem by:</p>
<ul>
<li>
<p>Supporting research and development</p>
</li>
<li>
<p>Promoting Starknet technology adoption</p>
</li>
<li>
<p>Funding and organizing conferences and events for knowledge sharing</p>
</li>
</ul>
<h2 id="community-engagement"><a class="header" href="#community-engagement">Community Engagement</a></h2>
<p>Community strength matters to the Foundation. To foster engagement, it:</p>
<ul>
<li>
<p>Organizes events and discussions</p>
</li>
<li>
<p>Collaborates with allied blockchain communities</p>
</li>
<li>
<p>Creates avenues for community contributions to Starknet’s growth</p>
</li>
</ul>
<h1 id="what-is-starkware"><a class="header" href="#what-is-starkware">What is Starkware?</a></h1>
<p>Starkware, founded in 2018, focuses on zk-STARK technology. Its key
products include:</p>
<ul>
<li>
<p>StarkEx: A Layer 2 solution on Ethereum, efficient through STARK
proofs</p>
</li>
<li>
<p>Cairo: An open-source language for efficient, scalable computation
in decentralized apps (<a href="https://github.com/starkware-libs/cairo/tree/73c3ed0a1af65f53490866426ae49360b2304374">see
repo</a>)</p>
</li>
</ul>
<p>Starknet, its latest project, aims for community-driven evolution under
the Starknet Foundation’s governance.</p>
<h1 id="learning-resources"><a class="header" href="#learning-resources">Learning Resources</a></h1>
<p>For deeper insights into Starknet and Cairo:</p>
<ul>
<li>
<p><a href="https://book.starknet.io">The Starknet Book</a>: For mastering
Starknet</p>
</li>
<li>
<p><a href="https://cairo-book.github.io/">The Cairo Book</a>: For mastering Cairo</p>
</li>
<li>
<p><a href="https://github.com/shramee/starklings-cairo1">Starklings</a>:
Practical tutorials and examples</p>
</li>
</ul>
<h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>
<p>Starknet offers scalable, secure, and cost-effective decentralized apps,
backed by zk-STARKs technology. It’s not just the tech; Starknet puts
emphasis on empowering its developer community with robust tools and
resources. This book aims to guide all those keen to explore Starknet’s
technologies and philosophies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Starknet is a scalable Layer-2 solution on Ethereum. This guide will walk you through the process of deploying and interacting with your first Starknet smart contract using the Cairo programming language, a language tailored for creating validity proofs and that Starknet uses. For seasoned developers looking to understand the core concepts and get hands-on experience, this guide offers step-by-step instructions and essential details.</p>
<p>We will use the Starknet Remix Plugin to compile, deploy and interact with our smart contract. It is a great tool to get started with Starknet development.</p>
<ol>
<li>Visit <a href="https://remix.ethereum.org/">The Remix Project</a>.</li>
<li>Navigate to the ‘Plugins’ section in the bottom left corner.</li>
<li>Enable the “Starknet” plugin.</li>
</ol>
<img alt="Activate the Starknet Plugin" src="img/ch01-starknet-plugin.png" class="center" style="width: 100%;" />
<p><span class="caption">Activate the Starknet Plugin</span></p>
<ol start="4">
<li>After enabling, the Starknet logo appears on the left sidebar. Click it to interact with opened Cairo files.</li>
</ol>
<h2 id="introduction-to-starknet-smart-contracts"><a class="header" href="#introduction-to-starknet-smart-contracts">Introduction to Starknet Smart Contracts</a></h2>
<p>The script below is a simple <code>Ownable</code> contract pattern written in Cairo for Starknet. It features:</p>
<ul>
<li>An ownership system.</li>
<li>A method to transfer ownership.</li>
<li>A method to check the current owner.</li>
<li>An event notification for ownership changes.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::ContractAddress;

#[starknet::interface]
trait OwnableTrait&lt;T&gt; {
    fn transfer_ownership(ref self: T, new_owner: ContractAddress);
    fn get_owner(self: @T) -&gt; ContractAddress;
}

#[starknet::contract]
mod Ownable {
    use super::ContractAddress;
    use starknet::get_caller_address;

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
      OwnershipTransferred1: OwnershipTransferred1,  
    }

    #[derive(Drop, starknet::Event)]
    struct OwnershipTransferred1 {
        #[key]
        prev_owner: ContractAddress,
        #[key]
        new_owner: ContractAddress,
    }

    #[storage]
    struct Storage {
        owner: ContractAddress,
    }

    #[constructor]
    fn constructor(ref self: ContractState, init_owner: ContractAddress) {
        self.owner.write(init_owner);
    }

    #[external(v0)]
    impl OwnableImpl of super::OwnableTrait&lt;ContractState&gt; {
        fn transfer_ownership(ref self: ContractState, new_owner: ContractAddress) {
            self.only_owner();
            let prev_owner = self.owner.read();
            self.owner.write(new_owner);
            self.emit(Event::OwnershipTransferred1(OwnershipTransferred1 {
                prev_owner: prev_owner,
                new_owner: new_owner,
            }));
        }

        fn get_owner(self: @ContractState) -&gt; ContractAddress {
            self.owner.read()
        }
    }

    #[generate_trait]
    impl PrivateMethods of PrivateMethodsTrait {
        fn only_owner(self: @ContractState) {
            let caller = get_caller_address();
            assert(caller == self.owner.read(), 'Caller is not the owner');
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="components-breakdown"><a class="header" href="#components-breakdown">Components Breakdown</a></h3>
<p>The following is a brief description of the components in the contract. We will get into more details when we get deeper into Cairo so feel free to skip this section for now if you are not familiar with smart contract development.</p>
<ol>
<li><strong>Dependencies and Interface</strong>:
<ul>
<li><strong><code>starknet::ContractAddress</code></strong>: Represents a Starknet contract address.</li>
<li><strong><code>OwnableTrait</code></strong>: Specifies functions for transferring and getting ownership.</li>
</ul>
</li>
<li><strong>Events</strong>:
<ul>
<li><strong><code>OwnershipTransferred1</code></strong>: Indicates ownership change with previous and new owner details.</li>
</ul>
</li>
<li><strong>Storage</strong>:
<ul>
<li><strong><code>Storage</code></strong>: Holds the contract's state with the current owner's address.</li>
</ul>
</li>
<li><strong>Constructor</strong>:
<ul>
<li>Initializes the contract with a starting owner.</li>
</ul>
</li>
<li><strong>External Functions</strong>:
<ul>
<li>Functions for transferring ownership and retrieving the current owner's details.</li>
</ul>
</li>
<li><strong>Private Methods</strong>:
<ul>
<li><strong><code>only_owner</code></strong>: Validates if the caller is the current owner.</li>
</ul>
</li>
</ol>
<h2 id="compilation-process"><a class="header" href="#compilation-process">Compilation Process</a></h2>
<p>To compile using Remix:</p>
<ol>
<li>
<p><strong>File Creation</strong></p>
<ul>
<li>Navigate to the &quot;File Explorer&quot; tab in Remix.</li>
<li>Create a new file named <code>Ownable.cairo</code> and input the previous code.</li>
</ul>
</li>
<li>
<p><strong>Compilation</strong></p>
<ul>
<li>Choose the <code>Ownable.cairo</code> file.</li>
<li>In the &quot;Starknet&quot; tab, select &quot;Compile Ownable.cairo&quot;.</li>
<li>Post-compilation, an &quot;artifacts&quot; folder emerges containing the compiled contract in two distinct formats: Sierra (JSON file) and CASM. For Starknet deployment, Remix will use the Sierra file. Do not worry about this process for now; we will cover it in detail in a later chapter. For now, Remix will handle the compilation and deployment for us.</li>
</ul>
</li>
</ol>
<img alt="Artifacts folder after compilation" src="img/ch01-remix-file.png" class="center" style="width: 100%;" />
<p><span class="caption">Artifacts folder after compilation</span></p>
<h2 id="deployment-on-the-development-network"><a class="header" href="#deployment-on-the-development-network">Deployment on the Development Network</a></h2>
<p>To set your smart contract in motion, an initial owner must be defined. The Constructor function needs this information.</p>
<p>Here's a step-by-step guide to deploying your smart contract on the development network:</p>
<ol>
<li>
<p><strong>Select the Appropriate Network</strong></p>
<ul>
<li>Go to the Environment selection tab.</li>
<li>Choose &quot;Remote Devnet&quot; for deploying your inaugural contract on a development network.</li>
</ul>
</li>
<li>
<p><strong>Choose a Devnet Account</strong></p>
<ul>
<li>Under &quot;Devnet account selection&quot;, a list of accounts specific to the chosen devnet is presented.</li>
<li>Pick any account and copy its address.</li>
</ul>
</li>
<li>
<p><strong>Initiating Deployment</strong></p>
<ul>
<li>Navigate to the &quot;Starknet&quot; tab.</li>
<li>Input the copied address into the <code>init_owner</code> variable.</li>
<li>Click on &quot;Deploy ownable.cairo&quot;.</li>
</ul>
</li>
</ol>
<p>Post-deployment, Remix's terminal will send various logs. These logs provide crucial details, including:</p>
<ul>
<li><code>transaction_hash</code>: The unique hash of the transaction. This hash can be used to track the transaction's status.</li>
<li><code>contract_address</code>: The address of the deployed contract. Use this address to interact with your contract.</li>
<li><code>calldata</code>: Contains the <code>init_owner</code> address fed to the constructor.</li>
</ul>
<pre><code class="language-bash">{
  &quot;transaction_hash&quot;: &quot;0x275e6d2caf9bc98b47ba09fa9034668c6697160a74de89c4655e2a70be84247&quot;,
  &quot;contract_address&quot;: &quot;0x5eb239955ad4c4333b8ab83406a3cf5970554b60a0d8e78a531df18c59a0db9&quot;,
    ...
  &quot;calldata&quot;: [
    &quot;0x4d9c8282b5633eeb1aab56393690d76f71e32f1b7be1bea03eb03e059245a28&quot;
  ],
    ...
}
</code></pre>
<p>By following the above process, you successfully deploy your smart contract on the development network.</p>
<h2 id="interaction-with-the-contract"><a class="header" href="#interaction-with-the-contract">Interaction with the Contract</a></h2>
<p>With the contract now active on the development network, interaction becomes possible. Here's a guide to effectively interact with your contract on Starknet:</p>
<ol>
<li>
<p><strong>Initiating Interaction</strong></p>
<ul>
<li>Navigate to the &quot;Starknet&quot; tab.</li>
<li>Select the &quot;Interact&quot; option.</li>
</ul>
</li>
<li>
<p><strong>Calling the <code>get_owner</code> Function</strong></p>
<ul>
<li>Choose the <code>get_owner</code> function. Since this function doesn't require arguments, the calldata field remains blank. (This is a read function, hence calling it is termed as a &quot;call&quot;.)</li>
<li>Press the &quot;get_owner&quot; button. Your terminal will display the result, revealing the owner's address provided during the contract's deployment as calldata for the constructor:</li>
</ul>
</li>
</ol>
<pre><code class="language-bash">{
  &quot;response&quot;: {
    &quot;result&quot;: [
      &quot;0x4d9c8282b5633eeb1aab56393690d76f71e32f1b7be1bea03eb03e059245a28&quot;
    ]
  },
  &quot;contract&quot;: &quot;ownable.cairo&quot;,
  &quot;function&quot;: &quot;get_owner&quot;
}
</code></pre>
<p>This call currently doesn't spend gas because the function does not change the state of the contract.</p>
<ol start="3">
<li><strong>Invoking the <code>transfer_ownership</code> Function</strong></li>
</ol>
<ul>
<li>Now, for the <strong><code>transfer_ownership</code></strong> function, which requires the new owner's address as input.</li>
<li>Enter this address into the calldata field. (For this, use any address from the &quot;Devnet account selection&quot; listed in the Environment tab.)</li>
<li>Click the &quot;transfer_ownership&quot; button. The terminal then showcases the transaction hash indicating the contract's state alteration. Since we are altering the contract's state this typo of interaction is called an &quot;invoke&quot; and needs to be signed by the account that is calling the function.</li>
</ul>
<p>For these transactions, the terminal logs will exhibit a &quot;status&quot; variable, indicating the transaction's fate. If the status reads &quot;ACCEPTED_ON_L2&quot;, the Sequencer has accepted the transaction, pending block inclusion. However, a &quot;REJECTED&quot; status signifies the Sequencer's disapproval, and the transaction won't feature in the upcoming block. More often than not, this transaction gains acceptance, leading to a contract state modification. On calling the <strong><code>get_owner</code></strong> function again we get this:</p>
<pre><code class="language-bash">{
  &quot;response&quot;: {
    &quot;result&quot;: [
      &quot;0x20884fd341e11a00b9d31600c332f126f5c3f9ffd2aa93cb43dee9f90176d4f&quot;
    ]
  },
  &quot;contract&quot;: &quot;ownable.cairo&quot;,
  &quot;function&quot;: &quot;get_owner&quot;
}
</code></pre>
<p>You've now adeptly compiled, deployed, and interacted with your inaugural Starknet smart contract. Well done!</p>
<h2 id="deploying-on-starknet-testnet"><a class="header" href="#deploying-on-starknet-testnet">Deploying on Starknet Testnet</a></h2>
<p>After testing your smart contract on a development network, it's time to deploy it to the Starknet Testnet. Starknet Testnet is a public platform available for everyone, ideal for testing smart contracts and collaborating with fellow developers.</p>
<p>First you need to create a Starknet account.</p>
<h3 id="smart-wallet-setup"><a class="header" href="#smart-wallet-setup">Smart Wallet Setup</a></h3>
<p>Before deploying your smart contract to Starknet, you must handle the transaction cost. While deploying to the Starknet Goerli Testnet is free, a smart wallet account is essential. You can set up a smart wallet using either:</p>
<ul>
<li><a href="https://braavos.app/">Braavos</a></li>
<li><a href="https://www.argent.xyz/argent-x/">Argent</a></li>
</ul>
<p>Both are reliable Starknet wallets offering enhanced security and accessibility features thanks to the possibilities that the Cairo VM brings, such as Account Abstraction (keep reading the Book for more on this).</p>
<ol>
<li>Install the recommended chrome/brave extension for your chosen wallet.</li>
<li>Follow your wallet provider's instructions to deploy your account.
<ol>
<li>Use the <a href="https://faucet.goerli.starknet.io/">Starknet Faucet</a> to fund your account.</li>
</ol>
</li>
<li>Deploy the account to the network. This usually takes around 10 seconds.</li>
</ol>
<p>Once set up, you're ready to deploy your smart contracts to the Starknet Testnet.</p>
<h3 id="deployment-and-interaction"><a class="header" href="#deployment-and-interaction">Deployment and Interaction</a></h3>
<ol>
<li>Follow the previous deployment steps.</li>
<li>In the 'Environment selection' tab, choose 'Wallet Selection'.</li>
<li>Select your Starknet account and continue with deploying and interacting with your contract.</li>
</ol>
<p>You can monitor transaction hashes and addresses using any Starknet block explorers like:</p>
<ul>
<li><a href="https://testnet.starkscan.co/">Starkscan</a></li>
<li><a href="https://goerli.voyager.online/">Voyager</a></li>
</ul>
<p>These tools provide a visual representation of transactions and contract state alterations. Notably, when you alter the contract ownership using the <code>transfer_ownership</code> function, the event emitted by the contract appears in the block explorer. It's an effective method to track contract events.</p>
<h2 id="your-next-steps"><a class="header" href="#your-next-steps">Your Next Steps</a></h2>
<p>Decide your direction from the following choices:</p>
<ol>
<li>
<p><strong>Deepen Your Starknet Knowledge</strong>: For an extensive grasp of Starknet's inner workings and potential use cases, delve into Chapter 3 of the Starknet Book. This chapter details Starknet’s architectural nuances. Then go ahead from there.</p>
</li>
<li>
<p><strong>Dive into Cairo</strong>: If you're more attuned to coding and wish to craft Starknet contracts, then Cairo is essential. It stands as Starknet's core contract language. Begin with Chapters 1-6 of the <a href="https://book.cairo-lang.org/title-page.html">Cairo Book</a>, ranging from basics in <em>Getting Started</em> to more advanced aspects such as <em>Enums and Pattern Matching</em>. Conclude by navigating to the <a href="https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html">Starknet Smart Contracts chapter</a>, ensuring you have a well-rounded understanding.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-tooling"><a class="header" href="#starknet-tooling">Starknet Tooling</a></h1>
<p>To make the most of this chapter, a basic grasp of the Cairo programming
language is advised. We suggest reading chapters 1-6 of the <a href="https://book.cairo-lang.org/title-page.html">Cairo
Book</a>, covering topics from
<em>Getting Started</em> to <em>Enums and Pattern Matching.</em> Follow this by
studying the <a href="https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html">Starknet Smart Contracts
chapter</a>
in the same book. With this background, you’ll be well-equipped to
understand the examples presented here.</p>
<p>Today, Starknet provides all essential tools for building decentralized
applications (dApps), compatible with multiple languages like
JavaScript, Rust, and Python. You can use the Starknet SDK for
development. Front-end developers can use Starknet.js with React, while
Rust and Python work well for back-end tasks.</p>
<p>We welcome contributors to enhance existing tools or develop new
solutions.</p>
<p>In this chapter, you’ll explore:</p>
<ul>
<li>
<p>Frameworks: Build using Protostar or Hardhat</p>
</li>
<li>
<p>SDKs: Discover multi-language support through Starknet.js,
Starknet-rs, Starknet_py, and Caigo</p>
</li>
<li>
<p>Front-end Development: Use Starknet.js and React</p>
</li>
<li>
<p>Testing: Understand testing methods with Protostar and the Devnet</p>
</li>
</ul>
<p>By chapter’s end, you’ll have a complete grasp of Starknet’s toolset,
enabling efficient dApp development.</p>
<p>Here’s a quick rundown of the tools that could be used for Starknet
development and that we’ll cover in this chapter:</p>
<ol>
<li>
<p>Scarb: A package manager that compiles your contracts.</p>
</li>
<li>
<p>Starkli: A CLI tool for interacting with the Starknet network.</p>
</li>
<li>
<p>Foundry: For contract testing.</p>
</li>
<li>
<p>Katana: Creates a local test node.</p>
</li>
<li>
<p>SDKs: starknet.js, Starknet.py, and starknet.rs interface with
Starknet using common programming languages.</p>
</li>
<li>
<p>Starknet-react: Builds front-end apps using React.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>This chapter walks you through setting up your Starknet development
tools.</p>
<p>Essential tools to install:</p>
<ol>
<li>
<p><a href="https://github.com/xJonathanLEI/starkli">Starkli</a> - A CLI tool for
interacting with Starknet. More tools are discussed in Chapter 2.</p>
</li>
<li>
<p><a href="https://github.com/software-mansion/scarb">Scarb</a> - Cairo’s package
manager that compiles code to Sierra, a mid-level language between
Cairo and CASM.</p>
</li>
</ol>
<p>For support or queries, visit our <a href="https://github.com/starknet-edu/starknetbook/issues">GitHub
Issues</a> or contact
espejelomar on Telegram.</p>
<h2 id="starkli-installation"><a class="header" href="#starkli-installation">Starkli Installation</a></h2>
<p>Easily install Starkli using Starkliup, an installer invoked through the
command line.</p>
<pre><code class="language-bash">curl https://get.starkli.sh | sh
starkliup
</code></pre>
<p>Restart your terminal and confirm installation:</p>
<pre><code class="language-bash">starkli --version
</code></pre>
<p>To upgrade Starkli, simply repeat the steps.</p>
<h2 id="scarb-package-manager-installation"><a class="header" href="#scarb-package-manager-installation">Scarb Package Manager Installation</a></h2>
<p>We will get deeper into Scarb later in this chapter. For now, we will go over the installation process.</p>
<p>For macOS and Linux:</p>
<pre><code class="language-bash">    curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh
</code></pre>
<p>For Windows, follow manual setup in the <a href="https://docs.swmansion.com/scarb/download.html#windows">Scarb
documentation</a>.</p>
<p>Restart the terminal and run:</p>
<pre><code class="language-bash">    scarb --version
</code></pre>
<p>To upgrade Scarb, rerun the installation command.</p>
<p>You are now set to code in Cairo and deploy to Starknet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h1>
<p>In this chapter, you’ll learn how to compile, deploy, and interact with
a Starknet smart contract written in Cairo.</p>
<p>First, confirm that the following commands work on your system. If they
don’t, refer to Basic Installation in this chapter.</p>
<pre><code class="language-bash">    scarb --version  # For Cairo code compilation
    starkli --version  # To interact with Starknet
</code></pre>
<h2 id="find-the-compiler-versions-supported"><a class="header" href="#find-the-compiler-versions-supported">Find the compiler versions supported</a></h2>
<p>We have to make sure that our Starkli compiler version match Scarb
compiler version</p>
<p>To find the compiler versions supported by Starkli, execute:</p>
<pre><code class="language-bash">    starkli declare --help
</code></pre>
<p>You’ll see a list of possible compiler versions under the
<code>--compiler-version</code> flag.</p>
<pre><code class="language-bash">    ...
    --compiler-version &lt;COMPILER_VERSION&gt;
              Statically-linked Sierra compiler version [possible values: [COMPILER VERSIONS]]]
    ...
</code></pre>
<p>Note that the Scarb compiler version might not align with Starkli’s
supported versions. To check Scarb’s version:</p>
<pre><code class="language-bash">    scarb --version
</code></pre>
<p>You’ll see a list that contains scarb, cairo and sierra version.</p>
<pre><code class="language-bash">    scarb &lt;SCARB VERSION&gt;
    cairo: &lt;COMPILER VERSION&gt;
    sierra: &lt;SIERRA VERSION&gt;
</code></pre>
<p>If there’s a mismatch, it is suggested that you install the version of
Scarb that uses the compiler version that Starkli supports. You can find
previous releases on
<a href="https://github.com/software-mansion/scarb/releases">Scarb</a>'s GitHub
repo.</p>
<p>To install a specific version, such as <code>0.6.1</code>, run:</p>
<pre><code class="language-bash">    curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh -s -- -v 0.6.1
</code></pre>
<h2 id="smart-wallet-setup-1"><a class="header" href="#smart-wallet-setup-1">Smart Wallet Setup</a></h2>
<p>A smart wallet comprises a Signer and an Account Descriptor. The Signer
is a smart contract with a private key for signing transactions, while
the Account Descriptor is a JSON file detailing the wallet’s address and
public key.</p>
<ol>
<li>
<p>Use Braavos or Argent X browser extensions to create your smart
wallet.</p>
</li>
<li>
<p>Follow the provided instructions for your chosen wallet (Argent or
Braavos).</p>
</li>
<li>
<p>Fund your wallet with ETH. Use <a href="https://faucet.goerli.starknet.io/">Starknet Goerli
Faucet</a> as needed.</p>
</li>
</ol>
<p>Now you’re ready to interact with Starknet smart contracts.</p>
<h3 id="creating-a-signer"><a class="header" href="#creating-a-signer">Creating a Signer</a></h3>
<p>The Signer is an essential smart contract capable of signing
transactions in Starknet. You’ll need the private key from your smart
wallet to create one, from which the public key can be derived.</p>
<p>Starkli enables secure storage of your private key through a keystore
file. This encrypted file can be accessed using a password and is
generally stored in the default Starkli directory.</p>
<p>First, create the default directory:</p>
<pre><code class="language-bash">    mkdir ~/.starkli-wallets/deployer -p
</code></pre>
<p>Then generate the keystore file. The signer command contains subcommands
for creating a keystore file from a private key or completely create a
new one. In this tutorial, we’ll use the private key option which is the
most common use case. You need to provide the path to the keystore file
you want to create. You can give any name to the keystore file, you will
likely have several wallets. In this tutorial, we will use the name
<code>my_keystore_ 1.json</code>.</p>
<pre><code class="language-bash">    starkli signer keystore from-key ~/.starkli-wallets/deployer/my_keystore_1.json
    Enter private key:
    Enter password:
</code></pre>
<p>In the private key prompt, paste the private key of your smart wallet.
In the password prompt, enter a password of your choice. You will need
this password to sign transactions using Starkli.</p>
<p>Export the private key from your Braavos or Argent wallet. For Argent X,
you can find it in the &quot;Settings&quot; section → Select your Account →
&quot;Export Private Key&quot;. For Braavos, you can find it in the &quot;Settings&quot;
section → &quot;Privacy and Security&quot; → &quot;Export Private Key&quot;.</p>
<p>While knowing the private key of a smart wallet is necessary to sign
transactions, it’s not sufficient. We also need to inform Starkli about
the signing mechanism employed by our smart wallet created by Braavos or
Argent X. Does it use an elliptic curve? If yes, which one? This is the
reason why we need an account descriptor file.</p>
<h4 id="optional-the-architecture-of-the-starknet-signer"><a class="header" href="#optional-the-architecture-of-the-starknet-signer">[OPTIONAL] The Architecture of the Starknet Signer</a></h4>
<p>The Starknet Signer plays an instrumental role in securing your
transactions. Let’s demystify what goes on under the hood.</p>
<p>Key Components:</p>
<ol>
<li>
<p><strong>Private Key</strong>: A 256-bit/32-byte/64-character (ignoring the <em>0x</em>
prefix) hexadecimal key that is the cornerstone of your wallet’s
security.</p>
</li>
<li>
<p><strong>Public Key</strong>: Derived from the private key, it’s also a
256-bit/32-byte/64-character hexadecimal key.</p>
</li>
<li>
<p><strong>Smart Wallet Address</strong>: Unlike Ethereum, the address here is
influenced by the public key, class hash, and a salt. <strong><a href="https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-address/">Learn more
in Starknet
Documentation</a></strong>.</p>
</li>
</ol>
<p>To view the details of the previously created keystore file:</p>
<pre><code class="language-bash">    cat ~/.starkli-wallets/deployer/my_keystore_1.json
</code></pre>
<p>Anatomy of the <code>keystore.json</code> File:</p>
<pre><code class="language-json">    {
      &quot;crypto&quot;: {
        &quot;cipher&quot;: &quot;aes-128-ctr&quot;,
        &quot;cipherparams&quot;: {
          &quot;iv&quot;: &quot;dba5f9a67456b121f3f486aa18e24db7&quot;
        },
        &quot;ciphertext&quot;: &quot;b3cda3df39563e3dd61064149d6ed8c9ab5f07fbcd6347625e081fb695ddf36c&quot;,
        &quot;kdf&quot;: &quot;scrypt&quot;,
        &quot;kdfparams&quot;: {
          &quot;dklen&quot;: 32,
          &quot;n&quot;: 8192,
          &quot;p&quot;: 1,
          &quot;r&quot;: 8,
          &quot;salt&quot;: &quot;6dd5b06b1077ba25a7bf511510ea0c608424c6657dd3ab51b93029244537dffb&quot;
        },
        &quot;mac&quot;: &quot;55e1616d9ddd052864a1ae4207824baac58a6c88798bf28585167a5986585ce6&quot;
      },
      &quot;id&quot;: &quot;afbb9007-8f61-4e62-bf14-e491c30fd09a&quot;,
      &quot;version&quot;: 3
    }
</code></pre>
<ul>
<li>
<p><strong><code>version</code></strong>: The version of the smart wallet implementation.</p>
</li>
<li>
<p><strong><code>id</code></strong>: A randomly generated identification string.</p>
</li>
<li>
<p><strong><code>crypto</code></strong>: Houses all encryption details.</p>
</li>
</ul>
<p>Inside <strong><code>crypto</code></strong>:</p>
<ul>
<li>
<p><strong><code>cipher</code></strong>: Specifies the encryption algorithm used, which in this
case is AES-128-CTR.</p>
<ul>
<li>
<p><strong>AES (Advanced Encryption Standard)</strong>: A globally accepted
encryption standard.</p>
</li>
<li>
<p><strong>128</strong>: Refers to the key size in bits, making it a 128-bit
key.</p>
</li>
<li>
<p><strong>CTR (Counter Mode)</strong>: A specific mode of operation for the AES
cipher.</p>
</li>
</ul>
</li>
<li>
<p><strong><code>cipherparams</code></strong>: Contains an Initialization Vector (IV), which
ensures that encrypting the same plaintext with the same key will
produce different ciphertexts.</p>
<ul>
<li><strong><code>iv</code> (Initialization Vector)</strong>: A 16-byte hex string that
serves as a random and unique starting point for each encryption
operation.</li>
</ul>
</li>
<li>
<p><strong><code>ciphertext</code></strong>: This is the private key after encryption, securely
stored so that only the correct password can reveal it.</p>
</li>
<li>
<p><strong><code>kdf</code> and <code>kdfparams</code></strong>: KDF stands for Key Derivation Function.
This adds a layer of security by requiring computational work,
making brute-force attacks harder.</p>
<ul>
<li>
<p><strong><code>dklen</code></strong>: The length (in bytes) of the derived key. Typically
32 bytes.</p>
</li>
<li>
<p><strong><code>n</code></strong>: A cost factor representing CPU/memory usage. A higher
value means more computational work is needed, thus increasing
security.</p>
</li>
<li>
<p><strong><code>p</code></strong>: Parallelization factor, affecting the computational
complexity.</p>
</li>
<li>
<p><strong><code>r</code></strong>: Block size for the hash function, again affecting
computational requirements.</p>
</li>
<li>
<p><strong><code>salt</code></strong>: A random value that is combined with the password to
deter dictionary attacks.</p>
</li>
</ul>
</li>
<li>
<p><strong><code>mac</code> (Message Authentication Code)</strong>: This is a cryptographic
code that ensures the integrity of the message (the encrypted
private key in this case). It is generated using a hash of both the
ciphertext and a portion of the derived key.</p>
</li>
</ul>
<h3 id="creating-an-account-descriptor"><a class="header" href="#creating-an-account-descriptor">Creating an Account Descriptor</a></h3>
<p>An Account Descriptor informs Starkli about your smart wallet’s unique
features, such as its signing mechanism. You can generate this
descriptor using Starkli’s <code>fetch</code> subcommand under the <code>account</code>
command. The <code>fetch</code> subcommand takes your on-chain wallet address as
input and generates the account descriptor file. The account descriptor
file is a JSON file that contains the details of your smart wallet.</p>
<pre><code class="language-bash">    starkli account fetch &lt;SMART_WALLET_ADDRESS&gt; --output ~/.starkli-wallets/deployer/my_account_1.json
</code></pre>
<p>After running the command, you’ll see a message like the one below.
We’re using a Braavos wallet as an example, but the steps are the same
for an Argent wallet.</p>
<pre><code class="language-bash">    Account contract type identified as: Braavos
    Description: Braavos official proxy account
    Downloaded new account config file: ~/.starkli-wallets/deployer/my_account_1.json
</code></pre>
<p>To see the details of your Account Descriptor, run:</p>
<pre><code class="language-bash">    cat ~/.starkli-wallets/deployer/my_account_1.json
</code></pre>
<p>Here’s what a typical descriptor might look like:</p>
<pre><code class="language-json">    {
      &quot;version&quot;: 1,
      &quot;variant&quot;: {
        &quot;type&quot;: &quot;braavos&quot;,
        &quot;version&quot;: 1,
        &quot;implementation&quot;: &quot;0x5dec330eebf36c8672b60db4a718d44762d3ae6d1333e553197acb47ee5a062&quot;,
        &quot;multisig&quot;: {
          &quot;status&quot;: &quot;off&quot;
        },
        &quot;signers&quot;: [
          {
            &quot;type&quot;: &quot;stark&quot;,
            &quot;public_key&quot;: &quot;0x49759ed6197d0d385a96f9d8e7af350848b07777e901f5570b3dc2d9744a25e&quot;
          }
        ]
      },
      &quot;deployment&quot;: {
        &quot;status&quot;: &quot;deployed&quot;,
        &quot;class_hash&quot;: &quot;0x3131fa018d520a037686ce3efddeab8f28895662f019ca3ca18a626650f7d1e&quot;,
        &quot;address&quot;: &quot;0x6dcb489c1a93069f469746ef35312d6a3b9e56ccad7f21f0b69eb799d6d2821&quot;
      }
    }
</code></pre>
<p>Note: The structure will differ if you use an Argent wallet.</p>
<h2 id="setting-up-environment-variables"><a class="header" href="#setting-up-environment-variables">Setting up Environment Variables</a></h2>
<p>To simplify Starkli commands, you can set environment variables. Two key
variables are crucial: one for the Signer’s keystore file location and
another for the Account Descriptor file.</p>
<pre><code class="language-bash">    export STARKNET_ACCOUNT=~/.starkli-wallets/deployer/my_account_1.json
    export STARKNET_KEYSTORE=~/.starkli-wallets/deployer/my_keystore_1.json
</code></pre>
<p>Setting these variables makes running Starkli commands easier and more
efficient.</p>
<h2 id="declaring-smart-contracts-in-starknet"><a class="header" href="#declaring-smart-contracts-in-starknet">Declaring Smart Contracts in Starknet</a></h2>
<p>Deploying a smart contract on Starknet involves two steps:</p>
<ul>
<li>
<p>Declare your contract’s code.</p>
</li>
<li>
<p>Deploy an instance of the declared code.</p>
</li>
</ul>
<p>To get started, navigate to the <code>contracts/</code> directory in the <a href="https://github.com/starknet-edu/starknetbook/tree/main/chapters/book/modules/chapter_1/pages/contracts">first
chapter</a>
of the Starknet Book repo. The <code>src/lib.cairo</code> file contains a basic
contract to practice with.</p>
<p>First, compile the contract using the Scarb compiler. If you haven’t
installed Scarb, follow the installation guide in the <a href="https://book.starknet.io/chapter_1/environment_setup.html">Setting up your
Environment</a>
section.</p>
<pre><code class="language-bash">    scarb build
</code></pre>
<p>This creates a compiled contract in <code>target/dev/</code> as
&quot;contracts_Ownable.sierra.json&quot; (in Chapter 2 of the book we will learn
more details about Scarb).</p>
<p>With the smart contract compiled, we’re ready to declare it using
Starkli. Before declaring your contract, decide on an RPC provider.</p>
<h3 id="choosing-an-rpc-provider"><a class="header" href="#choosing-an-rpc-provider">Choosing an RPC Provider</a></h3>
<p>There are three main options for RPC providers, sorted by ease of use:</p>
<ol>
<li>
<p><strong>Starknet Sequencer’s Gateway</strong>: The quickest option and it’s the
default for Starkli for now. The sequencer gateway is deprecated and
will be disabled by StarkWare soon. You’re strongly recommended to
use a third-party JSON-RPC API provider like Infura, Alchemy, or
Chainstack.</p>
</li>
<li>
<p><strong>Infura or Alchemy</strong>: A step up in complexity. You’ll need to set
up an API key and choose an endpoint. For Infura, it would look like
<code>https://starknet-goerli.infura.io/v3/&lt;API_KEY&gt;</code>. Learn more in the
<a href="https://docs.infura.io/networks/starknet/how-to/choose-a-network">Infura
documentation</a>.</p>
</li>
<li>
<p><strong>Your Own Node</strong>: For those who want full control. It’s the most
complex but offers the most freedom. Check out <a href="https://book.starknet.io/chapter_4/node.html">Chapter 4 of the
Starknet Book</a> or
<a href="https://www.kasar.io/">Kasar</a> for setup guides.</p>
</li>
</ol>
<p>In this tutorial, we will use Alchemy. We can set the STARKNET_RPC
environment variable to make command invocations easier:</p>
<pre><code class="language-bash">    export STARKNET_RPC=&quot;https://starknet-goerli.g.alchemy.com/v2/&lt;API_KEY&gt;&quot;
</code></pre>
<h3 id="declaring-your-contract"><a class="header" href="#declaring-your-contract">Declaring Your Contract</a></h3>
<p>Run this command to declare your contract using the default Starknet
Sequencer’s Gateway:</p>
<pre><code class="language-bash">    starkli declare target/dev/contracts_Ownable.sierra.json
</code></pre>
<p>According to the <code>STARKNET_RPC</code> url, starkli can recognize the target
blockchain network, in this case &quot;goerli&quot;, so it is not necessary
explicitly specify it.</p>
<p>Unless you’re working with custom networks where it’s infeasible for
Starkli to detect the right compiler version, you shouldn’t need to
manually choose a version with <code>--network</code> and <code>--compiler-version</code>.</p>
<p>If you encounter an &quot;Error: Invalid contract class,&quot; it likely means
your Scarb’s compiler version is incompatible with Starkli. Follow the
steps above to align the versions. Starkli usually supports compiler
versions accepted by mainnet, even if Scarb’s latest version is not yet
compatible.</p>
<p>After running the command, you’ll receive a contract class hash. This
unique hash serves as the identifier for your contract class within
Starknet. For example:</p>
<pre><code class="language-bash">    Class hash declared: 0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8
</code></pre>
<p>You can think of this hash as the contract class’s <em>address.</em> Use a
block explorer like
<a href="https://testnet.starkscan.co/class/0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8">StarkScan</a>
to verify this hash on the blockchain.</p>
<p>If the contract class you’re attempting to declare already exists, it is
ok we can continue. You’ll receive a message like:</p>
<pre><code class="language-bash">    Not declaring class as its already declared. Class hash:
    0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8
</code></pre>
<h2 id="deploying-smart-contracts-on-starknet"><a class="header" href="#deploying-smart-contracts-on-starknet">Deploying Smart Contracts on Starknet</a></h2>
<p>To deploy a smart contract, you’ll need to instantiate it on Starknet’s
testnet. This process involves executing a command that requires two
main components:</p>
<ol>
<li>
<p>The class hash of your smart contract.</p>
</li>
<li>
<p>Any constructor arguments that the contract expects.</p>
</li>
</ol>
<p>In our example, the constructor expects an <em>owner</em> address. You can
learn more about constructors in [Chapter 12 of The Cairo
Book](<a href="https://book.cairo-lang.org/ch99-01-03-02-contract-functions.html?highlight=constructor#1-constructors">https://book.cairo-lang.org/ch99-01-03-02-contract-functions.html?highlight=constructor#1-constructors</a>).</p>
<p>The command would look like this:</p>
<pre><code class="language-bash">    starkli deploy \
        &lt;CLASS_HASH&gt; \
        &lt;CONSTRUCTOR_INPUTS&gt;
</code></pre>
<p>Here’s a specific example with an actual class hash and constructor
inputs (as the owner address use the address of your smart wallet so you
can invoke the transfer_ownership function later):</p>
<pre><code class="language-bash">    starkli deploy \
        0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8 \
        0x02cdAb749380950e7a7c0deFf5ea8eDD716fEb3a2952aDd4E5659655077B8510
</code></pre>
<p>After executing the command and entering your password, you should see
output like the following:</p>
<pre><code class="language-bash">    Deploying class 0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8 with salt 0x065034b27a199cbb2a5b97b78a8a6a6c6edd027c7e398b18e5c0e5c0c65246b7...
    The contract will be deployed at address 0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012
    Contract deployment transaction: 0x0743de1e233d38c4f3e9fb13f1794276f7d4bf44af9eac66e22944ad1fa85f14
    Contract deployed:
    0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012
</code></pre>
<p>The contract is now live on the Starknet testnet. You can verify its
status using a block explorer like
<a href="https://testnet.starkscan.co/contract/0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012">StarkScan</a>.
On the &quot;Read/Write Contract&quot; tab, you’ll see the contract’s external
functions.</p>
<h2 id="interacting-with-the-starknet-contract"><a class="header" href="#interacting-with-the-starknet-contract">Interacting with the Starknet Contract</a></h2>
<p>Starkli enables interaction with smart contracts via two primary
methods: <code>call</code> for read-only functions and <code>invoke</code> for write functions
that modify the state.</p>
<h3 id="calling-a-read-function"><a class="header" href="#calling-a-read-function">Calling a Read Function</a></h3>
<p>The <code>call</code> command enables you to query a smart contract function
without sending a transaction. For instance, to find out who the current
owner of the contract is, you can use the <code>get_owner</code> function, which
requires no arguments.</p>
<pre><code class="language-bash">    starkli call \
        &lt;CONTRACT_ADDRESS&gt; \
        get_owner
</code></pre>
<p>Replace <code>&lt;CONTRACT_ADDRESS&gt;</code> with the address of your contract. The
command will return the owner’s address, which was initially set during
the contract’s deployment:</p>
<pre><code class="language-bash">    [
        &quot;0x02cdab749380950e7a7c0deff5ea8edd716feb3a2952add4e5659655077b8510&quot;
    ]
</code></pre>
<h2 id="invoking-a-write-function"><a class="header" href="#invoking-a-write-function">Invoking a Write Function</a></h2>
<p>You can modify the contract’s state using the <code>invoke</code> command. For
example, let’s transfer the contract’s ownership with the
<code>transfer_ownership</code> function.</p>
<pre><code class="language-bash">    starkli invoke \
        &lt;CONTRACT_ADDRESS&gt; \
        transfer_ownership \
        &lt;NEW_OWNER_ADDRESS&gt;
</code></pre>
<p>Replace <code>&lt;CONTRACT_ADDRESS&gt;</code> with the address of the contract and
<code>&lt;NEW_OWNER_ADDRESS&gt;</code> with the address you want to transfer ownership
to. If the smart wallet you’re using isn’t the contract’s owner, an
error will appear. Note that the initial owner was set when deploying
the contract:</p>
<pre><code class="language-bash">    Execution was reverted; failure reason: [0x43616c6c6572206973206e6f7420746865206f776e6572].
</code></pre>
<p>The failure reason is encoded as a felt. o decode it, use the starkli’s
<code>parse-cairo-string</code> command.</p>
<pre><code class="language-bash">    starkli parse-cairo-string &lt;ENCODED_ERROR&gt;
</code></pre>
<p>For example, if you see
<code>0x43616c6c6572206973206e6f7420746865206f776e6572</code>, decoding it will
yield &quot;Caller is not the owner.&quot;</p>
<p>After a successful transaction on L2, use a block explorer like
StarkScan or Voyager to confirm the transaction status using the hash
provided by the <code>invoke</code> command.</p>
<p>To verify that the ownership has successfully transferred, you can call
the <code>get_owner</code> function again:</p>
<pre><code class="language-bash">    starkli call \
        &lt;CONTRACT_ADDRESS&gt; \
        get_owner
</code></pre>
<p>If the function returns the new owner’s address, the transfer was
successful.</p>
<p>Congratulations! You’ve successfully deployed and interacted with a
Starknet contract.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scarb-the-package-manager"><a class="header" href="#scarb-the-package-manager">Scarb: The Package Manager</a></h1>
<p>To make the most of this chapter, a basic grasp of the Cairo programming
language is advised. We suggest reading chapters 1-6 of the <a href="https://book.cairo-lang.org/title-page.html">Cairo
Book</a>, covering topics from
<em>Getting Started</em> to <em>Enums and Pattern Matching.</em> Follow this by
studying the <a href="https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html">Starknet Smart Contracts
chapter</a>
in the same book. With this background, you’ll be well-equipped to
understand the examples presented here.</p>
<p>Scarb is Cairo’s package manager designed for both Cairo and Starknet
projects. It handles dependencies, compiles projects, and integrates
with tools like Foundry. It is built by the same team that created
Foundry for Starknet.</p>
<h1 id="scarb-workflow"><a class="header" href="#scarb-workflow">Scarb Workflow</a></h1>
<p>Follow these steps to develop a Starknet contract using Scarb:</p>
<ol>
<li>
<p><strong>Initialize:</strong> Use <code>scarb new</code> to set up a new project, generating
a <code>Scarb.toml</code> file and initial <code>src/lib.cairo</code>.</p>
</li>
<li>
<p><strong>Code:</strong> Add your Cairo code in the <code>src</code> directory.</p>
</li>
<li>
<p><strong>Dependencies:</strong> Add external libraries using <code>scarb add</code>.</p>
</li>
<li>
<p><strong>Compile:</strong> Execute <code>scarb build</code> to convert your contract into
Sierra code.</p>
</li>
</ol>
<p>Scarb simplifies your development workflow, making it efficient and
streamlined.</p>
<h1 id="installation-1"><a class="header" href="#installation-1">Installation</a></h1>
<p>Scarb is cross-platform, supporting macOS, Linux, and Windows. For
installation, refer to the <a href="https://book.starknet.io/chapter_1/environment_setup.html#the_scarb_package_manager_installation">Chapter 1 setup
guide</a>.</p>
<h1 id="cairo-project-structure"><a class="header" href="#cairo-project-structure">Cairo Project Structure</a></h1>
<p>Next, we’ll dive into the key components that make up a Cairo project.</p>
<h2 id="cairo-packages"><a class="header" href="#cairo-packages">Cairo Packages</a></h2>
<p>Cairo packages, also referred to as &quot;crates&quot; in some contexts, are the
building blocks of a Cairo project. Each package must follow several
rules:</p>
<ul>
<li>
<p>A package must include a <code>Scarb.toml</code> file, which is Scarb’s
manifest file. It contains the dependencies for your package.</p>
</li>
<li>
<p>A package must include a <code>src/lib.cairo</code> file, which is the root of
the package tree. It allows you to define functions and declare used
modules.</p>
</li>
</ul>
<p>Package structures might look like the following case where we have a
package named <code>my_package</code>, which includes a <code>src</code> directory with the
<code>lib.cairo</code> file inside, a <code>snips</code> directory which in itself a package
we can use, and a <code>Scarb.toml</code> file in the top-level directory.</p>
<pre><code>my_package/
├── src/
│   ├── module1.cairo
│   ├── module2.cairo
│   └── lib.cairo
├── snips/
│   ├── src/
│   │   ├── lib.cairo
│   ├── Scarb.toml
└── Scarb.toml
</code></pre>
<p>Within the <code>Scarb.toml</code> file, you might have:</p>
<pre><code>[package]
name = &quot;my_package&quot;
version = &quot;0.1.0&quot;

[dependencies]
starknet = &quot;&gt;=2.0.1&quot;
snips = { path = &quot;snips&quot; }
</code></pre>
<p>Here starknet and snips are the dependencies of the package. The
<code>starknet</code> dependency is hosted on the Scarb registry (we do not need to
download it), while the <code>snips</code> dependency is located in the <code>snips</code>
directory.</p>
<h1 id="setting-up-a-project-with-scarb"><a class="header" href="#setting-up-a-project-with-scarb">Setting Up a Project with Scarb</a></h1>
<p>To create a new project using Scarb, navigate to your desired project
directory and execute the following command:</p>
<pre><code>$ scarb new hello_scarb
</code></pre>
<p>This command will create a new project directory named <code>hello_scarb</code>,
including a <code>Scarb.toml</code> file, a <code>src</code> directory with a <code>lib.cairo</code> file
inside, and initialize a new Git repository with a <code>.gitignore</code> file.</p>
<pre><code>hello_scarb/
├── src/
│   └── lib.cairo
└── Scarb.toml
</code></pre>
<p>Upon opening <code>Scarb.toml</code> in a text editor, you should see something
similar to the code snippet below:</p>
<pre><code>[package]
name = &quot;hello_scarb&quot;
version = &quot;0.1.0&quot;

# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html
[dependencies]
# foo = { path = &quot;vendor/foo&quot; }
</code></pre>
<h1 id="building-a-scarb-project"><a class="header" href="#building-a-scarb-project">Building a Scarb Project</a></h1>
<p>Clear all content in <code>src/lib.cairo</code> and replace with the following:</p>
<pre><code>// src/lib.cairo
mod hello_scarb;
</code></pre>
<p>Next, create a new file titled <code>src/hello_scarb.cairo</code> and add the
following:</p>
<pre><code>// src/hello_scarb.cairo
use debug::PrintTrait;
fn main() {
    'Hello, Scarb!'.print();
}
</code></pre>
<p>In this instance, the <code>lib.cairo</code> file contains a module declaration
referencing <em>hello_scarb</em>, which includes the <em>hello_scarb.cairo</em>
file’s implementation. For more on modules, imports, and the <code>lib.cairo</code>
file, please refer to the subchapter on <a href="https://book.starknet.io/chapter_2/imports.html">imports in Chapter
2</a>.</p>
<p>Scarb mandates that your source files be located within the <code>src</code>
directory.</p>
<p>To build (compile) your project from your <code>hello_scarb</code> directory, use
the following command:</p>
<pre><code>scarb build
</code></pre>
<p>This command compiles your project and produces the Sierra code in the
<code>target/dev/hello_scarb.sierra</code> file. Sierra serves as an intermediate
layer between high-level Cairo and compilation targets such as Cairo
Assembly (CASM). To understand more about Sierra, check out this
<a href="https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5/">article</a>.</p>
<p>To remove the build artifacts and delete the target directory, use the
<code>scarb clean</code> command.</p>
<h2 id="adding-dependencies"><a class="header" href="#adding-dependencies">Adding Dependencies</a></h2>
<p>Scarb facilitates the seamless management of dependencies for your Cairo
packages. Here are two methods to add dependencies to your project:</p>
<ul>
<li>Edit Scarb.toml File</li>
</ul>
<p>Open the Scarb.toml file in your project directory and locate the
<code>[dependencies]</code> section. If it doesn’t exist, add it. To include a
dependency hosted on a Git repository, use the following format:</p>
<pre><code>[dependencies]
alexandria_math = { git = &quot;https://github.com/keep-starknet-strange/alexandria.git&quot; }
</code></pre>
<p>For consistency, it’s recommended to pin Git dependencies to specific
commits. This can be done by adding the <code>rev</code> field with the commit
hash:</p>
<pre><code>[dependencies]
alexandria_math = { git = &quot;https://github.com/keep-starknet-strange/alexandria.git&quot;, rev = &quot;81bb93c&quot; }
</code></pre>
<p>After adding the dependency, remember to save the file.</p>
<ul>
<li>Use the scarb add Command</li>
</ul>
<p>Alternatively, you can use the <code>scarb add</code> command to add dependencies
to your project. Open your terminal and execute the following command:</p>
<pre><code>$ scarb add alexandria_math --git https://github.com/keep-starknet-strange/alexandria.git
</code></pre>
<p>This command will add the alexandria_math dependency from the specified
Git repository to your project.</p>
<p>To remove a dependency, you can use the <code>scarb rm</code> command.</p>
<p>Once a dependency is added, the Scarb.toml file will be automatically
updated with the new dependency information.</p>
<h2 id="using-dependencies-in-your-code"><a class="header" href="#using-dependencies-in-your-code">Using Dependencies in Your Code</a></h2>
<p>After dependencies are added to your project, you can start utilizing
them in your Cairo code.</p>
<p>For example, let’s assume you have added the alexandria_math
dependency. Now, you can import and utilize functions from the
alexandria_math library in your <code>src/hello_scarb.cairo</code> file:</p>
<pre><code>// src/hello_scarb.cairo
use alexandria_math::fibonacci;

fn main() -&gt; felt252 {
    fibonacci::fib(0, 1, 10)
}
</code></pre>
<p>In the above example, we import the fibonacci function from the
alexandria_math library and utilize it in the main function.</p>
<h1 id="scarb-cheat-sheet"><a class="header" href="#scarb-cheat-sheet">Scarb Cheat Sheet</a></h1>
<p>Here’s a quick cheat sheet of some of the most commonly used Scarb
commands:</p>
<ul>
<li>
<p><code>scarb new &lt;project_name&gt;</code>: Initialize a new project with the given
project name.</p>
</li>
<li>
<p><code>scarb build</code>: Compile your Cairo code into Sierra code.</p>
</li>
<li>
<p><code>scarb add &lt;dependency&gt; --git &lt;repository&gt;</code>: Add a dependency to
your project from a specified Git repository.</p>
</li>
<li>
<p><code>scarb rm &lt;dependency&gt;</code>: Remove a dependency from your project.</p>
</li>
<li>
<p><code>scarb run &lt;script&gt;</code>: Run a custom script defined in your
<code>Scarb.toml</code> file.</p>
</li>
</ul>
<p>Scarb is a versatile tool, and this is just the beginning of what you
can achieve with it. As you gain more experience in the Cairo language
and the Starknet platform, you’ll discover how much more you can do with
Scarb.</p>
<p>To stay updated on Scarb and its features, be sure to check the
<a href="https://docs.swmansion.com/scarb/docs.html">official Scarb
documentation</a> regularly.
Happy coding!</p>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starkli-a-cli-interface-"><a class="header" href="#starkli-a-cli-interface-">Starkli: A CLI interface 🚧</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="katana-a-local-node"><a class="header" href="#katana-a-local-node">Katana: A Local Node</a></h1>
<p><code>Katana</code> is an indispensable tool designed to aid in local development.
This creation by the <a href="https://github.com/dojoengine/dojo/blob/main/crates/katana/README.md">Dojo
team</a>
enables you to perform all Starknet-related activities in a local
environment, thus serving as an efficient platform for development and
testing.</p>
<p>We suggest employing either <code>katana</code> or <code>starknet-devnet</code> for testing
your contracts, with the latter discussed in detail in the following
subchapter. The <code>starknet-devnet</code> is a public testnet, maintained by the
<a href="https://github.com/Shard-Labs/starknet-devnet">Shard Labs team</a>. Both
these tools offer an effective environment for development and testing.</p>
<p>For an example of how to use <code>katana</code> to deploy and interact with a
contract, see <a href="https://book.starknet.io/chapter_2/deploy_call_invoke.html">Chapter 2’s Voting contract
example</a>.</p>
<h2 id="understanding-rpc-in-starknet"><a class="header" href="#understanding-rpc-in-starknet">Understanding RPC in Starknet</a></h2>
<p>Remote Procedure Call (RPC) establishes the communication between nodes
in the Starknet network. Essentially, it allows us to interact with a
node in the Starknet network. The RPC server is responsible for
receiving these calls.</p>
<p>RPC can be obtained from various sources: . To support the
decentralization of the Network, you can use your own local Starknet
node. Consult <a href="https://book.starknet.io/chapter_4/node.html">Chapter 4</a>
for guidelines on setting up your node. . For ease of access, consider
using a provider such as
<a href="https://docs.infura.io/networks/starknet/how-to">Infura</a> or
<a href="https://www.alchemy.com/starknet">Alchemy</a> to get an RPC client. . For
development and testing, a temporary local node such as <code>katana</code> can be
used.</p>
<h2 id="getting-started-with-katana"><a class="header" href="#getting-started-with-katana">Getting Started with Katana</a></h2>
<p>To install <code>katana</code> from its source code, run the following commands:</p>
<pre><code>mkdir ~/.dojo &amp;&amp; cd ~/.dojo
git clone https://github.com/dojoengine/dojo
cd dojo
cargo install --path ./crates/katana --locked --force
</code></pre>
<p>Once installed, confirm it with the version command:</p>
<pre><code>katana --version
</code></pre>
<p>Updating <code>katana</code> to its latest version involves going back to the
<code>dojo</code> directory and running the following commands:</p>
<pre><code>cd ~/.dojo/dojo
git pull

# If you are using a local Starknet node, ensure to stop it first.
cargo install --path ./crates/katana --locked --force
</code></pre>
<p>To initialize a local Starknet node, execute the following command:</p>
<pre><code>katana --accounts 3 --seed 0 --gas-price 250
</code></pre>
<p>The <code>--accounts</code> flag determines the number of accounts to be created,
while the <code>--seed</code> flag sets the seed for the private keys of these
accounts. This ensures that initializing the node with the same seed
will always yield the same accounts. Lastly, the <code>--gas-price</code> flag
specifies the transaction gas price.</p>
<p>Running the command produces output similar to this:</p>
<pre><code>██╗  ██╗ █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗
██║ ██╔╝██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗
█████╔╝ ███████║   ██║   ███████║██╔██╗ ██║███████║
██╔═██╗ ██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║
██║  ██╗██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║
╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝


PREFUNDED ACCOUNTS
==================

| Account address |  0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0
| Private key     |  0x0300001800000000300000180000000000030000000000003006001800006600
| Public key      |  0x01b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e

| Account address |  0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c
| Private key     |  0x0333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b
| Public key      |  0x04486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d

| Account address |  0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5
| Private key     |  0x07ca856005bee0329def368d34a6711b2d95b09ef9740ebf2c7c7e3b16c1ca9c
| Public key      |  0x07006c42b1cfc8bd45710646a0bb3534b182e83c313c7bc88ecf33b53ba4bcbc


ACCOUNTS SEED
=============
0


🚀 JSON-RPC server started: http://0.0.0.0:5050
</code></pre>
<p>The output includes the addresses, private keys, and public keys of the
created accounts. It also contains the seed used to generate the
accounts. This seed can be reused to create identical accounts in future
runs. Additionally, the output provides the URL of the JSON-RPC server.
This URL can be used to establish a connection to the local Starknet
node.</p>
<p>To stop the local Starknet node, simply press <code>Ctrl+C</code>.</p>
<p>The local Starknet node does not persist data. Hence, once it’s stopped,
all data will be erased.</p>
<p>For a practical demonstration of <code>katana</code> to deploy and interact with a
contract, see <a href="https://book.starknet.io/chapter_2/deploy_call_invoke.html">Chapter 2’s Voting contract
example</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-devnet-"><a class="header" href="#starknet-devnet-">Starknet Devnet 🚧</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-js-javascript-sdk"><a class="header" href="#starknet-js-javascript-sdk">Starknet-js: Javascript SDK</a></h1>
<p>Starknet.js is a JavaScript/TypeScript library designed to connect your
website or decentralized application (D-App) to Starknet. It aims to
mimic the architecture of <a href="https://docs.ethers.org/v5/">ethers.js</a>, so
if you are familiar with ethers, you should find Starknet.js easy to
work with.</p>
<img alt="Starknet-js in your dapp" src="img/ch02-starknet-js.png" class="center" style="width: 50%;" />
<p><span class="caption">Starknet-js in your dapp</span></p>
<h1 id="installation-2"><a class="header" href="#installation-2">Installation</a></h1>
<p>To install Starknet.js, follow these steps:</p>
<ul>
<li>For the latest official release (main branch):</li>
</ul>
<!-- -->
<pre><code>npm install starknet
</code></pre>
<ul>
<li>To use the latest features (merges in develop branch):</li>
</ul>
<!-- -->
<pre><code>npm install starknet@next
</code></pre>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>To build an app that users are able to connect to and interact with
Starknet, we recommend adding the
<a href="https://github.com/starknet-io/get-starknet">get-starknet</a> library,
which allows you to manage wallet connections.</p>
<p>With these tools ready, there are basically 3 main concepts to know on
the frontend: Account, Provider, and Contracts.</p>
<h3 id="account"><a class="header" href="#account">Account</a></h3>
<p>We can generally think of the account as the &quot;end user&quot; of a
dapp, and some user interaction will be involved to gain access to it.</p>
<p>Think of a dapp where the user connects their browser extension wallet
(such as ArgentX or Braavos) - if the user accepts the connection, that
gives us access to the account and signer, which can sign transactions
and messages.</p>
<p>Unlike Ethereum, where user accounts are Externally Owned Accounts,
Starknet <strong>accounts are contracts</strong>. This might not necessarily impact
your dapp’s frontend, but you should definitely be aware of this
difference.</p>
<pre><code class="language-ts">async function connectWallet() {
    const starknet = await connect();
    console.log(starknet.account);
    
    const nonce = await starknet.account.getNonce();
    const message = await starknet.account.signMessage(...)
}
</code></pre>
<p>The snippet above uses the <code>connect</code> function provided by <code>get-starknet</code> to establish a connection to the user wallet. Once connected, we are able to access account methods, such as <code>signMessage</code> or <code>execute</code>.</p>
<h3 id="provider"><a class="header" href="#provider">Provider</a></h3>
<p>The provider allows you to interact with the Starknet
network. You can think of it as a &quot;read&quot; connection to the blockchain,
as it doesn’t allow signing transactions or messages. Just like in
Ethereum, you can use a default provider, or use services such as Infura
or Alchemy, both of which support Starknet, to create an RPC provider.</p>
<p>By default, the Provider is a sequencer provider.</p>
<pre><code class="language-ts">export const provider = new Provider({
  sequencer: {
    network: &quot;goerli-alpha&quot;,
  },
  // rpc: {
  //   nodeUrl: INFURA_ENDPOINT
  // }
});

const block = await provider.getBlock(&quot;latest&quot;); // &lt;- Get latest block    
console.log(block.block_number);
</code></pre>
<h2 id="contracts"><a class="header" href="#contracts">Contracts</a></h2>
<p>Your frontend will likely be interacting with deployed
contracts. For each contract, there should be a counterpart on the
frontend. To create these instances, you will need the contract’s
address and ABI, and either a provider or signer.</p>
<pre><code class="language-ts">const contract = new Contract(
  abi_erc20,
  contractAddress,
  starknet.account
);

const balance = await contract.balanceOf(starknet.account.address);
const transfer = await contract.transfer(recipientAddress, amountFormatted);
//or: const transfer = await contract.invoke(&quot;transfer&quot;, [to, amountFormatted]); 

console.log(`Tx hash: ${transfer.transaction_hash}`);
</code></pre>
<p>If you create a contract instance with a provider, you’ll be limited to
calling read functions on the contract - only with a signer can you
change the state of the blockchain. However, you are able to connect a
previously created <code>Contract</code> instance with a new account:</p>
<pre><code class="language-ts">const contract = new Contract(
  abi_erc20,
  contractAddress,
  provider
);

contract.connect(starknet.account);
</code></pre>
<p>In the snippet above, after
calling the <code>connect</code> method, it would be possible to call read
functions on the contract, but not before.</p>
<h3 id="units"><a class="header" href="#units">Units</a></h3>
<p>If you have previous experience with web3, you know dealing
with units requires care, and Starknet is no exception. Once again, the
docs are very useful here, in particular <a href="https://www.starknetjs.com/docs/guides/define_call_message/">this section on data
transformation</a>.</p>
<p>Very often you will need to convert Cairo structs (such as Uint256) that
are returned from contracts into numbers:</p>
<pre><code class="language-ts">// Uint256 shape:
// { 
//    type: 'struct', 
//    low: Uint256.low, 
//    high: Uint256.high 
// 
// }
const balance = await contract.balanceOf(address); // &lt;- uint256
const asBN = uint256.uint256ToBN(uint256); // &lt;- uint256 into BN
const asString = asBN.toString() //&lt;- BN into string
</code></pre>
<p>And vice versa:</p>
<pre><code class="language-ts">const amount = 1;

const amountFormatted = {
    type: &quot;struct&quot;,
    ...uint256.bnToUint256(amount),
};
</code></pre>
<p>There are other helpful utils, besides <code>bnToUint256</code> and <code>uint256ToBN</code>,
provided by Starknet.js.</p>
<p>We now have a solid foundation to build a Starknet dapp. However, there
are framework specific tools that help us build Starknet dapps, which
are covered in chaper 5.</p>
<h2 id="additional-resources"><a class="header" href="#additional-resources">Additional Resources</a></h2>
<ul>
<li>
<p>Starknet.js GitHub Repository:
<a href="https://github.com/0xs34n/starknet.js">https://github.com/0xs34n/starknet.js</a></p>
</li>
<li>
<p>Official Starknet.js Website and documentation:
<a href="https://www.starknetjs.com/">https://www.starknetjs.com/</a></p>
</li>
</ul>
<p>Stay tuned for more updates on Starknet.js, including detailed guides,
examples, and comprehensive documentation.</p>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-react-react-integration"><a class="header" href="#starknet-react-react-integration">Starknet-React: React Integration</a></h1>
<p>Several tools exist in the starknet ecosystem to build the front-end for
your application. The most popular ones are:</p>
<ul>
<li>
<p><a href="https://github.com/apibara/starknet-react">starknet-react</a>
(<a href="https://apibara.github.io/starknet-react">documentation</a>):
Collection of React hooks for Starknet. It is inspired by
<a href="https://github.com/tmm/wagmi">wagmi</a>, powered by
<a href="https://github.com/0xs34n/starknet.js">starknet.js</a>.</p>
</li>
<li>
<p><a href="https://github.com/0xs34n/starknet.js">starknet.js</a>: A JavaScript
library for interacting with Starknet contracts. It would be the
equivalent of <a href="https://web3js.org/">web3.js</a> for Ethereum.</p>
</li>
</ul>
<p>For Vue developers, vue-stark-boil, created by the team at <a href="https://github.com/dontpanicdao">Don’t Panic
DAO</a>, is a great option. For a deeper
understanding of Vue, visit their <a href="https://vuejs.org/">website</a>. The
vue-stark-boil boilerplate enables various functionalities, such as
connecting to a wallet, listening for account changes, and calling a
contract.</p>
<p>Authored by the <a href="https://github.com/apibara/">Apibara</a> team, <a href="https://github.com/apibara/starknet-react/">Starknet
React</a> is an open-source
collection of React providers and hooks meticulously designed for
Starknet.</p>
<p>To immerse in the real-world application of Starknet React, we recommend
exploring the comprehensive example dApp project at
<a href="https://github.com/finiam/starknet-demo-dapp/">starknet-demo-dapp</a>.</p>
<h2 id="integrating-starknet-react"><a class="header" href="#integrating-starknet-react">Integrating Starknet React</a></h2>
<p>Embarking on your Starknet React journey necessitates the incorporation
of vital dependencies. Let’s start by adding them to your project.</p>
<pre><code>yarn add @starknet-react/core starknet get-starknet
</code></pre>
<p><a href="https://www.starknetjs.com/">Starknet.js</a> is an essential SDK
facilitating interactions with Starknet. In contrast,
<a href="https://github.com/starknet-io/get-starknet/">get-starknet</a> is a
package adept at managing wallet connections.</p>
<p>Proceed by swaddling your app within the <code>StarknetConfig</code> component.
This enveloping action offers a degree of configuration, while
simultaneously providing a React Context for the application beneath to
utilize shared data and hooks. The <code>StarknetConfig</code> component accepts a
connectors prop, allowing the definition of wallet connection options
available to the user.</p>
<pre><code>const connectors = [
  new InjectedConnector({ options: { id: &quot;braavos&quot; } }),
  new InjectedConnector({ options: { id: &quot;argentX&quot; } }),
];

return (
    &lt;StarknetConfig
      connectors={connectors}
      autoConnect
    &gt;
      &lt;App /&gt;
    &lt;/StarknetConfig&gt;
)
</code></pre>
<h2 id="establishing-connection-and-managing-account"><a class="header" href="#establishing-connection-and-managing-account">Establishing Connection and Managing Account</a></h2>
<p>Once the connectors are defined in the config, the stage is set to use a
hook to access these connectors, enabling users to connect their
wallets:</p>
<pre><code>export default function Connect() {
  const { connect, connectors, disconnect } = useConnectors();

  return (
    &lt;div&gt;
      {connectors.map((connector) =&gt; (
        &lt;button
          key={connector.id}
          onClick={() =&gt; connect(connector)}
          disabled={!connector.available()}
        &gt;
          Connect with {connector.id}
        &lt;/button&gt;
      ))}
    &lt;/div&gt;
  );
}
</code></pre>
<p>Observe the <code>disconnect</code> function that terminates the connection when
invoked. Post connection, access to the connected account is provided
through the <code>useAccount</code> hook, offering insight into the current state
of connection:</p>
<pre><code>const { address, isConnected, isReconnecting, account } = useAccount();

return (
    &lt;div&gt;
      {isConnected ? (
          &lt;p&gt;Hello, {address}&lt;/p&gt;
      ) : (
        &lt;Connect /&gt;
      )}
    &lt;/div&gt;
);
</code></pre>
<p>The state values, such as <code>isConnected</code> and <code>isReconnecting</code>, receive
automatic updates, simplifying UI conditional updates. This convenient
pattern shines when dealing with asynchronous processes, as it
eliminates the need to manually manage the state within your components.</p>
<p>Having established a connection, signing messages becomes a breeze using
the account value returned from the <code>useAccount</code> hook. For a more
streamlined experience, the <code>useSignTypedData</code> hook is at your disposal.</p>
<pre><code>const { data, signTypedData } = useSignTypedData(typedMessage)

return (
  &lt;&gt;
    &lt;p&gt;
      &lt;button onClick={signTypedData}&gt;Sign&lt;/button&gt;
    &lt;/p&gt;
    {data &amp;&amp; &lt;p&gt;Signed: {JSON.stringify(data)}&lt;/p&gt;}
  &lt;/&gt;
)
</code></pre>
<p>Starknet React supports signing an array of <code>BigNumberish</code> values or an
object. While signing an object, it is crucial to ensure that the data
conforms to the EIP712 type. For a more comprehensive guide on signing,
refer to the Starknet.js documentation:
<a href="https://www.starknetjs.com/docs/guides/signature/">here</a>.</p>
<h2 id="displaying-starkname"><a class="header" href="#displaying-starkname">Displaying StarkName</a></h2>
<p>After an account has been connected, the <code>useStarkName</code> hook can be used
to retrieve the StarkName of this connected account. Related to
<a href="https://www.starknet.id/">Starknet.id</a> it permits to display the user
address in a more user friendly way.</p>
<pre><code>const { data, isError, isLoading, status } = useStarkName({ address });
// You can track the status of the request with the status variable ('idle' | 'error' | 'loading' | 'success')

if (isLoading) return &lt;p&gt;Loading...&lt;/p&gt;
return &lt;p&gt;Account: {isError ? address : data}&lt;/p&gt;
</code></pre>
<p>You also have additional information you can get from this hook →
<strong>error</strong>, <strong>isIdle</strong>, <strong>isFetching</strong>, <strong>isSuccess</strong>, <strong>isFetched</strong>,
<strong>isFetchedAfterMount</strong>, <strong>isRefetching</strong>, <strong>refetch</strong> which can give
you more precise information on what is happening.</p>
<h2 id="fetching-address-from-starkname"><a class="header" href="#fetching-address-from-starkname">Fetching address from StarkName</a></h2>
<p>You could also want to retrieve an address corresponding to a StarkName.
For this purpose, you can use the <code>useAddressFromStarkName</code> hook.</p>
<pre><code>const { data, isLoading, isError } = useAddressFromStarkName({ name: 'vitalik.stark' })

if (isLoading) return &lt;p&gt;Loading...&lt;/p&gt;
if (isError) return &lt;p&gt;Something went wrong&lt;/p&gt;
return &lt;p&gt;Address: {data}&lt;/p&gt;
</code></pre>
<p>If the provided name does not have an associated address, it will return
<strong>&quot;0x0&quot;</strong></p>
<h2 id="navigating-the-network"><a class="header" href="#navigating-the-network">Navigating the Network</a></h2>
<p>In addition to wallet and account management, Starknet React equips
developers with hooks for network interactions. For instance, useBlock
enables the retrieval of the latest block:</p>
<pre><code>const { data, isError, isFetching } = useBlock({
    refetchInterval: 10_000,
    blockIdentifier: &quot;latest&quot;,
});

if (isError) {
  return (
    &lt;p&gt;Something went wrong&lt;/p&gt;
  )
}

return (
    &lt;p&gt;Current block: {isFetching ? &quot;Loading...&quot; : data?.block_number}&lt;p&gt;
)
</code></pre>
<p>In the aforementioned code, refetchInterval controls the frequency of
data refetching. Behind the scenes, Starknet React harnesses
<a href="https://github.com/TanStack/query/">react-query</a> for managing state and
queries. In addition to useBlock, Starknet React offers other hooks like
useContractRead and useWaitForTransaction, which can be configured to
update at regular intervals.</p>
<p>The useStarknet hook provides direct access to the ProviderInterface:</p>
<pre><code>const { library } = useStarknet();

// library.getClassByHash(...)
// library.getTransaction(...)
</code></pre>
<h2 id="tracking-wallet-changes"><a class="header" href="#tracking-wallet-changes">Tracking Wallet changes</a></h2>
<p>To improve your dApp User Experience, you can track the user wallet
changes, especially when the user changes the wallet account (or
connects/disconnects). But also when the user changes the network. You
could want to reload correct balances when the user changes the account,
or to reset the state of your dApp when the user changes the network. To
do so, you can use a previous hook we already looked at: <code>useAccount</code>
and a new one <code>useNetwork</code>.</p>
<p>The <code>useNetwork</code> hook can provide you with the network chain currently
in use.</p>
<pre><code>const { chain: {id, name} } = useNetwork();

return (
    &lt;&gt;
        &lt;p&gt;Connected chain: {name}&lt;/p&gt;
        &lt;p&gt;Connected chain id: {id}&lt;/p&gt;
    &lt;/&gt;
)
</code></pre>
<p>You also have additional information you can get from this hook →
<strong>blockExplorer</strong>, <strong>testnet</strong> which can give you more precise
information about the current network being used.</p>
<p>After knowing this you have all you need to track user interaction on
the using account and network. You can use the <code>useEffect</code> hook to do
some work on changes.</p>
<pre><code>const { chain } = useNetwork();
const { address } = useAccount();

useEffect(() =&gt; {
    if(address) {
        // Do some work when the user changes the account on the wallet
        // Like reloading the balances
    }else{
        // Do some work when the user disconnects the wallet
        // Like reseting the state of your dApp
    }
}, [address]);

useEffect(() =&gt; {
    // Do some work when the user changes the network on the wallet
    // Like reseting the state of your dApp
}, [chain]);
</code></pre>
<h2 id="contract-interactions"><a class="header" href="#contract-interactions">Contract Interactions</a></h2>
<h3 id="read-functions"><a class="header" href="#read-functions">Read Functions</a></h3>
<p>Starknet React presents useContractRead, a specialized hook for invoking
read functions on contracts, akin to wagmi. This hook functions
independently of the user’s connection status, as read operations do not
necessitate a signer.</p>
<pre><code>const { data: balance, isLoading, isError, isSuccess } = useContractRead({
    abi: abi_erc20,
    address: CONTRACT_ADDRESS,
    functionName: &quot;allowance&quot;,
    args: [owner, spender],
    // watch: true &lt;- refresh at every block
});
</code></pre>
<p>For ERC20 operations, Starknet React offers a convenient useBalance
hook. This hook exempts you from passing an ABI and returns a suitably
formatted balance value.</p>
<pre><code>  const { data, isLoading } = useBalance({
    address,
    token: CONTRACT_ADDRESS, // &lt;- defaults to the ETH token
    // watch: true &lt;- refresh at every block
  });

  return (
    &lt;p&gt;Balance: {data?.formatted} {data?.symbol}&lt;/p&gt;
  )
</code></pre>
<h3 id="write-functions"><a class="header" href="#write-functions">Write Functions</a></h3>
<p>The useContractWrite hook, designed for write operations, deviates
slightly from wagmi. The unique architecture of Starknet facilitates
multicall transactions natively at the account level. This feature
enhances the user experience when executing multiple transactions,
eliminating the need to approve each transaction individually. Starknet
React capitalizes on this functionality through the useContractWrite
hook. Below is a demonstration of its usage:</p>
<pre><code>const calls = useMemo(() =&gt; {
    // compile the calldata to send
    const calldata = stark.compileCalldata({
      argName: argValue,
    });

    // return a single object for single transaction,
    // or an array of objects for multicall**
    return {
      contractAddress: CONTRACT_ADDRESS,
      entrypoint: functionName,
      calldata,
    };
}, [argValue]);


// Returns a function to trigger the transaction
// and state of tx after being sent
const { write, isLoading, data } = useContractWrite({
    calls,
});

function execute() {
  // trigger the transaction
  write();
}

return (
  &lt;button type=&quot;button&quot; onClick={execute}&gt;
    Make a transaction
  &lt;/button&gt;
)
</code></pre>
<p>The code snippet begins by compiling the calldata using the
compileCalldata utility provided by Starknet.js. This calldata, along
with the contract address and entry point, are passed to the
useContractWrite hook. The hook returns a write function that is
subsequently used to execute the transaction. The hook also provides the
transaction’s hash and state.</p>
<h3 id="a-single-contract-instance"><a class="header" href="#a-single-contract-instance">A Single Contract Instance</a></h3>
<p>In certain use cases, working with a single contract instance may be
preferable to specifying the contract address and ABI in each hook.
Starknet React accommodates this requirement with the useContract hook:</p>
<pre><code>const { contract } = useContract({
    address: CONTRACT_ADDRESS,
    abi: abi_erc20,
});

// Call functions directly on contract
// contract.transfer(...);
// contract.balanceOf(...);
</code></pre>
<h2 id="tracking-transactions"><a class="header" href="#tracking-transactions">Tracking Transactions</a></h2>
<p>The useTransaction hook allows for the tracking of transaction states
given a transaction hash. This hook maintains a cache of all
transactions, thereby minimizing redundant network requests.</p>
<pre><code>const { data, isLoading, error } = useTransaction({ hash: txHash });

return (
  &lt;pre&gt;
    {JSON.stringify(data?.calldata)}
  &lt;/pre&gt;
)
</code></pre>
<p>The full array of available hooks can be discovered in the Starknet
React documentation, accessible here:
<a href="https://apibara.github.io/starknet-react/">https://apibara.github.io/starknet-react/</a>.</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>The Starknet React library offers a comprehensive suite of React hooks
and providers, purpose-built for Starknet and the Starknet.js SDK. By
taking advantage of these well-crafted tools, developers can build
robust decentralized applications that harness the power of the Starknet
network.</p>
<p>Through the diligent work of dedicated developers and contributors,
Starknet React continues to evolve. New features and optimizations are
regularly added, fostering a dynamic and growing ecosystem of
decentralized applications.</p>
<p>It’s a fascinating journey, filled with innovative technology, endless
opportunities, and a growing community of passionate individuals. As a
developer, you’re not only building applications, but contributing to
the advancement of a global, decentralized network.</p>
<p>Have questions or need help? The Starknet community is always ready to
assist. Join the <a href="https://discord.gg/starknet">Starknet Discord</a> or
explore the <a href="https://github.com/starknet-edu/starknetbook">StarknetBook’s GitHub
repository</a> for resources
and support.</p>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li>
<p><a href="https://starknet.js.org">Starknet.js</a></p>
</li>
<li>
<p><a href="https://www.apibara.com/starknet-react-docs">Starknet React Docs</a></p>
</li>
<li>
<p><a href="https://github.com/ethereumbook/ethereumbook">Mastering Ethereum</a></p>
</li>
<li>
<p><a href="https://github.com/bitcoinbook/bitcoinbook">Mastering Bitcoin</a></p>
</li>
</ul>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-py-python-sdk-"><a class="header" href="#starknet-py-python-sdk-">Starknet-py: Python SDK 🚧</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet-rs-rust-sdk-"><a class="header" href="#starknet-rs-rust-sdk-">Starknet-rs: Rust SDK 🚧</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foundry-cast-interacting-with-starknet-"><a class="header" href="#foundry-cast-interacting-with-starknet-">Foundry Cast: Interacting with Starknet 🚧</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foundry-forge-testing-"><a class="header" href="#foundry-forge-testing-">Foundry Forge: Testing 🚧</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>This is an introduction to Starknet’s Layer 2 architecture, designed for
both beginners and experienced users. It focuses on the key components:
Sequencers, Provers, and nodes.</p>
<p>Starknet is a coordinated system, with each component—Sequencers,
Provers, and nodes—playing a specific yet interconnected role. Although
Starknet hasn’t fully decentralized yet, it’s actively moving toward
that goal. This understanding of the roles and interactions within the
system will help you better grasp the intricacies of the Starknet
ecosystem.</p>
<h2 id="high-level-overview"><a class="header" href="#high-level-overview">High-Level Overview</a></h2>
<p>Starknet’s operation begins when a transaction is received by a gateway,
which serves as the Mempool. This stage could also be managed by the
Sequencer. The transaction is initially marked as &quot;RECEIVED.&quot; The
Sequencer then incorporates the transaction into the network state and
tags it as &quot;ACCEPTED_ON_L2.&quot; The final step involves the Prover, which
executes the operating system on the new block, calculates its proof,
and submits it to the Layer 1 (L1) for verification.</p>
<img alt="Starknet Architecture" src="img/ch03-architecture.png" class="center" style="width: 50%;" />
<p><span class="caption">Starknet architecture</span></p>
<p>In essence, Starknet’s architecture involves multiple components:</p>
<ul>
<li>
<p>The Sequencer is responsible for receiving transactions, ordering
them, and producing blocks. It operates similarly to validators in
Ethereum or Bitcoin.</p>
</li>
<li>
<p>The Prover is tasked with generating proofs for the created blocks
and transactions. It uses Cairo’s Virtual Machine to run provable
programs, thereby creating execution traces necessary for generating
STARK proofs.</p>
</li>
<li>
<p>Layer 1 (L1), in this case Ethereum, hosts a smart contract capable
of verifying these STARK proofs. If the proofs are valid, Starknet’s
state root on L1 is updated.</p>
</li>
</ul>
<p>Starknet’s state is a comprehensive snapshot maintained through Merkle
trees, much like in Ethereum. This establishes the architecture of the
validity roll-up and the roles of each component.</p>
<p>For a more in-depth look at each component, read on.</p>
<p>After exploring the introductory overview of the different components,
delve deeper into their specific roles by referring to their dedicated
subchapters in this Chapter.</p>
<h2 id="sequencers"><a class="header" href="#sequencers">Sequencers</a></h2>
<p>Sequencers are the backbone of the Starknet network, akin to Ethereum’s
validators. They usher transactions into the system.</p>
<p>Validity rollups excel at offloading some network chores, like bundling
and processing transactions, to specialized players. This setup is
somewhat like how Ethereum and Bitcoin delegate security to miners.
Sequencing, like mining, demands hefty resources.</p>
<p>For networks like Starknet and other platforms utilizing Validity
rollups, a similar parallel is drawn. These networks outsource
transaction processing to specialized entities and then verify their
work. These specialized entities in the context of Validity rollups are
known as &quot;Sequencers.&quot;</p>
<p>Instead of providing security, as miners do, Sequencers provide
transaction capacity. They order (sequence) multiple transactions into a
single batch, executes them, and produce a block that will later be
proved by the Prover and submmited to the Layer 1 network as a single,
compact proof, known as a &quot;rollup.&quot; In other words, just as validators
in Ethereum and miners in Bitcoin are specialized actors securing the
network, Sequencers in Validity rollup-based networks are specialized
actors that provide transaction capacity.</p>
<p>This mechanism allows Validity (or ZK) rollups to handle a higher volume
of transactions while maintaining the security of the underlying
Ethereum network. It enhances scalability without compromising on
security.</p>
<p>Sequencers follow a systematic method for transaction processing:</p>
<ol>
<li>
<p>Sequencing: They collect transactions from users and order
(sequence) them.</p>
</li>
<li>
<p>Executing: Sequencers then process these transactions.</p>
</li>
<li>
<p>Batching: Transactions are grouped together in batches or blocks for
efficiency.</p>
</li>
<li>
<p>Block Production: Sequencers produce blocks that contain batches of
processed transactions.</p>
</li>
</ol>
<p>Sequencers must be reliable and highly available, as their role is
critical to the network’s smooth functioning. They need powerful and
well-connected machines to perform their role effectively, as they must
process transactions rapidly and continuously.</p>
<p>The current roadmap for Starknet includes decentralizing the Sequencer
role. This shift towards decentralization will allow more participants
to become Sequencers, contributing to the robustness of the network.</p>
<p>For more details in the Sequencer role, refer to the dedicated
subchapter in this Chapter.</p>
<h2 id="provers"><a class="header" href="#provers">Provers</a></h2>
<p>Provers serve as the second line of verification in the Starknet
network. Their main task is to validate the work of the Sequencers (when
they receive the block produced by the Sequencer) and to generate proofs
that these processes were correctly performed.</p>
<p>The duties of a Prover include:</p>
<ol>
<li>
<p>Receiving Blocks: Provers obtain blocks of processed transactions
from Sequencers.</p>
</li>
<li>
<p>Processing: Provers process these blocks a second time, ensuring
that all transactions within the block have been correctly handled.</p>
</li>
<li>
<p>Proof Generation: After processing, Provers generate a proof of
correct transaction processing.</p>
</li>
<li>
<p>Sending Proof to Ethereum: Finally, the proof is sent to the
Ethereum network for validation. If the proof is correct, the
Ethereum network accepts the block of transactions.</p>
</li>
</ol>
<p>Provers need even more computational power than Sequencers because they
have to calculate and generate proofs, a process that is computationally
heavy. However, the work of Provers can be split into multiple parts,
allowing for parallelism and efficient proof generation. The proof
generation process is asynchronous, meaning it doesn’t have to occur
immediately or in real-time. This flexibility allows for the workload to
be distributed among multiple Provers. Each Prover can work on a
different block, allowing for parallelism and efficient proof
generation.</p>
<p>The design of Starknet relies on these two types of actors — Sequencers
and Provers — working in tandem to ensure efficient processing and
secure verification of transactions.</p>
<p>For more details in the Prover role, refer to the dedicated subchapter
in this Chapter.</p>
<h2 id="optimizing-sequencers-and-provers-debunking-common-misconceptions"><a class="header" href="#optimizing-sequencers-and-provers-debunking-common-misconceptions">Optimizing Sequencers and Provers: Debunking Common Misconceptions</a></h2>
<p>The relationship between Sequencers and Provers in blockchain technology
often sparks debate. A common misunderstanding suggests that either the
Prover or the Sequencer is the main bottleneck. To set the record
straight, let’s discuss the optimization of both components.</p>
<p>Starknet, utilizing the Cairo programming language, currently supports
only sequential transactions. Plans are in place to introduce parallel
transactions in the future. However, as of now, the Sequencer operates
one transaction at a time, making it the bottleneck in the system.</p>
<p>In contrast, Provers operate asynchronously and can execute multiple
tasks in parallel. The use of proof recursion allows for task
distribution across multiple machines, making scalability less of an
issue for Provers.</p>
<p>Given the asynchronous and scalable nature of Provers, focus in Starknet
has shifted to enhancing the Sequencer’s efficiency. This explains why
current development efforts are primarily aimed at the sequencing side
of the equation.</p>
<h2 id="nodes"><a class="header" href="#nodes">Nodes</a></h2>
<p>When it comes to defining what nodes do in Bitcoin or Ethereum, people
often misinterpret their role as keeping track of every transaction
within the network. This, however, is not entirely accurate.</p>
<p>Nodes serve as auditors of the network, maintaining the state of the
network, such as how much Bitcoin each participant owns or the current
state of a specific smart contract. They accomplish this by processing
transactions and preserving a record of all transactions, but that’s a
means to an end, not the end itself.</p>
<p>In Validity rollups and specifically within Starknet, this concept is
somewhat reversed. Nodes don’t necessarily have to process transactions
to get the state. In contrast to Ethereum or Bitcoin, Starknet nodes
aren’t required to process all transactions to maintain the state of the
network.</p>
<p>There are two main ways to access network state data: via an API gateway
or using the RPC protocol to communicate with a node. Operating your own
node is typically faster than using a shared architecture, like the
gateway. Over time, Starknet plans to deprecate APIs and replace them
with a JSON RPC standard, making it even more beneficial to operate your
own node.</p>
<p>It’s worth noting that encouraging more people to run nodes increases
the resilience of the network and prevents server flooding, which has
been an issue in networks in other L2s.</p>
<p>Currently, there are primarily three methods for a node to keep track of
the network’s state and we can have nodes implement any of these
methods:</p>
<ol>
<li>
<p><strong>Replaying Old Transactions</strong>: Like Ethereum or Bitcoin, a node can
take all the transactions and re-execute them. Although this
approach is accurate, it isn’t scalable unless you have a powerful
machine that’s capable of handling the load. If you can replay all
transactions, you can become a Sequencer.</p>
</li>
<li>
<p><strong>Relying on L2 Consensus</strong>: Nodes can trust the Sequencer(s) to
execute the network correctly. When the Sequencer updates the state
and adds a new block, nodes accept the update as accurate.</p>
</li>
<li>
<p><strong>Checking Proof Validation on L1</strong>: Nodes can monitor the state of
the network by observing L1 and ensuring that every time a proof is
sent, they receive the updated state. This way, they don’t have to
trust anyone and only need to keep track of the latest valid
transaction for Starknet.</p>
</li>
</ol>
<p>Each type of node setup comes with its own set of hardware requirements
and trust assumptions.</p>
<h3 id="nodes-that-replay-transactions"><a class="header" href="#nodes-that-replay-transactions">Nodes That Replay Transactions</a></h3>
<p>Nodes that replay transactions require powerful machines to track and
execute all transactions. These nodes don’t have trust assumptions; they
rely solely on the transactions they execute, guaranteeing that the
state at any given point is valid.</p>
<h3 id="nodes-that-rely-on-l2-consensus"><a class="header" href="#nodes-that-rely-on-l2-consensus">Nodes That Rely on L2 Consensus</a></h3>
<p>Nodes relying on L2 consensus require less computational power. They
need sufficient storage to keep the state but don’t need to process a
lot of transactions. The trade-off here is a trust assumption.
Currently, Starknet revolves around one Sequencer, so these nodes are
trusting Starkware not to disrupt the network. However, once a consensus
mechanism and leader election amongst Sequencers are in place, these
nodes will only need to trust that a Sequencer who staked their stake to
produce a block is not willing to lose it.</p>
<h3 id="nodes-that-check-proof-validation-on-l1"><a class="header" href="#nodes-that-check-proof-validation-on-l1">Nodes That Check Proof Validation on L1</a></h3>
<p>Nodes that only update their state based on proof validation on L1
require the least hardware. They have the same requirements as an
Ethereum node, and once Ethereum light nodes become a reality,
maintaining such a node could be as simple as using a smartphone. The
only trade-off is latency. Proofs are not sent to Ethereum every block
but intermittently, resulting in delayed state updates. Plans are in
place to produce proofs more frequently, even if they are not sent to
Ethereum immediately, allowing these nodes to reduce their latency.
However, this development is still a way off in the Starknet roadmap.</p>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>Through this chapter, we delve into Starknet’s structure, uncovering the
importance of Sequencers, Provers, and nodes. Each plays a unique role,
but together, they create a highly scalable, efficient, and secure
network that marks a significant step forward in Layer 2 solutions. As
Starknet evolves towards decentralization, understanding these roles
will provide valuable insight into the inner workings of this network.</p>
<p>As we venture further into the Starknet universe, our next stop will be
an exploration of the transaction lifecycle before we dive into the
heart of coding with Cairo.</p>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transactions"><a class="header" href="#transactions">Transactions</a></h1>
<p>A transaction's journey in Starknet, from its inception to finality, comprises a series of carefully orchestrated steps. Each stage plays a crucial role in ensuring data is accurately transmitted, processed, and stored within the network. In this chapter, we explore the lifecycle of a Starknet transaction.</p>
<h2 id="preparing-the-groundwork-transaction-creation"><a class="header" href="#preparing-the-groundwork-transaction-creation">Preparing the Groundwork: Transaction Creation</a></h2>
<p>Every transaction's journey commences with its preparation. The sender queries the nonce of their account, serving as a unique identifier for each transaction, signs the transaction, and dispatches it to their Node. It's critical to understand the sender must be online during this process to access real-time data.</p>
<pre><code>Preparing Transactions

1. Query the nonce of your account
2. Sign your transaction
3. Send your transaction to your Node
</code></pre>
<p>The Node, analogous to a post office, receives the transaction and broadcasts it on the Starknet network, primarily to the Sequencer. As the network evolves, the transaction will be broadcasted to multiple Sequencers.</p>
<p>It is worth mentioning that before broadcasting the transaction to the Sequencer, the gateways perform some validations, such as checking that the max fee exceeds a minimum fee and the account's balance is greater than the max fee. The transaction will be saved in the storage if the validation function passes.</p>
<h2 id="reception-and-processing-the-sequencers-role"><a class="header" href="#reception-and-processing-the-sequencers-role">Reception and Processing: The Sequencer's Role</a></h2>
<p>On receiving the transaction, the Sequencer acknowledges its receipt but hasn't processed it yet—similar to Ethereum's mempool state. </p>
<pre><code>Sequencer's Process

Receive the transaction
Validate the transaction
Execute the transaction
Update the state
</code></pre>
<p>It's crucial to remember the sequentiality of transaction processing in Starknet: the nonce won't update until the Sequencer processes your transaction. This aspect could become a hurdle when building backend applications, as sending multiple transactions consecutively may result in confusion or errors.</p>
<h2 id="acceptance-on-layer-2-l2"><a class="header" href="#acceptance-on-layer-2-l2">Acceptance on Layer-2 (L2)</a></h2>
<p>When the Sequencer validates and executes a transaction, it immediately updates the state without waiting for the block emission. The transaction status changes from 'received' to 'accepted on L2' at this stage.</p>
<p>Following the state update, the transaction is included in a block. However, the block isn't emitted immediately. The Sequencer decides the opportune moment to emit the block, either when there are enough transactions to form a block or after a certain time has passed. When the block is emitted, the block becomes available for other Nodes to query.</p>
<pre><code>Transaction Status Transition

1. Received -&gt; Accepted on L2
</code></pre>
<p>If a transaction fails during execution, it will be included in the block with the status 'reverted'.</p>
<p>It's essential to remember that at this stage, no proof has been generated, and the transaction relies on L2 consensus for security against censorship. There remains a slim possibility of transaction reversal if all Sequencers collude. Therefore, these stages should be seen as different layers of transaction finality.</p>
<h2 id="acceptance-on-layer-1-l1"><a class="header" href="#acceptance-on-layer-1-l1">Acceptance on Layer-1 (L1)</a></h2>
<p>The final step in the transaction's lifecycle is its acceptance on Layer-1 (L1). A Prover receives the block containing the transaction, re-executes the block, generates a proof, and sends it to Ethereum. Specifically, the proof is sent to a smart contract on Ethereum called the Verifier smart contract, which checks the proof's validity. If valid, the transaction's status changes to 'accepted on L1', signifying the transaction's security by Ethereum consensus.</p>
<pre><code>Transaction Status Transition

1. Accepted on L2 -&gt; Accepted on L1
</code></pre>
<h2 id="optional-transaction-finality-in-starknet"><a class="header" href="#optional-transaction-finality-in-starknet">[Optional] Transaction Finality in Starknet</a></h2>
<p>Transaction finality refers to the point at which a transaction is considered irreversible and is no longer susceptible to being reversed or undone. It's the assurance that once a transaction is committed, it can't be altered or rolled back, hence securing the integrity of the transaction and the system as a whole.</p>
<p>Let's dive into the transaction finality in both Starknet and Ethereum, and how they compare.</p>
<h3 id="ethereum-transaction-finality"><a class="header" href="#ethereum-transaction-finality">Ethereum Transaction Finality</a></h3>
<p>Ethereum operates on a Proof of Stake (PoS) consensus mechanism. A transaction has the finality status when it is part of a block that can't change without a significant amount of ETH getting burned. The number of blocks required to ensure that a transaction won't be rolled back is called 'blocks to finality', and the time to create those blocks is called 'time to finality'.</p>
<p>It is considered to be an average of 6 blocks to reach the finality status; given that a new block is validated each 12 seconds, the average time to finality for a transaction is 75 seconds.</p>
<h3 id="starknet-transaction-finality"><a class="header" href="#starknet-transaction-finality">Starknet Transaction Finality</a></h3>
<p>Starknet, a Layer-2 (L2) solution on Ethereum, has a two-step transaction finality process. The first step is when the transaction gets accepted on Layer-2 (Starknet), and the second step is when the transaction gets accepted on Layer-1 (Ethereum).</p>
<ul>
<li>Accepted on L2: When a transaction is processed by the Sequencer and included in a block on Starknet, it reaches L2 finality. However, this finality relies on the L2 consensus and comes with a slight risk of collusion among Sequencers leading to transaction reversal.</li>
<li>Accepted on L1: The absolute finality comes when the block containing the transaction gets a proof generated, the proof is validated by the Verifier contract on Ethereum, and the state is updated on Ethereum. At this point, the transaction is as secure as the Ethereum's PoW consensus can provide, meaning it becomes computationally infeasible to alter or reverse.</li>
</ul>
<h3 id="comparison"><a class="header" href="#comparison">Comparison</a></h3>
<p>The main difference between Ethereum and Starknet's transaction finality lies in the stages of finality and their reliance on consensus mechanisms.</p>
<ul>
<li>Ethereum's transaction finality becomes increasingly unlikely to be reversed as more blocks are added.</li>
<li>Starknet's finality process is two-fold. The initial finality (L2) is quicker but relies on L2 consensus</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequencers-1"><a class="header" href="#sequencers-1">Sequencers</a></h1>
<p>Before diving in, make sure to check out the <a href="https://book.starknet.io/chapter_3/topology.html">&quot;Understanding Starknet:
Sequencers, Provers, and
Nodes&quot;</a> chapter for a
quick rundown of Starknet’s architecture.</p>
<p>Three main layers exist in blockchain: data availability, ordering, and
execution. Sequencers have evolved within this evolving modular
landscape of blockchain technology. Most L1 blockchains, like Ethereum,
handle all these tasks. Initially, blockchains served as distributed
virtual machines focused on organizing and executing transactions. Even
roll-ups running on Ethereum today often centralize sequencing
(ordering) and execution while relying on Ethereum for data
availability. This is the current state of Starknet, which uses Ethereum
for data availability and a centralized Sequencer for ordering and
execution. However, it is possible to decentralize sequencing and
execution, as Starknet is doing.</p>
<p>Each of these layers plays a crucial role in achieving consensus. First,
the data must be available. Second, it needs to be put in a specific
order. That’s the main job of a Sequencer, whether run by a single
computer or a decentralized protocol. Lastly, you execute transactions
in the order they’ve been sequenced. This final step, done by the
Sequencer too, determines the system’s current state and keeps all
connected clients on the same page.</p>
<h2 id="introduction-to-sequencers"><a class="header" href="#introduction-to-sequencers">Introduction to Sequencers</a></h2>
<p>The advent of Layer Two (L2) solutions like Roll-Ups has altered the
blockchain landscape, improving scalability and efficiency. But what
about transaction order? Is it still managed by the base layer (L1), or
is an external system involved? Enter Sequencers. They ensure
transactions are in the correct order, regardless of whether they’re
managed by L1 or another system.</p>
<p>In essence, sequencing has two core tasks: sequencing (ordering) and
executing (validation). First, it orders transactions, determining the
canonical sequence of blocks for a given chain fork. It then appends new
blocks to this sequence. Second, it executes these transactions,
updating the system’s state based on a given function.</p>
<p>To clarify, we see sequencing as the act of taking a group of unordered
transactions and producing an ordered block. Sequencers also confirm the
resulting state of the machine. However, the approach explained here
separates these tasks. While some systems handle both ordering and state
validation simultaneously, we advocate for treating them as distinct
steps.</p>
<img alt="Sequencer role in the Starknet network" src="img/ch03-sequencer.png" class="center" style="width: 50%;" />
<p><span class="caption">Sequencer role in the Starknet network</span></p>
<h2 id="sequencers-in-starknet"><a class="header" href="#sequencers-in-starknet">Sequencers in Starknet</a></h2>
<p>Let’s delve into Sequencers by focusing on
<a href="https://github.com/keep-starknet-strange/madara">Madara</a> and
<a href="https://github.com/lambdaclass/starknet_stack/tree/main/sequencer">Kraken</a>,
two high-performance Starknet Sequencers. A Sequencer must, at least, do
two things: order and execute transactions.</p>
<ul>
<li>
<p><strong>Ordering</strong>: Madara handles the sequencing process, supporting
methods from simple FCFS and PGA to complex ones like Narwhall &amp;
Bullshark. It also manages the mempool, a critical data structure
that holds unconfirmed transactions. Developers can choose the
consensus protocol through Madara’s use of Substrate, which offers
multiple built-in options.</p>
</li>
<li>
<p><strong>Execution</strong>: Madara lets you choose between two execution crates:
<a href="https://github.com/starkware-libs/blockifier/tree/main">Blockifier</a>
and
<a href="https://github.com/lambdaclass/starknet_in_rust">Starknet_in_Rust</a>.
Both use the <a href="https://github.com/lambdaclass/cairo-vm">Cairo VM</a> for
their framework.</p>
</li>
</ul>
<p>We also have the Kraken Sequencer as another option.</p>
<ul>
<li>
<p><strong>Ordering</strong>: It employs Narwhall &amp; Bullshark for mempool
management. You can choose from multiple consensus methods, like
Bullshark, Tendermint, or Hotstuff.</p>
</li>
<li>
<p><strong>Execution</strong>: Runs on Starknet_in_Rust. Execution can be deferred
to either <a href="https://github.com/lambdaclass/cairo_native">Cairo
Native</a> or <a href="https://github.com/lambdaclass/cairo-vm">Cairo
VM</a>.</p>
</li>
</ul>
<table style="width:100%;">
<colgroup>
<col style="width: 42%" />
<col style="width: 28%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Feature</th>
<th style="text-align: left;"><a
href="https://github.com/keep-starknet-strange/madara">Madara</a></th>
<th style="text-align: left;"><a
href="https://github.com/lambdaclass/starknet_stack/tree/main/sequencer">Kraken</a></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><strong>Ordering
Method</strong></p></td>
<td style="text-align: left;"><p>FCFS, PGA, Narwhall &amp;
Bullshark</p></td>
<td style="text-align: left;"><p>Narwhall &amp; Bullshark</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><strong>Mempool
Management</strong></p></td>
<td style="text-align: left;"><p>Managed by Madara</p></td>
<td style="text-align: left;"><p>Managed using Narwhall &amp;
Bullshark</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><strong>Consensus
Options</strong></p></td>
<td style="text-align: left;"><p>Developer’s choice through
Substrate</p></td>
<td style="text-align: left;"><p>Bullshark, Tendermint or
Hotstuff</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><strong>Execution
Crates</strong></p></td>
<td style="text-align: left;"><p><a
href="https://github.com/starkware-libs/blockifier/tree/main">Blockifier</a>,
Starknet_in_rust</p></td>
<td style="text-align: left;"><p>Starknet_in_rust</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><strong>Execution
Framework</strong></p></td>
<td style="text-align: left;"><p><a
href="https://github.com/lambdaclass/cairo-vm">Cairo VM</a></p></td>
<td style="text-align: left;"><p><a
href="https://github.com/lambdaclass/cairo_native">Cairo Native</a> or
<a href="https://github.com/lambdaclass/cairo-vm">Cairo VM</a></p></td>
</tr>
</tbody>
</table>
<h3 id="understanding-the-execution-layer"><a class="header" href="#understanding-the-execution-layer">Understanding the Execution Layer</a></h3>
<ul>
<li>
<p><a href="https://github.com/starkware-libs/blockifier/tree/main">Blockifier</a>,
a Rust component in Starknet Sequencers, generates state diffs and
blocks. It uses <a href="https://github.com/lambdaclass/cairo-vm">Cairo VM</a>.
Its goal is to become a full Starknet Sequencer.</p>
</li>
<li>
<p>Starknet_in_Rust is another Rust component for Starknet that also
generates state diffs and blocks. It uses <a href="https://github.com/lambdaclass/cairo-vm">Cairo
VM</a>.</p>
</li>
<li>
<p><a href="https://github.com/lambdaclass/cairo_native">Cairo Native</a> stands
out by converting Cairo’s Sierra code to MLIR. See an example
<a href="https://github.com/lambdaclass/cairo_native/blob/main/examples/erc20.rs">here</a>.</p>
</li>
</ul>
<h2 id="the-need-for-decentralized-sequencers"><a class="header" href="#the-need-for-decentralized-sequencers">The Need for Decentralized Sequencers</a></h2>
<p>For more details on the Decentralization of Starknet, refer to the
dedicated subchapter in this Chapter.</p>
<p>Proving transactions doesn’t required to be decentralized (although in
the near future Starknet will operate with decentralized provers). Once
the order is set, anyone can submit a proof; it’s either correct or not.
However, the process that determines this order should be decentralized
to maintain a blockchain’s original qualities.</p>
<p>In the context of Ethereum’s Layer 1 (L1), Sequencers can be likened to
Ethereum validators. They are responsible for creating and broadcasting
blocks. This role is divided under the concept of &quot;Proposer-Builder
Separation&quot; (PBS) (<a href="https://www.youtube.com/watch?v=6xS0xMzh9Tc">Hasu,
2023</a>). Block builders form
blocks (order the transactions), while block proposers, unaware of the
block’s content, choose the most profitable one. This separation
prevents transaction censorship at the protocol level. Currently, most
Layer 2 (L2) Sequencers, including Starknet, perform both roles, which
can create issues.</p>
<p>The drive toward centralized Sequencers mainly stems from performance
issues like high costs and poor user experience on Ethereum for both
data storage and transaction ordering. The challenge is scalability: how
to expand without sacrificing decentralization. Opting for
centralization risks turning the blockchain monopolistic, negating its
unique advantages like network-effect services without monopoly.</p>
<p>With centralization, blockchain loses its core principles: credible
neutrality and resistance to monopolization. What’s wrong with a
centralized system? It raises the risks of censorship (via transaction
reordering).</p>
<p>A centralized validity roll-up looks like this:</p>
<ul>
<li>
<p>User Interaction &amp; Selection: Users send transactions to a
centralized Sequencer, which selects and orders them.</p>
</li>
<li>
<p>Block Formation: The Sequencer packages these ordered transactions
into a block.</p>
</li>
<li>
<p>Proof &amp; Verification: The block is sent to a proving service, which
generates a proof and posts it to Layer 1 (L1) for verification.</p>
</li>
<li>
<p>Verification: Once verified on L1, the transactions are considered
finalized and integrated into the L1 blockchain.</p>
</li>
</ul>
<img alt="Centralized rollup" src="img/ch03-centralized-rollup.png" class="center" style="width: 50%;" />
<p><span class="caption">Centralized rollup</span></p>
<p>While centralized roll-ups can provide L1 security, they come with a
significant downside: the risk of censorship. Hence, the push for
decentralization in roll-ups.</p>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>This chapter has dissected the role of Sequencers in the complex
ecosystem of blockchain technology, focusing on Starknet’s current state
and future directions. Sequencers essentially serve two main functions:
ordering transactions and executing them. While these tasks may seem
straightforward, they are pivotal in achieving network consensus and
ensuring security.</p>
<p>Given the evolving modular architecture of blockchain—with distinct
layers for data availability, transaction ordering, and
execution—Sequencers provide a crucial link. Their role gains more
significance in the context of Layer 2 solutions, where achieving
scalability without sacrificing decentralization is a pressing concern.</p>
<p>In Starknet, Sequencers like Madara and Kraken demonstrate the potential
of high-performance, customizable solutions. These Sequencers allow for
a range of ordering methods and execution frameworks, proving that
there’s room for innovation even within seemingly rigid structures.</p>
<p>The discussion on &quot;Proposer-Builder Separation&quot; (PBS) highlights the
need for role specialization to maintain a system’s integrity and thwart
transaction censorship. This becomes especially crucial when we
recognize that the current model of many L2 Sequencers, Starknet
included, performs both proposing and building, potentially exposing the
network to vulnerabilities.</p>
<p>To reiterate, Sequencers aren’t just a mechanism for transaction
ordering and execution; they are a linchpin in blockchain’s
decentralized ethos. Whether centralized or decentralized, Sequencers
must strike a delicate balance between scalability, efficiency, and the
overarching principle of decentralization.</p>
<p>As blockchain technology continues to mature, it’s worth keeping an eye
on how the role of Sequencers evolves. They hold the potential to either
strengthen or weaken the unique advantages that make blockchain
technology so revolutionary.</p>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="provers-1"><a class="header" href="#provers-1">Provers</a></h1>
<p>SHARP is like public transportation for proofs on Starknet, aggregating
multiple Cairo programs to save costs and boost efficiency. It uses
recursive proofs, allowing parallelization and optimization, making it
more affordable for all users. Critical services like the gateway,
validator, and Prover work together with a stateless design for
flexibility. SHARP’s adoption by StarkEx, Starknet, and external users
(through the Cairo Playground) highlights its significance and potential
for future optimization.</p>
<p>This chapter will discuss SHARP, how it has evolved to incorporate
recursive proofs, and its role in reducing costs and improving
efficiency within the Starknet network.</p>
<h2 id="what-is-sharp"><a class="header" href="#what-is-sharp">What is SHARP?</a></h2>
<p>SHARP, which stands for &quot;Shared Prover&quot;, is a mechanism used in Starknet
that aggregates multiple Cairo programs from different users, each
containing different logic. These Cairo programs are then executed
together, generating a single proof common to all the programs. Rather
than sending the proof directly to the Solidity Verifier in Ethereum, it
is initially sent to a STARK Verifier program written in Cairo. The
STARK Verifier generates a new proof to confirm that the initial proofs
were verified, which can be sent back into SHARP and the STARK Verifier.
This recursive proof process will be discussed in more detail later in
this chapter. Ultimately, the last proof in the series is sent to the
Solidity Verifier on Ethereum. In other words, there are many proofs
generated until we reach Ethereum and the Solidity Verifier.</p>
<p>The primary benefit of SHARP system lies in its ability to decrease
costs and enhance efficiency within the Starknet network. It achieves
this by aggregating multiple Cairo jobs, which are individual sets of
computations. This aggregation allows the protocol to leverage the
exponential amortization offered by STARK proofs.</p>
<p>Exponential amortization means that as the computational load of the
proofs increases, the cost of verifying those proofs rises at a slower
logarithmic rate than the computation increase. In other words, the
computation itself grows slower than the verification cost. As a result,
the cost of each transaction within the aggregated set is significantly
reduced, making the overall process more cost-effective and accessible
for users.</p>
<p>In SHARP and Cairo context, &quot;jobs&quot; refer to the individual Cairo
programs or tasks submitted by different users. These jobs contain
specific logic or computations that must be executed on the Starknet
network.</p>
<p>Additionally, SHARP allows smaller users with limited computation to
benefit from joining other jobs and share the cost of generating the
proofs. This collaborative approach is similar to using public
transportation instead of a private car, where the cost is distributed
among all participants, making it more affordable for everyone.</p>
<h2 id="recursive-proofs-in-sharp"><a class="header" href="#recursive-proofs-in-sharp">Recursive Proofs in SHARP</a></h2>
<p>One of the most powerful features of SHARP is its use of recursive
proofs. Rather than directly sending the generated proofs to the
Solidity Verifier, they are first sent to a STARK Verifier program
written in Cairo. This Verifier, which is also a Cairo Program, receives
the proof and creates a new Cairo job that is sent to the Prover. The
Prover then generates a new proof to confirm that the initial proofs
were verified. These new proofs can be sent back into SHARP and the
STARK Verifier, restarting the process.</p>
<p>This process continues recursively, with each new proof being sent to
the Cairo Verifier until a trigger is reached. At this point, the last
proof in the series is sent to the Solidity Verifier on Ethereum. This
approach allows for greater parallelization of the computation and
reduces the time and cost associated with generating and verifying
proofs.</p>
<pre><code>     Generated Proofs
             |
             V
STARK Verifier program (in Cairo)
             |
             V
        Cairo Job
             |
             V
            Prover
             |
             V
  New Proof Generated
             |
             V
       Repeat Process
             |
             V
 Trigger Reached (last proof)
             |
             V
    Solidity Verifier
</code></pre>
<p>At first glance, recursive proofs may seem more complex and
time-consuming. However, there are several benefits to this approach:</p>
<ol>
<li>
<p><strong>Parallelization</strong>: Recursive proofs allow for work
parallelization, reducing user latency and improving SHARP
efficiency.</p>
</li>
<li>
<p><strong>Cheaper on-chain costs</strong>: Parallelization enables SHARP to create
larger proofs, which would have previously been limited by the
availability of large cloud machines (which are rare and limited).
As a result, on-chain costs are reduced.</p>
</li>
<li>
<p><strong>Lower cloud costs</strong>: Since each job is shorter, the required
memory for processing is reduced, resulting in lower cloud costs.</p>
</li>
<li>
<p><strong>Optimization</strong>: Recursive proofs enable SHARP to optimize for
various factors, including latency, on-chain costs, and time to
proof.</p>
</li>
<li>
<p><strong>Cairo support</strong>: Recursive proofs only require support in Cairo,
without the need to add support in the Solidity Verifier.</p>
</li>
</ol>
<p>Latency in Starknet encompasses the time taken for processing,
confirming, and including transactions in a block. It is affected by
factors like network congestion, transaction fees, and system
efficiency. Minimizing latency ensures faster transaction processing and
user feedback.</p>
<p>Time to proof, however, specifically pertains to the duration required
to generate and verify cryptographic proofs for transactions or
operations.</p>
<h2 id="sharp-backend-architecture-and-data-pipeline"><a class="header" href="#sharp-backend-architecture-and-data-pipeline">SHARP Backend Architecture and Data Pipeline</a></h2>
<p>SHARP back end architecture consists of several services that work
together to process Cairo jobs and generate proofs. These services
include:</p>
<ol>
<li>
<p><strong>Gateway</strong>: Cairo jobs enter SHARP through the gateway.</p>
</li>
<li>
<p><strong>Job Creator</strong>: It prevents job duplication and ensures that the
system operates consistently, regardless of multiple identical
requests.</p>
</li>
<li>
<p><strong>Validator</strong>: This is the first important step. The validator
service runs validation checks on each job, ensuring they meet the
requirements and can fit within the prover machines. Invalid jobs
are tagged as such and do not proceed to the Prover.</p>
</li>
<li>
<p><strong>Scheduler</strong>: The scheduler service creates &quot;trains&quot; that aggregate
jobs and send them to the Prover. Recursive jobs are paired and sent
to the Prover together.</p>
</li>
<li>
<p><strong>Cairo Runner</strong>: This service runs Cairo for the Prover’s needs.
The Cairo Runner service runs Cairo programs, executing the
necessary computations and generating the execution trace as an
intermediate result. The Prover then uses this execution trace.</p>
</li>
<li>
<p><strong>Prover</strong>: The Prover computes the proofs for each train (that
contains a few jobs).</p>
</li>
<li>
<p><strong>Dispatcher</strong>: The Dispatcher serves two functions in the SHARP
system.</p>
<ol>
<li>
<p>In the case of a recursive proof, the Dispatcher runs the Cairo
Verifier program on the proof it has received from the Prover,
resulting in a new Cairo job that goes back to the Validator.</p>
</li>
<li>
<p>In the case of a proof that needs to go on chain (e.g., to
Ethereum), the Dispatcher creates &quot;packages&quot; from the proof,
which can then be sent to the Blockchain Writer.</p>
</li>
</ol>
</li>
<li>
<p><strong>Blockchain Writer</strong>: Once the packages have been created by the
Dispatcher, they are sent to the Blockchain Writer. The Blockchain
Writer is responsible for sending the packages to the appropriate
blockchain (e.g., Ethereum) for verification. This is an important
step in the SHARP system, as it ensures that the proofs are properly
verified and that the transactions are securely recorded on the
blockchain.</p>
</li>
<li>
<p><strong>Catcher</strong>: The Catcher monitors blockchain (e.g., Ethereum)
transactions to ensure that they have been accepted. While the
Catcher is relevant for internal monitoring purposes, it is
important to note that if a transaction fails, the fact won’t be
registered on-chain in the fact registry. As a result, the soundness
of the system is still preserved even without the catcher.</p>
</li>
</ol>
<p>SHARP is designed to be stateless (each Cairo job is executed in its own
context and has no dependency on other jobs), allowing for greater
flexibility in processing jobs.</p>
<h2 id="current-sharp-users"><a class="header" href="#current-sharp-users">Current SHARP Users</a></h2>
<p>Currently, the primary users of SHARP include:</p>
<ul>
<li>
<p>StarkEx</p>
</li>
<li>
<p>Starknet</p>
</li>
<li>
<p>External users who use the Cairo Playground</p>
</li>
</ul>
<h2 id="challenges-and-optimization"><a class="header" href="#challenges-and-optimization">Challenges and Optimization</a></h2>
<p>Optimizing the Prover involves numerous challenges and potential
projects on which the Starkware team and the community are currently
working:</p>
<ul>
<li>
<p>Exploring more efficient hash functions: SHARP is constantly
exploring more efficient hash functions for Cairo, the Prover, and
Solidity.</p>
</li>
<li>
<p>Investigating smaller fields: Investigating smaller fields for
recursive proof steps could lead to more efficient computations.</p>
</li>
<li>
<p>Adjusting various parameters: SHARP is continually adjusting various
parameters of the STARK protocol, such as FRI parameters and block
factors.</p>
</li>
<li>
<p>Optimizing the Cairo code: SHARP is optimizing the Cairo code to
make it faster, resulting in a faster recursive prover.</p>
</li>
<li>
<p>Developing dynamic layouts: This will allow Cairo programs to scale
resources depending on their needs.</p>
</li>
<li>
<p>Improving scheduling algorithm: This is another optimization path
that can be taken. It is not within the Prover itself.</p>
</li>
</ul>
<p>In particular, dynamic layouts (you can learn more about layouts here
(TODO)) will allow Cairo programs to scale resources depending on their
needs. This can lead to more efficient computation and better
utilization of resources. Dynamic layouts allow SHARP to determine the
required resources for a specific job and adjust the layout accordingly
instead of relying on predefined layouts with fixed resources. This
approach can provide tailored solutions for each job, improving overall
efficiency.</p>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>In conclusion, SHARP is a critical component of Starknet’s architecture,
providing a more efficient and cost-effective solution for processing
Cairo programs and verifying their proofs. By leveraging the power of
STARK technology and incorporating recursive proofs, SHARP plays a vital
role in improving the overall performance and scalability of the
Starknet network. The stateless nature of SHARP and the reliance on the
cryptographic soundness of the STARK proving system make it an
innovative and valuable addition to the blockchain ecosystem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodes-1"><a class="header" href="#nodes-1">Nodes</a></h1>
<p>This chapter will guide you through setting up and running a Starknet
node, illustrating the layered tech stack concept, and explaining how to
operate these protocols locally. Starknet, as a Layer 2 Validity Rollup,
operates on top of Ethereum Layer 1, creating a protocol stack that each
addresses different functionalities, similar to the OSI model for
internet connections. This chapter is an edit of
<a href="https://medium.com/starknet-edu/the-starknet-stack-7b0d70a7e1d4">drspacemn</a>'s
blog.</p>
<p>CONTRIBUTE: This guide shows how to run a Starknet node locally with a
particular setup. You can contribute to this guide by adding more
options for hardware and software, as well as other ways to run a
Starknet nod (for example using
<a href="https://github.com/keep-starknet-strange/beerus">Beerus</a>). You can also
contribute by adding more information about the Starknet stack and the
different layers. Feel free to <a href="https://github.com/starknet-edu/starknetbook">open a
PR</a>.</p>
<h2 id="what-is-a-node-in-the-context-of-ethereum-and-blockchain"><a class="header" href="#what-is-a-node-in-the-context-of-ethereum-and-blockchain">What is a Node in the Context of Ethereum and Blockchain?</a></h2>
<p>In the context of Ethereum and blockchain, a node is an integral part of
the network that validates and relays transactions. Nodes download a
copy of the entire blockchain and are interconnected with other nodes to
maintain and update the blockchain state. There are different types of
nodes, such as full nodes, light nodes, and mining nodes, each having
different roles and responsibilities within the network.</p>
<h2 id="overview-of-starknet-technology"><a class="header" href="#overview-of-starknet-technology">Overview of Starknet Technology</a></h2>
<p>Starknet is a permissionless, zk-STARK-based Layer-2 network, aiming for
full decentralization. It enables developers to build scalable
decentralized applications (dApps) and utilizes Ethereum’s Layer 1 for
proof verification and data availability. Key aspects of Starknet
include:</p>
<ul>
<li>
<p><strong>Cairo execution environment</strong>: Cairo, the execution environment of
Starknet, facilitates writing and execution of complex smart
contracts.</p>
</li>
<li>
<p><strong>Scalability</strong>: Starknet achieves scalability through zk-STARK
proofs, minimizing the data needed to be posted on-chain.</p>
</li>
<li>
<p><strong>Node network</strong>: The Starknet network comprises nodes that
synchronize and process transactions, contributing to the network’s
overall security and decentralization.</p>
</li>
</ul>
<h2 id="starknet-stack"><a class="header" href="#starknet-stack">Starknet Stack</a></h2>
<p>The Starknet stack can be divided into various layers, similar to OSI or
TCP/IP models. The most appropriate model depends on your understanding
and requirements. A simplified version of the modular blockchain stack
might look like this:</p>
<ul>
<li>
<p>Layer 1: Data Layer</p>
</li>
<li>
<p>Layer 2: Execution Layer</p>
</li>
<li>
<p>Layer 3: Application Layer</p>
</li>
<li>
<p>Layer 4: Transport Layer</p>
</li>
</ul>
<img alt="Modular blockchain layers" src="img/ch03-modular-blockcahain-layers.png" class="center" style="width: 50%;" />
<p><span class="caption">Modular blockchain layers</span></p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>There are various hardware specifications, including packaged options,
that will enable you to run an Ethereum node from home. The goal here is
to build the most cost-efficient Starknet stack possible (<a href="https://github.com/rocket-pool/docs.rocketpool.net/blob/main/src/guides/node/local/hardware.md">see here more
options</a>).</p>
<p><strong>Minimum Requirements:</strong></p>
<ul>
<li>
<p>CPU: 2+ cores</p>
</li>
<li>
<p>RAM: 4 GB</p>
</li>
<li>
<p>Disk: 600 GB</p>
</li>
<li>
<p>Connection Speed: 8 mbps/sec</p>
</li>
</ul>
<p><strong>Recommended Specifications:</strong></p>
<ul>
<li>
<p>CPU: 4+ cores</p>
</li>
<li>
<p>RAM: 16 GB+</p>
</li>
<li>
<p>Disk 2 TB</p>
</li>
<li>
<p>Connection Speed: 25+ mbps/sec</p>
</li>
</ul>
<p><strong>You can refer to these links for the hardware:</strong></p>
<ul>
<li>
<p><a href="https://a.co/d/iAWpTzQ">CPU</a> — $193</p>
</li>
<li>
<p><a href="https://a.co/d/cTUk9Kd">Board</a> (can attempt w/ Raspberry Pi) — $110</p>
</li>
<li>
<p><a href="https://a.co/d/0US61Y5">Disk</a> — $100</p>
</li>
<li>
<p><a href="https://a.co/d/br867sk">RAM</a> — $60</p>
</li>
<li>
<p><a href="https://a.co/d/2k3Gn40">PSU</a> — $40</p>
</li>
<li>
<p><a href="https://a.co/d/apCBGwF">Case</a> — $50</p>
</li>
</ul>
<p>Total — $553</p>
<p>Recommended operating system and software: Ubuntu LTS,
<a href="https://docs.docker.com/engine/install/ubuntu">Docker</a>, and <a href="https://docs.docker.com/compose/install/linux">Docker
Compose</a>. Ensure you have
the necessary tools installed with:</p>
<pre><code>sudo apt install -y jq curl net-tools
</code></pre>
<h2 id="layer-1-data-layer"><a class="header" href="#layer-1-data-layer">Layer 1: Data Layer</a></h2>
<p>The bottom-most layer of the stack is the data layer. Here, Starknet’s
L2 leverages Ethereum’s L1 for proof verification and data availability.
Starknet utilizes Ethereum as its L1, so the first step is setting up an
Ethereum Full Node. As this is the data layer, the hardware bottleneck
is usually the disk storage. It’s crucial to have a high capacity I/O
SSD over an HDD because Ethereum Nodes require both an Execution Client
and a Consensus Client for communication.</p>
<p>Ethereum provides several options for Execution and Consensus clients.
Execution clients include Geth, Erigon, Besu (used here), Nethermind,
and Akula. Consensus clients include Prysm, Lighthouse (used here),
Lodestar, Nimbus, and Teku.</p>
<p>Your Besu/Lighthouse node will take approximately 600 GB of disk space.
Navigate to a partition on your machine with sufficient capacity and run
the following commands:</p>
<pre><code>git clone https://github.com/starknet-edu/starknet-stack.git
cd starknet-stack
docker-compose -f dc-l1.yaml up -d
</code></pre>
<p>This will begin the fairly long process of spinning up our Consensus
Client, Execution Client, and syncing them to the current state of the
Goerli Testnet. If you would like to see the logs from either process
you can run:</p>
<pre><code># tail besu logs
docker container logs -f $(docker ps | grep besu | awk '{print $1}')

# tail lighthouse logs
docker container logs -f $(docker ps | grep lighthouse | awk '{print $1}')
</code></pre>
<p>Lets make sure that everything that should be listening is listening:</p>
<pre><code># should see all ports in command output

# besu ports
sudo netstat -lpnut | grep -E '30303|8551|8545'

# lighthouse ports
sudo netstat -lpnut | grep -E '5054|9000'
</code></pre>
<p>We’ve used docker to abstract a lot of the nuance of running an Eth L1
node, but the important things to note are how the two processes EL/CL
point to each other and communicate via JSON-RPC:</p>
<pre><code>services:
  lighthouse:
      image: sigp/lighthouse:latest
      container_name: lighthouse
      volumes:
        - ./l1_consensus/data:/root/.lighthouse
        - ./secret:/root/secret
      network_mode: &quot;host&quot;
      command:
        - lighthouse
        - beacon
        - --network=goerli
        - --metrics
        - --checkpoint-sync-url=https://goerli.beaconstate.info
        - --execution-endpoint=http://127.0.0.1:8551
        - --execution-jwt=/root/secret/jwt.hex

  besu:
    image: hyperledger/besu:latest
    container_name: besu
    volumes:
      - ./l1_execution/data:/var/lib/besu
      - ./secret:/var/lib/besu/secret
    network_mode: &quot;host&quot;
    command:
      - --network=goerli
      - --rpc-http-enabled=true
      - --data-path=/var/lib/besu
      - --data-storage-format=BONSAI
      - --sync-mode=X_SNAP
      - --engine-rpc-enabled=true
      - --engine-jwt-enabled=true
      - --engine-jwt-secret=/var/lib/besu/secret/jwt.hex
</code></pre>
<p>Once this is done, your Ethereum node should be up and running, and it
will start syncing with the Ethereum network.</p>
<h2 id="layer-2-execution-layer"><a class="header" href="#layer-2-execution-layer">Layer 2: Execution Layer</a></h2>
<p>The next layer in our Starknet stack is the Execution Layer. This layer
is responsible for running the Cairo VM, which executes Starknet smart
contracts. The Cairo VM is a deterministic virtual machine that allows
developers to write complex smart contracts in the Cairo language.
Starknet uses a similar <a href="https://github.com/starkware-libs/starknet-specs">JSON-RPC
spec</a> as
<a href="https://ethereum.org/en/developers/docs/apis/json-rpc">Ethereum</a> in
order to interact with the execution layer.</p>
<p>In order to stay current with the propagation of the Starknet blockchain
we need a client similar to Besu that we are using for L1. The efforts
to provide full nodes for the Starknet ecosystem are:
<a href="https://github.com/eqlabs/pathfinder">Pathfinder</a> (used here),
<a href="https://github.com/starkware-libs/papyrus">Papyrus</a>, and
<a href="https://github.com/NethermindEth/juno">Juno</a>. However, different
implementations are still in development and not yet ready for
production.</p>
<p>Check that your L1 has completed its sync:</p>
<pre><code># check goerli etherscan to make sure you have the latest block https://goerli.etherscan.io

curl --location --request POST 'http://localhost:8545' \
--header 'Content-Type: application/json' \
--data-raw '{
    &quot;jsonrpc&quot;:&quot;2.0&quot;,
    &quot;method&quot;:&quot;eth_blockNumber&quot;,
    &quot;params&quot;:[],
    &quot;id&quot;:83
}'

# Convert the result, which is hex (remove 0x) to decimal. Example:
echo $(( 16#246918 ))
</code></pre>
<p>Start your L2 Execution Client and note that we are syncing Starknet’s
state from our LOCAL ETH L1 NODE!</p>
<p>PATHFINDER_ETHEREUM_API_URL=http://127.0.0.1:8545</p>
<pre><code># from starknet-stack project root
docker-compose -f dc-l2.yaml up -d
</code></pre>
<p>To follow the sync:</p>
<pre><code>docker container logs -f $(docker ps | grep pathfinder | awk '{print $1}')
</code></pre>
<p>Starknet <a href="https://testnet.starkscan.co">Testnet_1</a> currently comprises
800,000+ blocks so this will take some time (days) to sync fully. To
check L2 sync:</p>
<pre><code># compare `current_block_num` with `highest_block_num`

curl --location --request POST 'http://localhost:9545' \
--header 'Content-Type: application/json' \
--data-raw '{
 &quot;jsonrpc&quot;:&quot;2.0&quot;,
 &quot;method&quot;:&quot;starknet_syncing&quot;,
 &quot;params&quot;:[],
 &quot;id&quot;:1
}'
</code></pre>
<p>To check data sizes:</p>
<pre><code>sudo du -sh ./* | sort -rh
</code></pre>
<h2 id="layer-3-application-layer"><a class="header" href="#layer-3-application-layer">Layer 3: Application Layer</a></h2>
<p>We see the same need for data refinement as we did in the OSI model. On
L1 packets come over the wire in a raw stream of bytes and are then
processed and filtered by higher-level protocols. When designing a
decentralized application Bob will need to be cognizant of interactions
with his contract on chain, but doesn’t need to be aware of all the
information occurring on Starknet.</p>
<p>This is the role of an indexer. To process and filter useful information
for an application. Information that an application MUST be opinionated
about and the underlying layer MUST NOT be opinionated about.</p>
<p>Indexers provide applications flexibility as they can be written in any
programming language and have any data layout that suits the
application.</p>
<p>To start our toy
<a href="https://github.com/starknet-edu/starknet-stack/blob/main/indexer/indexer.sh">indexer</a>
run:</p>
<pre><code>./indexer/indexer.sh
</code></pre>
<p>Again notice that we don’t need to leave our local setup for these
interactions (<a href="http://localhost:9545">http://localhost:9545</a>).</p>
<h2 id="layer-4-transport-layer"><a class="header" href="#layer-4-transport-layer">Layer 4: Transport Layer</a></h2>
<p>The transport layer comes into play when the application has parsed and
indexed critical information, often leading to some state change based
on this information. This is where the application communicates the
desired state change to the Layer 2 sequencer to get that change into a
block. This is achieved using the same full-node/RPC spec
implementation, in our case, Pathfinder.</p>
<p>When working with our local Starknet stack, invoking a transaction
locally might look like this:</p>
<pre><code>curl --location --request POST 'http://localhost:9545' \
--header 'Content-Type: application/json' \
--data-raw '{
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;starknet_addInvokeTransaction&quot;,
    &quot;params&quot;: {
        &quot;invoke_transaction&quot;: {
            &quot;type&quot;: &quot;INVOKE&quot;,
            &quot;max_fee&quot;: &quot;0x4f388496839&quot;,
            &quot;version&quot;: &quot;0x0&quot;,
            &quot;signature&quot;: [
                &quot;0x7dd3a55d94a0de6f3d6c104d7e6c88ec719a82f4e2bbc12587c8c187584d3d5&quot;,
                &quot;0x71456dded17015d1234779889d78f3e7c763ddcfd2662b19e7843c7542614f8&quot;
            ],
            &quot;contract_address&quot;: &quot;0x23371b227eaecd8e8920cd429d2cd0f3fee6abaacca08d3ab82a7cdd&quot;,
            &quot;calldata&quot;: [
                &quot;0x1&quot;,
                &quot;0x677bb1cdc050e8d63855e8743ab6e09179138def390676cc03c484daf112ba1&quot;,
                &quot;0x362398bec32bc0ebb411203221a35a0301193a96f317ebe5e40be9f60d15320&quot;,
                &quot;0x0&quot;,
                &quot;0x1&quot;,
                &quot;0x1&quot;,
                &quot;0x2b&quot;,
                &quot;0x0&quot;
            ],
            &quot;entry_point_selector&quot;: &quot;0x15d40a3d6ca2ac30f4031e42be28da9b056fef9bb7357ac5e85627ee876e5ad&quot;
        }
    },
    &quot;id&quot;: 0
}'
</code></pre>
<p>However, this process involves setting up a local wallet and signing the
transaction. For simplicity, we will use a browser wallet and StarkScan.</p>
<p>Steps:</p>
<ol>
<li>
<p>Navigate to the contract on StarkScan and connect to your wallet.</p>
</li>
<li>
<p>Enter a new value and write the transaction:</p>
</li>
</ol>
<img alt="Starkscan block explorer" src="img/ch03-starkscan-block-explorer.png" class="center" style="width: 50%;" />
<p><span class="caption">Starkscan block explorer</span></p>
<p>Once the transaction is accepted on the Layer 2 execution layer, the
event data should come through our application layer indexer.</p>
<p>Example Indexer Output:</p>
<pre><code>Pulled Block #: 638703
Found transaction: 0x2053ae75adfb4a28bf3a01009f36c38396c904012c5fc38419f4a7f3b7d75a5
Events to Index:
[
  {
    &quot;from_address&quot;: &quot;0x806778f9b06746fffd6ca567e0cfea9b3515432d9ba39928201d18c8dc9fdf&quot;,
    &quot;keys&quot;: [
      &quot;0x1fee98324df9b8703ae8de6de3068b8a8dce40c18752c3b550c933d6ac06765&quot;
    ],
    &quot;data&quot;: [
      &quot;0xa&quot;
    ]
  },
  {
    &quot;from_address&quot;: &quot;0x126dd900b82c7fc95e8851f9c64d0600992e82657388a48d3c466553d4d9246&quot;,
    &quot;keys&quot;: [
      &quot;0x5ad857f66a5b55f1301ff1ed7e098ac6d4433148f0b72ebc4a2945ab85ad53&quot;
    ],
    &quot;data&quot;: [
      &quot;0x2053ae75adfb4a28bf3a01009f36c38396c904012c5fc38419f4a7f3b7d75a5&quot;,
      &quot;0x0&quot;
    ]
  },
  {
    &quot;from_address&quot;: &quot;0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7&quot;,
    &quot;keys&quot;: [
      &quot;0x99cd8bde557814842a3121e8ddfd433a539b8c9f14bf31ebf108d12e6196e9&quot;
    ],
    &quot;data&quot;: [
      &quot;0x126dd900b82c7fc95e8851f9c64d0600992e82657388a48d3c466553d4d9246&quot;,
      &quot;0x46a89ae102987331d369645031b49c27738ed096f2789c24449966da4c6de6b&quot;,
      &quot;0x17c1e31c270&quot;,
      &quot;0x0&quot;
    ]
  }
]
</code></pre>
<p>Once the transaction is accepted on Layer 1, we can query the Starknet
Core Contracts from our Layer 1 node to see the storage keys that have
been updated on our data layer!</p>
<p>You have successfully navigated through the entire Starknet stack, from
setting up your node, through executing and monitoring a transaction, to
inspecting its effects on the data layer. This journey has equipped you
with the understanding and the skills to interact with Starknet on a
deeper level.</p>
<h2 id="conclusion-understanding-the-modular-nature-of-starknet"><a class="header" href="#conclusion-understanding-the-modular-nature-of-starknet">Conclusion: Understanding the Modular Nature of Starknet</a></h2>
<p>Conceptual models, such as the ones used in this guide, are incredibly
useful in helping us understand complex systems. They can be refactored,
reformed, and nested to provide a clear and comprehensive view of how a
platform like Starknet operates. For instance, the OSI Model, a
foundational model for understanding network interactions, underpins our
modular stack.</p>
<p>A key concept to grasp is <em>Fractal Scaling.</em> This concept allows us to
extend our model to include additional layers beyond Layer 2, such as
Layer 3. In this extended model, the entire stack recurs above our
existing stack, as shown in the following diagram:</p>
<img alt="Fractal scaling in a modular blockchain environment" src="img/ch03-fractal-scaling.png" class="center" style="width: 50%;" />
<p><span class="caption">Fractal scaling in a modular blockchain environment</span></p>
<p>Just as Layer 2 compresses its transaction throughput into a proof and
state change that is written to Layer 1, we can apply the same
compression principle at Layer 3, proving and writing to Layer 2. This
not only gives us more control over the protocol rules but also allows
us to achieve higher compression ratios, enhancing the scalability of
our applications.</p>
<p>In essence, Starknet’s modular and layered design, combined with the
power of Fractal Scaling, offers a robust and scalable framework for
building decentralized applications. Understanding this structure is
fundamental to effectively leveraging Starknet’s capabilities and
contributing to its ecosystem.</p>
<p>This concludes our journey into running a Starknet node and traversing
its layered architecture. We hope that you now feel equipped to explore,
experiment with, and innovate within the Starknet ecosystem.</p>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layer-3-app-chains"><a class="header" href="#layer-3-app-chains">Layer 3 (App Chains)</a></h1>
<p>Appchains let you create a blockchain designed precisely for your
application’s needs. These specialized blockchains allow customization
in various aspects, such as hash functions and consensus algorithms.
Moreover, they inherit the security features of the Layer 1 or Layer 2
blockchains they are built upon.</p>
<p>Example:</p>
<p>Layer 3 blockchains can exist on top of Layer 2 blockchains. You can
even build additional layers (Layer 4 and so on) on top of Layer 3 for
more complex solutions. A sample layout is shown in the following
diagram.</p>
<img alt="Example of an environment with a Layers 3 and 4" src="img/ch03-layer-3-ecosystem.png" class="center" style="width: 50%;" />
<p><span class="caption">Example of an environment with a Layers 3 and 4</span></p>
<p>In this example ecosystem, Layer 3 options include:</p>
<ul>
<li>
<p>The Public Starknet (L2), which is a general-purpose blockchain for
decentralized applications.</p>
</li>
<li>
<p>A L3 Starknet optimized for cost-sensitive applications.</p>
</li>
<li>
<p>Customized L3 Starknet systems designed for enhanced performance,
using specific storage structures or data compression techniques.</p>
</li>
<li>
<p>StarkEx systems used by platforms like dYdX and Sorare, offering
proven scalability through data availability solutions like Validium
or Rollup.</p>
</li>
<li>
<p>Privacy-focused Starknet instances, which could also function as a
Layer 4, for conducting transactions without including them in
public Starknets.</p>
</li>
</ul>
<h2 id="benefits-of-layer-3"><a class="header" href="#benefits-of-layer-3">Benefits of Layer 3</a></h2>
<p>Layer 3 app chains (with
<a href="https://github.com/keep-starknet-strange/madara">Madara</a> as an apt
sequencer or other option), offer a variety of advantages due to its
modularity and flexibility. Here’s an overview of the key benefits:</p>
<ul>
<li>
<p><strong>Quick Iteration</strong>: App chains enable rapid protocol changes,
freeing you from the constraints of the public Layer 2 roadmap. For
example, you could rapidly deploy new DeFi algorithms tailored to
your user base.</p>
</li>
<li>
<p><strong>Governance Independence</strong>: You maintain complete control over
feature development and improvements, avoiding the need for
decentralized governance consensus. This enables, for example, quick
implementation of user-suggested features.</p>
</li>
<li>
<p><strong>Cost Efficiency</strong>: Layer 3 offers substantial cost reductions,
potentially up to 1 million times compared to Layer 1, making it
economically feasible to run more complex applications.</p>
</li>
<li>
<p><strong>Security</strong>: While there may be some trade-offs, such as reduced
censorship resistance, the core security mechanisms remain strong.</p>
</li>
<li>
<p><strong>Congestion Avoidance</strong>: App chains are shielded from network
congestion, providing a more stable transaction environment, crucial
for real-time applications like gaming.</p>
</li>
<li>
<p><strong>Privacy Enhancements</strong>: Layer 3 can serve as a testing ground for
privacy-centric features, which could include anonymous transactions
or encrypted messaging services.</p>
</li>
<li>
<p><strong>Innovation Platform</strong>: App chains act as experimental fields where
novel features can be developed and tested. For instance, they could
serve as a testbed for new consensus algorithms before these are
considered for Layer 2.</p>
</li>
</ul>
<p>In summary, Layer 3 provides the flexibility, cost-efficiency, and
environment conducive for innovation, without significant compromise on
security.</p>
<h2 id="madara-as-a-sequencer-for-layer-3-app-chains"><a class="header" href="#madara-as-a-sequencer-for-layer-3-app-chains">Madara as a Sequencer for Layer 3 App Chains</a></h2>
<p><a href="https://github.com/keep-starknet-strange/madara">Madara</a> is a
specialized sequencer developed to execute transactions and group them
into batches. Created by the StarkWare Exploration Team, it functions as
a starting point for building Layer 3 Starknet appchains. This expands
the possibilities for innovation within the Starknet ecosystem.</p>
<p>Madara’s flexibility allows for the creation of Layer 3 appchains
optimized for various needs, foe example:</p>
<ul>
<li>
<p>Cost-Efficiency: Create an appchain for running a decentralized
exchange (DEX) with lower fees compared to the public Starknet.</p>
</li>
<li>
<p>Performance: Build an appchain to operate a DEX with faster
transaction times.</p>
</li>
<li>
<p>Privacy: Design an appchain to facilitate anonymous transactions or
encrypted messaging services.</p>
</li>
</ul>
<p>For more information on Madara, refer to the subchapter with the same
title.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solidity-verifier-"><a class="header" href="#solidity-verifier-">Solidity Verifier 🚧</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decentralization-"><a class="header" href="#decentralization-">Decentralization 🚧</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="account-abstraction"><a class="header" href="#account-abstraction">Account Abstraction</a></h1>
<p>Account Abstraction (AA) is a paradigm shift in how accounts and
transactions are managed in blockchain networks. To break it down, AA
refers to two intertwined notions:</p>
<ol>
<li>
<p>Transaction Flexibility: This gives the power to each smart contract
to validate its transactions, rather than enforcing a
one-size-fits-all validation process. This can lead to a variety of
potential benefits such as enabling smart contracts to pay for gas
fees, allowing multiple signers for a single account, and even
introducing advanced cryptographic signatures.</p>
</li>
<li>
<p>User Experience Optimization: AA provides a more intuitive
experience for end-users. It allows developers to create a more
flexible security model, for instance, allowing different keys for
everyday use and high-value transactions. Additionally, it
eliminates, if wished, the need for seed phrases, instead opting for
easier recovery methods.</p>
</li>
</ol>
<p>At a technical level, AA replaces Externally Owned Accounts (EOA) with a
generalized concept of accounts. Under this model, accounts can be
represented by a smart contract that dictates their specific rules and
behaviors. This means the user or contract account could dictate rules
about transaction ordering, signatures, access controls, and more,
providing a high level of customization.</p>
<p>Here are two commonly cited definitions of AA:</p>
<blockquote>
<p>Definition 1: Account Abstraction (AA) is when a <strong>smart contract can
pay for its own transactions</strong> (Martin Triay, Devcon 6)[1]. In other
words, abstract contracts (or account smart contracts) can pay for
transactions. This is a departure from the traditional Externally
Owned Accounts or Smart Wallets.</p>
</blockquote>
<blockquote>
<p>Definition 2: AA is <strong>validation abstraction</strong>. Instead of relying on
a single method of transaction validation, as with Ethereum’s Layer 1,
AA enables an abstraction of the validation process. This implies the
possibility of using different types of signatures, cryptographic
primitives, execution processes, etc. (lightclient, Devcon 6)[3].</p>
</blockquote>
<p>AA is positioned as the cornerstone of the next generation blockchain
technologies, with significant improvements in scalability, user
experience, and security. It is currently being pioneered by Layer 2
solutions, including Starknet, as they aim to revolutionize the way we
approach security, user experience, and self-custody in the crypto
space.</p>
<h2 id="applications-of-account-abstraction"><a class="header" href="#applications-of-account-abstraction">Applications of Account Abstraction</a></h2>
<p>Having defined Account Abstraction, let’s delve into its practical
applications. Account Abstraction aims to improve both the accessibility
and security of self-custody. Here are a few of the key features that AA
enables:</p>
<ol>
<li>
<p><strong>Hardware Signer:</strong> With AA, you could sign transactions using a
key generated and safeguarded by your smartphone’s secure enclave.
This use of biometric identity makes the process more secure and
user-friendly (Starkware)[4], (Braavos)[7].</p>
</li>
<li>
<p><strong>Social recovery:</strong> With the integration of AA, if you lose or
compromise your key, you could securely replace it, thus eliminating
the need for seed phrases. This change not only enhances security
but also simplifies the user experience (Julien Niset, 2022)[5].</p>
</li>
<li>
<p><strong>Key rotation:</strong> If a key controlling your account is compromised,
you can easily replace it, negating the need to transfer your
assets.</p>
</li>
<li>
<p><strong>Session keys:</strong> AA can enhance the usability of web3 applications
by allowing a <em>sign in once</em> feature. This would enable websites to
execute transactions on your behalf, reducing the need for
continuous approvals.</p>
</li>
<li>
<p><strong>Custom transaction validation schemes:</strong> AA enables the use of
various signature schemes, multisignatures, and other security
rules. This flexibility allows for customizable security measures to
meet individual user’s needs (Martin Triay, Devcon 6)[1], (Julien
Niset, 2022)[5], (Motty Lavie)[7].</p>
</li>
</ol>
<p>Moreover, AA provides enhanced security in several ways:</p>
<ol>
<li>
<p><strong>Improved key management:</strong> With AA, you can associate multiple
devices with your wallet, so if one device is lost, you still have
access to your account.</p>
</li>
<li>
<p><strong>Various signature and validation schemes:</strong> AA supports additional
security measures, like two-factor authentication for large
transactions, providing a more secure environment that adapts to
individual user’s needs.</p>
</li>
<li>
<p><strong>Custom security policies:</strong> Tailor security schemes to suit
different types of users or devices and adapt good practices from
the banking and web2 sectors.</p>
</li>
</ol>
<p>AA opens up new possibilities for both developers and users in the
Ethereum ecosystem. It offers a promising pathway for a more secure,
user-friendly experience and lays the groundwork for widespread
adoption.</p>
<h2 id="ethereum-account-system"><a class="header" href="#ethereum-account-system">Ethereum Account System</a></h2>
<p>To fully understand the benefits of Account Abstraction (AA), let’s
delve into Ethereum’s current account system. The system is split into
two types of accounts:</p>
<ul>
<li>
<p><strong>Externally Owned Accounts</strong> (EOAs)</p>
</li>
<li>
<p><strong>Contract Accounts</strong> (CAs).</p>
</li>
</ul>
<p>EOAs are the accounts used by individuals, wallets, or any entity
external to the Ethereum network. These accounts are identified by their
address, which is derived from the public key of an associated
cryptographic object called a signer. This signer, or keypair, consists
of a private key and a public key.</p>
<p>The private key, also known as the secret key, is used to digitally sign
transactions or messages, establishing proof of ownership. The
corresponding public key is used to verify this signature, ensuring it
was indeed signed by the respective private key.</p>
<p>This means, in order to modify the state of an account, a transaction
must be initiated and signed by the corresponding private key of the
account’s EOA. This design choice ensures security by associating each
account with a unique cryptographic identity.</p>
<p>On the other hand, CAs are smart contracts living on the Ethereum
blockchain. Unlike EOAs, they do not have a private key. They are
triggered through transactions or messages initiated by EOAs, and their
behavior is determined by their associated code.</p>
<p>However, the current account model presents some challenges:</p>
<ol>
<li>
<p><strong>Key Management:</strong> The loss of a private key is catastrophic. Given
that the private key represents the ownership of the account, if it
is lost, all the assets within the account are lost too. Similarly,
if it gets stolen, the perpetrator gains full control over the
account and its assets.</p>
</li>
<li>
<p><strong>User Experience:</strong> Currently, the Ethereum account model lacks
user-friendly methods for key recovery or account recovery, which
can discourage non-technical users. Additionally, user interfaces,
such as crypto wallets, can be overwhelming and difficult to use,
presenting barriers for wider adoption.</p>
</li>
<li>
<p><strong>Lack of Flexibility:</strong> The traditional model doesn’t allow for
custom transaction validation schemes, limiting the possible
security and access control improvements.</p>
</li>
</ol>
<p>Account Abstraction proposes to improve upon these limitations, offering
new possibilities in terms of security, scalability, and user
experience.</p>
<h2 id="the-need-for-account-abstraction"><a class="header" href="#the-need-for-account-abstraction">The Need for Account Abstraction</a></h2>
<p>As the crypto ecosystem matures and attracts a broader user base, it
faces pivotal challenges that demand innovative solutions. Among these,
the question of Account Abstraction (AA) has taken center stage.
Ethereum, one of the leading platforms for smart contracts and
Decentralized Applications (dApps), is in a precarious position: it must
embrace Account Abstraction or risk its position in the crypto world.</p>
<p>Without AA, Ethereum’s ability to provide a seamless, empowering, and
secure experience for its users is hampered. This could lead to users
abandoning the platform for centralized exchanges and wallets, a trend
that would undermine the very ethos of decentralization that
cryptocurrency and blockchain technology espouse.</p>
<p>There are several compelling reasons why Ethereum, and the larger crypto
ecosystem, need Account Abstraction:</p>
<ul>
<li>
<p><strong>Risk of Centralization:</strong> The inefficiencies and limitations of
the current account model may push users towards centralized
exchanges and wallets. These entities defy the principles of
decentralization, presenting familiar risks such as censorship,
discrimination, and potential abuse of power. Account Abstraction,
by enabling easier and more secure account management, can help
uphold the principles of decentralization.</p>
</li>
<li>
<p><strong>Quantum Threat:</strong> Quantum computing poses a potential threat to
cryptographic systems, with its ability to break traditional
security measures. Account Abstraction can address this by enabling
the use of different signature schemes, including quantum-resistant
ones, enhancing the security of assets on the blockchain.</p>
</li>
<li>
<p><strong>Scaling Self-Custody:</strong> As the next billion users approach the
crypto ecosystem, the importance of scaling self-custody becomes
paramount. AA can improve the scalability of self-custody, which is
essential for onboarding these new users.</p>
</li>
<li>
<p><strong>User Experience:</strong> Simplifying the onboarding process and user
experience is essential for widespread adoption. The complexity
associated with current wallets and key management systems can be
daunting for newcomers. Account Abstraction promises to simplify
these aspects, paving the way for a more intuitive user experience.</p>
</li>
</ul>
<p>Starknet is currently leading the efforts to implement Account
Abstraction at the protocol level. Many consider it to be the &quot;proving
ground&quot; for the future of AA. With numerous experts from different
organizations collaborating, Starknet aims to redefine the approach to
security, user experience, and self-custody in the crypto space.</p>
<p>The stakes are high. The future of Ethereum, and by extension, the
crypto ecosystem, is deeply intertwined with the success of Account
Abstraction. If Ethereum cannot adapt, it risks losing its prominence to
other, more adaptable platforms.</p>
<h2 id="why-isnt-account-abstraction-implemented-in-ethereums-layer-1-yet"><a class="header" href="#why-isnt-account-abstraction-implemented-in-ethereums-layer-1-yet">Why Isn’t Account Abstraction Implemented in Ethereum’s Layer 1 Yet?</a></h2>
<p>Ethereum’s Layer 1 (L1) doesn’t yet support Account Abstraction (AA) at
a protocol level, not due to lack of desire or understanding of its
importance, but rather due to the complexity of its implementation.</p>
<p>The most prominent roadblock in integrating AA is the entrenched nature
of Externally Owned Accounts (EOAs) in Ethereum’s architecture. These
accounts, as fundamental elements of the Ethereum core protocol, would
need significant alteration to support AA, an undertaking that becomes
more daunting as the value secured by Ethereum continues to rise.</p>
<p>One key aspect that complicates the integration of AA into Ethereum’s L1
is the Ethereum Virtual Machine (EVM). The EVM, as the runtime
environment for smart contracts in Ethereum, has limitations that hinder
the implementation of AA. While there have been several proposals for AA
since Ethereum’s inception, they have been consistently delayed due to
other pressing updates and improvements to the Ethereum network.</p>
<p>However, the emergence of Layer 2 (L2) solutions provides a new pathway
for the implementation of AA. With their focus on scalability and
performance enhancements, these new virtual machines can better
accommodate AA. Starknet and ZKSync are examples of platforms that have
native AA inspired by EIP4337 – a proposal deemed superior by industry
experts like Argent’s Julien Niset.</p>
<p>The repeated postponements and challenges in implementing AA on
Ethereum’s L1 have led many proponents, including Niset, to shift their
focus. Instead of hoping for EOAs to be phased out and AA integrated at
Ethereum’s core, they are now advocating for the broad adoption of AA
through L2 solutions like Starknet. This strategy could bring the
benefits of AA to users sooner and help the Ethereum network remain
competitive in the rapidly evolving crypto landscape.</p>
<h2 id="conclusion-5"><a class="header" href="#conclusion-5">Conclusion</a></h2>
<p>To bring it all home, imagine the Ethereum account system as a kind of
multifunctional Swiss Army knife, currently under renovation. What we’re
doing with Account Abstraction is swapping out a few tools - while it
was once a knife and a corkscrew, we’re making it into a magnifying
glass and a set of tweezers.</p>
<p>Why the change? The original tools served us well, but they didn’t fit
every task we found ourselves up against. Some jobs required precision;
others needed a broader lens. That’s where Account Abstraction shines.
It expands Ethereum’s capabilities, adjusting and adapting to our
ever-evolving requirements.</p>
<p>Remember the complications of Ethereum’s current account system? Account
Abstraction seeks to transform those by offering more flexible,
personalized, and safer solutions. It’s like tailoring the tools of your
Swiss Army knife to your unique needs.</p>
<p>However, it’s not yet implemented into Ethereum’s Layer 1. And why? The
kitchen is bustling, and the chefs are wary of spilling the soup. The
implementation process has its challenges, it’s true. But the cook who
never dropped a pan never learned to make an omelette. That’s why
research and development continue relentlessly.</p>
<p>Through the lens of Account Abstraction, we see Ethereum’s
future—secure, accessible, flexible. It’s an exciting, transformative
prospect that’s redefining what we thought possible. And though the path
may be fraught with complexities and risks, it’s a journey well worth
taking.</p>
<p>After all, the Swiss Army knife was once just a knife. Imagine what it
could become next.</p>
<h1 id="references"><a class="header" href="#references">References:</a></h1>
<ul>
<li>
<p>[1] Martin Triay, Devcon 6:
<a href="https://www.youtube.com/watch?v=Osc_gwNW3Fw">https://www.youtube.com/watch?v=Osc_gwNW3Fw</a></p>
</li>
<li>
<p>[2] Julien Niset: <a href="https://www.youtube.com/watch?v=OwppworJGzs">https://www.youtube.com/watch?v=OwppworJGzs</a></p>
</li>
<li>
<p>[3] lightclient, Devcon 6:
<a href="https://app.devcon.org/schedule/9mvqce">https://app.devcon.org/schedule/9mvqce</a></p>
</li>
<li>
<p>[4] Starkware:
<a href="https://medium.com/@starkware/how-starknet-is-revolutionizing-crypto-signing-ba3724077a79">https://medium.com/@starkware/how-starknet-is-revolutionizing-crypto-signing-ba3724077a79</a></p>
</li>
<li>
<p>[5] Julien Niset, 2022:
<a href="https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction/">https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction/</a></p>
</li>
<li>
<p>[6] Yoav, Devcon 6: <a href="https://app.devcon.org/schedule/9mvqce">https://app.devcon.org/schedule/9mvqce</a></p>
</li>
<li>
<p>[7] Motty Lavie, 2023:
<a href="https://www.youtube.com/watch?v=FrxAdJYhSY8">https://www.youtube.com/watch?v=FrxAdJYhSY8</a></p>
</li>
</ul>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="account-contracts"><a class="header" href="#account-contracts">Account Contracts</a></h1>
<p>Now that we know better the concept of AA, let’s actually code it in
Starknet.</p>
<h2 id="account-contract-interface"><a class="header" href="#account-contract-interface">Account Contract Interface</a></h2>
<p>Account contracts, while essentially being smart contracts,
differentiate themselves through unique methods. A smart contract gains
the status of an account contract when it implements the interface as
described by SNIP-6 (<a href="https://github.com/ericnordelo/SNIPs/blob/feat/standard-account/SNIPS/snip-6.md">StarkNet IMprovement Proposa-6: Standar Account
Interface</a>).
This standard borrows from SRC-6 and SRC-5, which are akin to Ethereum’s
ERCs, setting application-level conventions and contract standards.</p>
<p>To initiate, let’s formulate the <code>ISRC6</code> (SNIP-6: Standard Account
Interface) trait, which outlines the requisite functions for an account
contract:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    trait ISRC6 {
        fn __validate__(calls: Array&lt;Call&gt;) -&gt; felt252;
        fn is_valid_signature(hash: felt252, signature: Array&lt;felt252&gt;) -&gt; felt252;
        fn __execute__(calls: Array&lt;Call&gt;) -&gt; Array&lt;Span&lt;felt252&gt;&gt;;
    }
<span class="boring">}</span></code></pre></pre>
<p>The functions represented above serve the following purposes:</p>
<ul>
<li>
<p><code>__validate__</code>: This function takes in the list of calls scheduled
for execution and validates them in line with the rules specified in
the contract. It returns a short string (e.g., VALID) encapsulated
within a <code>felt252</code> that signifies the validation outcome.</p>
</li>
<li>
<p><code>is_valid_signature</code>: This function is tasked with validating the
signature of a transaction. It receives a hash of the transaction
data and a signature, which may be validated against a public key or
through any other method as specified by the contract creator. It
returns a short string (e.g., VALID) encapsulated within a <code>felt252</code>
that signifies the validation outcome.</p>
</li>
<li>
<p><code>__execute__</code>: Post-validation, the <code>__execute__</code> function is
responsible for executing an array of contract calls (as <code>Call</code>
structs). It returns an array of <code>Span&lt;felt252&gt;</code> structs
representing the return values of the executed calls.</p>
</li>
</ul>
<p>Moreover, the <code>SNIP-5</code> (Standard Interface Detection) trait needs to be
defined with a function called <code>supports_interface</code>. This function
verifies whether a contract supports a specific interface, receiving an
interface ID and returning a boolean.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    trait ISRC5 {
        fn supports_interface(interface_id: felt252) -&gt; bool;
    }
<span class="boring">}</span></code></pre></pre>
<p>Until now, we’ve mentioned contract calls without explicitly defining
them. Let’s remedy that.</p>
<p>The <code>Call</code> struct represents a single contract call:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct Call {
        to: ContractAddress,
        selector: felt252,
        calldata: Array&lt;felt252&gt;
    }
<span class="boring">}</span></code></pre></pre>
<p>Here’s what each field signifies:</p>
<ul>
<li>
<p><code>to</code>: The address of the target contract.</p>
</li>
<li>
<p><code>selector</code>: The function’s selector to be invoked on the target
contract.</p>
</li>
<li>
<p><code>calldata</code>: An array that encapsulates the function parameters.</p>
</li>
</ul>
<p>The elements described above are foundational to defining an account
contract and sufficient to implement the SNIP-6 standard. Nevertheless,
there are additional components that can be incorporated to bolster the
account contract’s functionality. For instance, the
<code>__validate_declare__</code> function might be added if the contract is used
to declare other contracts, providing a mechanism to validate the
contract declaration. Additionally, to counterfactually deploy a smart
contract (i.e., have it pay for its own deployment), one can include the
<code>__validate_deploy__</code> function. Detailed implementations of these
functions will be covered in the subsequent chapters.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>We elucidated the unique aspects of account contracts and their
derivation from basic smart contracts by adhering to specific methods
outlined in SNIP-6.</p>
<p>We defined the <code>ISRC6</code> trait, detailing the critical functions, namely,
<code>__validate__</code>, <code>is_valid_signature</code>, and <code>__execute__</code>. These functions
carry out tasks such as transaction validation, signature verification,
and contract call execution, respectively. We further introduced the
<code>ISRC5</code> trait, emphasizing the <code>supports_interface</code> function for
verifying interface support in contracts.</p>
<p>Furthermore, we defined a single contract call using the <code>Call</code> struct,
explaining its fields— <code>to</code>, <code>selector</code>, and <code>calldata</code>. We also
discussed potential enhancements to account contracts using
<code>__validate_declare__</code> and <code>__validate_deploy__</code> functions. These
additional features, along with detailed function implementations, will
be explored in the chapters ahead.</p>
<p>In the next subchapter, we will implement a simple account contract and
learn how to deploy it on Starknet. This will provide a practical
understanding of how account contracts work and how to interact with
them.</p>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world-account-contract"><a class="header" href="#hello-world-account-contract">Hello World Account Contract</a></h1>
<p><strong>NOTE:</strong>
<strong>THIS CHAPTER NEEDS TO BE UPDATED TO REFLECT THE NEW SYNTAX FOR ACCOUNT CONTRACTS. PLEASE DO NOT USE THIS CHAPTER AS A REFERENCE UNTIL THIS NOTE IS REMOVED.</strong></p>
<p><strong>CONTRIBUTE: This subchapter is missing an example of declaration, deployment and interaction with the contract. We would love to see your contribution! Please submit a PR.</strong></p>
<p>In this chapter, we will explore the fundamentals of account contracts
in Starknet using an example &quot;Hello World&quot; account contract written in
Cairo language. You can find it in the contracts directory of this
chapter in the Book’s repository (TODO: add link).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Import necessary modules
    #[account_contract]
    mod HelloAccount {
        use starknet::ContractAddress;
        use core::felt252;
        use array::ArrayTrait;
        use array::SpanTrait;

        // Validate deployment of the contract.
        // Returns starknet::VALIDATED to confirm successful validation.
        #[external]
        fn __validate_deploy__(
            class_hash: felt252, contract_address_salt: felt252, public_key_: felt252
        ) -&gt; felt252 {
            starknet::VALIDATED
        }

        // Validate declaration of transactions using this Account.
        // This function enforces that transactions now require accounts to pay fees.
        // Returns starknet::VALIDATED to confirm successful validation.
        #[external]
        fn __validate_declare__(class_hash: felt252) -&gt; felt252 {
            starknet::VALIDATED
        }

        // Validate transaction before execution.
        // This function is called by the account contract upon receiving a transaction.
        // If the validation is successful, it returns starknet::VALIDATED.
        #[external]
        fn __validate__(
            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::&lt;felt252&gt;
        ) -&gt; felt252 {
            starknet::VALIDATED
        }

        // Execute transaction.
        // If the '__validate__' function is successful, this '__execute__' function will be called.
        // It forwards the call to the target contract using starknet::call_contract_syscall.
        #[external]
        #[raw_output]
        fn __execute__(
            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::&lt;felt252&gt;
        ) -&gt; Span::&lt;felt252&gt; {
            starknet::call_contract_syscall(
                address: contract_address,
                entry_point_selector: entry_point_selector,
                calldata: calldata.span()
            ).unwrap_syscall()
        }
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="external-functions"><a class="header" href="#external-functions">External Functions</a></h2>
<p>The account contract includes several external functions to handle the
validation and execution of transactions. These functions are:</p>
<ol>
<li>
<p><code>__validate_deploy__</code>: Validates the deployment of the contract.</p>
</li>
<li>
<p><code>__validate_declare__</code>: Validates the declaration of transactions
using the account.</p>
</li>
<li>
<p><code>__validate__</code>: Validates a transaction before execution.</p>
</li>
<li>
<p><code>__execute__</code>: Executes a transaction after successful validation.</p>
</li>
</ol>
<h3 id="validate_deploy"><a class="header" href="#validate_deploy"><em>validate_deploy</em></a></h3>
<p>This function is responsible for validating the deployment of the
account contract. It returns <code>starknet::VALIDATED</code> to confirm successful
validation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[external]
    fn __validate_deploy__(
        class_hash: felt252, contract_address_salt: felt252, public_key_: felt252
    ) -&gt; felt252 {
        starknet::VALIDATED
    }
<span class="boring">}</span></code></pre></pre>
<h3 id="validate_declare"><a class="header" href="#validate_declare"><em>validate_declare</em></a></h3>
<p>This function enforces that transactions now require accounts to pay
fees. It returns <code>starknet::VALIDATED</code> to confirm successful validation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[external]
    fn __validate_declare__(class_hash: felt252) -&gt; felt252 {
        starknet::VALIDATED
    }
<span class="boring">}</span></code></pre></pre>
<h3 id="validate"><a class="header" href="#validate"><em>validate</em></a></h3>
<p>This function is called by the account contract upon receiving a
transaction. If the validation is successful, it returns
<code>starknet::VALIDATED</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[external]
    fn __validate__(
        contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::&lt;felt252&gt;
    ) -&gt; felt252 {
        starknet::VALIDATED
    }
<span class="boring">}</span></code></pre></pre>
<h3 id="execute"><a class="header" href="#execute"><em>execute</em></a></h3>
<p>If the <code>__validate__</code> function is successful, this <code>__execute__</code>
function will be called. It forwards the call to the target contract
using <code>starknet::call_contract_syscall</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[external]
    #[raw_output]
    fn __execute__(
        contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::&lt;felt252&gt;
    ) -&gt; Span::&lt;felt252&gt; {
        starknet::call_contract_syscall(
            address: contract_address,
            entry_point_selector: entry_point_selector,
            calldata: calldata.span()
        ).unwrap_syscall()
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="declaring-and-deploying-the-hello-world-account-contract"><a class="header" href="#declaring-and-deploying-the-hello-world-account-contract">Declaring and Deploying the Hello World Account Contract</a></h2>
<p>The declaring and deploying process is the same as with other contracts.
Before declaring and deploying the Hello World account contract, you
must first have an account contract set up to manage the deployment
process. To learn more about deploying an account contract, refer to the
subchapter on deploying in Chapter 2 of the Book.</p>
<p>Remember to compile using <code>scarb build</code> (refer to the Scarb subchapter
in Chapter 2 of the Book). Then follow the steps below to declare and
deploy the Hello World account contract:</p>
<ul>
<li>Export the required environment variables:</li>
</ul>
<!-- -->
<pre><code>export STARKNET_NETWORK=alpha-goerli
export STARKNET_WALLET=starkware.starknet.wallets.open_zeppelin.OpenZeppelinAccount
</code></pre>
<ul>
<li>Declare the contract (since the contract is already declared, you
can skip this step. If you want to declare it anyway, run the
following command but you will receive an error):</li>
</ul>
<!-- -->
<pre><code>starknet declare --contract target/release/starknetbook_chapter_7_HelloAccount.json --account my_account --max_fee 100000000000000000
</code></pre>
<p>The class hash is:
0x07e813097812d58afbb4fb015e683f2b84e4f008cbecc60fa6dece7734a2cdfe</p>
<ul>
<li>Deploy the contract:</li>
</ul>
<!-- -->
<pre><code>starknet deploy --class_hash 0x07e813097812d58afbb4fb015e683f2b84e4f008cbecc60fa6dece7734a2cdfe --account my_account --max_fee 100000000000000000
</code></pre>
<p>After completing these steps, you will have successfully declared and
deployed the Hello World account contract on Starknet. <a href="https://testnet.starkscan.co/contract/0x01e6d7698ca76788c8f9c1091ec3d6d3f7167a9effe520402d832ca9894eba4a#overview">Here is a
deployed
version</a>.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>In this subchapter, we delved into the details of a basic account
contract in Starknet using a &quot;Hello World&quot; example.</p>
<p>We also outlined the steps to declare and deploy the Hello World account
contract on the Starknet network. The deployment process involves
exporting the required environment variables, declaring the contract,
and deploying it using the class hash.</p>
<p>As we progress in our exploration of Starknet account contracts, the
next subchapter will introduce a standard account contract, drawing
parallels with the standard account contract defined by Open Zeppelin
and Starkware. This will further strengthen our understanding of how
account contracts operate within the Starknet ecosystem.</p>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-account-contract"><a class="header" href="#standard-account-contract">Standard Account Contract</a></h1>
<p><strong>NOTE:</strong>
<strong>THIS CHAPTER NEEDS TO BE UPDATED TO REFLECT THE NEW SYNTAX FOR ACCOUNT CONTRACTS. PLEASE DO NOT USE THIS CHAPTER AS A REFERENCE UNTIL THIS NOTE IS REMOVED.</strong></p>
<p><strong>CONTRIBUTE: This subchapter is missing an example of declaration, deployment and interaction with the contract. We would love to see your contribution! Please submit a PR.</strong></p>
<p>In this chapter, we build upon our exploration of account contracts in
Starknet by introducing a more complex account contract. This Standard
Account Contract includes additional features such as signature
validation, providing a more robust example of an account contract in
Cairo language. You can find the full code for this contract in the Book
repository (todo: add link). You can interact and compile the contract
using Scarb (review the Scarb subchapter in Chapter 2 of the Book for
more information).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Import necessary modules and traits
    use serde::Serde;
    use starknet::ContractAddress;
    use array::ArrayTrait;
    use array::SpanTrait;
    use option::OptionTrait;

    // Define the Account contract
    #[account_contract]
    mod Account {
        use array::ArrayTrait;
        use array::SpanTrait;
        use box::BoxTrait;
        use ecdsa::check_ecdsa_signature;
        use option::OptionTrait;
        use super::Call;
        use starknet::ContractAddress;
        use zeroable::Zeroable;
        use serde::ArraySerde;

        // Define the contract's storage variables
        struct Storage {
            public_key: felt252
        }

        // Constructor function for initializing the contract
        #[constructor]
        fn constructor(public_key_: felt252) {
            public_key::write(public_key_);
        }

        // Internal function to validate the transaction signature
        fn validate_transaction() -&gt; felt252 {
            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info
            let signature = tx_info.signature; // Extract signature
            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // Check signature length

            // Verify ECDSA signature
            assert(
                check_ecdsa_signature(
                    message_hash: tx_info.transaction_hash,
                    public_key: public_key::read(),
                    signature_r: *signature[0_u32],
                    signature_s: *signature[1_u32],
                ),
                'INVALID_SIGNATURE',
            );

            starknet::VALIDATED // Return validation status
        }

        // Validate contract deployment
        #[external]
        fn __validate_deploy__(
            class_hash: felt252, contract_address_salt: felt252, public_key_: felt252
        ) -&gt; felt252 {
            validate_transaction()
        }

        // Validate contract declaration
        #[external]
        fn __validate_declare__(class_hash: felt252) -&gt; felt252 {
            validate_transaction()
        }

        // Validate contract execution
        #[external]
        fn __validate__(
            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array&lt;felt252&gt;
        ) -&gt; felt252 {
            validate_transaction()
        }

        // Execute a contract call
        #[external]
        #[raw_output]
        fn __execute__(mut calls: Array&lt;Call&gt;) -&gt; Span&lt;felt252&gt; {
            // Validate caller
            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');

            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info
            assert(tx_info.version != 0, 'INVALID_TX_VERSION');

            assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // Only single calls are supported
            let Call{to, selector, calldata } = calls.pop_front().unwrap();

            // Call the target contract
            starknet::call_contract_syscall(
                address: to, entry_point_selector: selector, calldata: calldata.span()
            ).unwrap_syscall()
        }
    }

    // Define the Call struct
    #[derive(Drop, Serde)]
    struct Call {
        to: ContractAddress,
        selector: felt252,
        calldata: Array&lt;felt252&gt;
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="grasping-ecdsa-signature"><a class="header" href="#grasping-ecdsa-signature">Grasping ECDSA Signature</a></h2>
<p>Elliptic Curve Digital Signature Algorithm (ECDSA) is a cryptographic
protocol extensively utilized across various blockchains to ensure data
integrity and verify the sender’s authenticity. As a variant of the
Digital Signature Algorithm (DSA), ECDSA leverages elliptic curve
cryptography, offering superior security with shorter keys than the
traditional DSA.</p>
<p>An ECDSA signature comprises two components, commonly referred to as <em>r</em>
and <em>s</em>. These two values, generated using the signer’s private key and
the hash of the message (or transaction) being signed, collectively form
the signature for a given input.</p>
<h3 id="deciphering-signature_r-and-signature_s"><a class="header" href="#deciphering-signature_r-and-signature_s">Deciphering signature_r and signature_s</a></h3>
<p>Within the context of the Standard Account Contract, <em>signature_r</em> and
<em>signature_s</em> represent the two constituents of the ECDSA signature.
These are utilized in the <em>check_ecdsa_signature</em> function to
authenticate the transaction’s legitimacy.</p>
<ul>
<li>
<p><code>signature_r (r)</code>: A random number generated during the signing
process, unique for each signature. Reusing <em>r</em> across different
messages may lead to private key exposure.</p>
</li>
<li>
<p><code>signature_s (s)</code>: This is computed using <em>r</em>, the private key, and
the hash of the message. Like <em>r</em>, <em>s</em> is also unique for each
signature.</p>
</li>
</ul>
<p>The function <em>check_ecdsa_signature</em> takes these two values, the
public key of the signer, and the hash of the message to authenticate
the signature. A valid signature indicates that the message was indeed
signed by the private key owner and remains unaltered.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>            assert(
                check_ecdsa_signature(
                    message_hash: tx_info.transaction_hash,
                    public_key: public_key::read(),
                    signature_r: *signature[0_u32],
                    signature_s: *signature[1_u32],
                ),
                'INVALID_SIGNATURE',
            );
<span class="boring">}</span></code></pre></pre>
<p>The above code snippet employs <em>check_ecdsa_signature</em> function to
assert the legitimacy of the transaction signature. If the signature is
not valid, the assertion fails, returning <em>INVALID_SIGNATURE</em>.</p>
<h2 id="contract-anatomy"><a class="header" href="#contract-anatomy">Contract Anatomy</a></h2>
<h3 id="storage"><a class="header" href="#storage">Storage</a></h3>
<p>In the standard account contract, we declare a single storage variable:
<em>public_key</em>. This assists in transaction signature validation. The
public key, stored as a <em>felt252</em> (a 252-bit unsigned integer), is
written to the storage in the constructor function and is accessed from
the storage in the <em>validate_transaction</em> function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct Storage {
        public_key: felt252
    }
<span class="boring">}</span></code></pre></pre>
<h3 id="constructor"><a class="header" href="#constructor">Constructor</a></h3>
<p>The constructor function serves to initialize the contract, storing the
supplied public key in the contract’s storage.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[constructor]
    fn constructor(public_key_: felt252) {
        public_key::write(public_key_);
    }
<span class="boring">}</span></code></pre></pre>
<h3 id="validate_transaction"><a class="header" href="#validate_transaction"><code>validate_transaction</code></a></h3>
<p>This internal function validates the transaction signature. It retrieves
the signature from the transaction info, checks its length, and verifies
the ECDSA signature. If the signature is legitimate, it returns
starknet::VALIDATED, otherwise an error. This function is invoked by
<strong>validate_deploy</strong>, <strong>validate_declare</strong>, and <strong>validate</strong> functions.</p>
<p>The inclusion of this function is optional. If transaction signature
validation is not required, it can be omitted. However, its inclusion in
your account contract is advised to ensure transaction validity and to
facilitate its reuse in all three validation functions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn validate_transaction() -&gt; felt252 {
            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info
            let signature = tx_info.signature; // Extract signature
            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // Check signature length

            // Verify ECDSA signature
            assert(
                check_ecdsa_signature(
                    message_hash: tx_info.transaction_hash,
                    public_key: public_key::read(),
                    signature_r: *signature[0_u32],
                    signature_s: *signature[1_u32],
                ),
                'INVALID_SIGNATURE',
            );

            starknet::VALIDATED // Return validation status
        }
<span class="boring">}</span></code></pre></pre>
<h3 id="call-struct"><a class="header" href="#call-struct">Call Struct</a></h3>
<p>The Call struct outlines the parameters required for a contract call.
These parameters comprise the target contract address (to), the function
to be called (selector), and the function’s arguments (calldata). The
Call struct is utilized in the <em>execute</em> function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[derive(Drop, Serde)]
    struct Call {
        to: ContractAddress,
        selector: felt252,
        calldata: Array&lt;felt252&gt;
    }
<span class="boring">}</span></code></pre></pre>
<h3 id="execute-1"><a class="header" href="#execute-1">execute</a></h3>
<p>This external function triggers a transaction post successful
validation. It ensures the caller’s validity, checks for a non-zero
transaction version, and supports only single calls. Post validation, it
forwards the call to the target contract. The contract creator can
incorporate multiple calls to different contracts or the same contract
(multicall) within this function. The function returns the output from
the target contract.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        #[external]
        #[raw_output]
        fn __execute__(mut calls: Array&lt;Call&gt;) -&gt; Span&lt;felt252&gt; {
            // Validate caller
            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');

            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info
            assert(tx_info.version != 0, 'INVALID_TX_VERSION');

            assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // Only single calls are supported
            let Call{to, selector, calldata } = calls.pop_front().unwrap();

            // Call the target contract
            starknet::call_contract_syscall(
                address: to, entry_point_selector: selector, calldata: calldata.span()
            ).unwrap_syscall()
        }
<span class="boring">}</span></code></pre></pre>
<h2 id="improvements-to-the-standard-account-contract"><a class="header" href="#improvements-to-the-standard-account-contract">Improvements to the Standard Account Contract</a></h2>
<p>The implementation of the Standard Account Contract has a few
limitations:</p>
<ul>
<li>
<p>It currently supports only single calls. We could support multicalls
to improve the flexibility and utility of the contract.</p>
</li>
<li>
<p>The ECDSA signature algorithm, while secure, can be computationally
intensive. Future versions could explore using more efficient
signature algorithms, such as Schnorr or BLS. Or quantum-resistant
signature algorithms, such as the STARKs.</p>
</li>
</ul>
<p>Despite these limitations, the Standard Account Contract provides a
robust and secure foundation for creating and interacting with smart
contracts on Starknet.</p>
<h2 id="declaring-and-deploying-the-hello-world-account-contract-1"><a class="header" href="#declaring-and-deploying-the-hello-world-account-contract-1">Declaring and Deploying the Hello World Account Contract</a></h2>
<p>This time we have a constructor function that takes the public key as an
argument. We need to generate a private key with the corresponding
public key.</p>
<p>TODO: add section on how to generate a private key and public key.</p>
<ul>
<li>Export the required environment variables:</li>
</ul>
<!-- -->
<pre><code>export STARKNET_NETWORK=alpha-goerli
export STARKNET_WALLET=starkware.starknet.wallets.open_zeppelin.OpenZeppelinAccount
</code></pre>
<ul>
<li>Declare the contract (since the contract is already declared, you
can skip this step. If you want to declare it anyway, run the
following command but you will receive an error):</li>
</ul>
<!-- -->
<pre><code>starknet declare --contract target/release/starknetbook_chapter_7_Account.json --account vote_admin --max_fee 100000000000000000
</code></pre>
<p>The class hash is:
0x05501f7806d3d11cab101e19001e409dd4760200c2da2fe03761750f66e4a5e1</p>
<ul>
<li>Deploy the contract:</li>
</ul>
<p>TODO: add section on how to deploy the contract.</p>
<p>Elliptic Curve Digital Signature Algorithm (ECDSA) is a popular choice
for ensuring data integrity and sender authenticity in blockchain
networks, but it’s not the only option. Other alternatives include:</p>
<ul>
<li>
<p>EdDSA (Edwards-curve Digital Signature Algorithm): EdDSA is another
form of elliptic curve cryptography that is designed to be faster
and more secure than ECDSA. EdDSA uses twisted Edwards curves, which
have strong security properties and allow for more efficient
computations. An example of EdDSA in use is Monero.</p>
</li>
<li>
<p>Schnorr Signatures: Schnorr signatures offer a level of security
similar to ECDSA but with shorter signatures. They have the
additional property of being linear, which allows for signature
aggregation and multi-signatures. This can lead to increased
efficiency and privacy. Bitcoin developers have proposed adding
Schnorr signatures to the Bitcoin protocol with the Taproot upgrade.</p>
</li>
<li>
<p>RSA (Rivest–Shamir–Adleman): RSA is an older cryptographic algorithm
that is widely used for secure data transmission. However, RSA
requires larger key sizes for equivalent security levels, making it
less efficient than elliptic curve techniques. RSA is not commonly
used in modern blockchain systems, but it is still used in many
traditional secure communication protocols.</p>
</li>
<li>
<p>BLS (Boneh-Lynn-Shacham) Signatures: BLS signatures, like Schnorr,
allow for signature aggregation, making them useful in systems that
require a large number of signatures. This property makes BLS
signatures particularly useful for consensus algorithms in
distributed systems and blockchains, such as Ethereum 2.0.</p>
</li>
<li>
<p>Post-Quantum Cryptography: With the advent of quantum computing,
researchers are developing new cryptographic algorithms that are
resistant to quantum attacks. One example are the STARKs used in
Starknet.</p>
</li>
</ul>
<p>Each of these alternatives has its strengths and weaknesses in terms of
security, efficiency, complexity, and mathematical properties.</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>In this chapter, we expanded on our understanding of account contracts
in Starknet by examining a more complex &quot;Standard Account Contract&quot;. We
dove into the various components of the contract and learned how they
work together to validate and execute transactions.</p>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>Here, we will explore numerous examples, elucidating the principles and
techniques to effectively design and implement Account contracts.</p>
<p>Before delving into the examples, we would like to issue a disclaimer:
the contracts discussed in this chapter are for illustrative and
educational purposes, and they have not undergone formal auditing. This
signifies that, while we strive to provide accurate and informative
content, the implementation of these contracts in a live environment
should be approached with due diligence. We encourage users to
thoroughly test and validate these contracts before their deployment on
the mainnet.</p>
<p>The goal of this chapter is not only to furnish a library of contract
examples but also to foster collaboration and knowledge sharing among
the Starknet community. We believe that the exchange of ideas and
constructive feedback is instrumental in advancing our collective
understanding and expertise.</p>
<p>If you’ve developed or come across an innovative contract that could
serve as a valuable learning resource for others, we invite you to
contribute. Here are a few guidelines for your contribution:</p>
<ol>
<li>
<p><strong>Open a PR:</strong> To submit a contract example or suggest changes to
existing ones, simply open a Pull Request. Ensure that your PR
contains a thorough explanation of the contract, its use cases, and
its functionality.</p>
</li>
<li>
<p><strong>Code Standards:</strong> Please ensure that the submitted code is
well-documented and adheres to the standard code conventions of
Starknet. This will facilitate the review process and enhance the
readability and comprehensibility of the contract.</p>
</li>
<li>
<p><strong>Detailed Explanation:</strong> Accompany your code with a detailed
explanation of the contract logic. Wherever possible, use diagrams,
flowcharts, or pseudocode to illustrate complex mechanisms or
workflows.</p>
</li>
</ol>
<p>As we expand this repertoire of contract examples, we hope to equip the
Starknet community with a robust toolset and inspire further exploration
and innovation in the realm of custom account contracts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multicaller-account"><a class="header" href="#multicaller-account">MultiCaller Account</a></h1>
<p><strong>NOTE:</strong>
<strong>THIS CHAPTER NEEDS TO BE UPDATED TO REFLECT THE NEW SYNTAX FOR ACCOUNT CONTRACTS. PLEASE DO NOT USE THIS CHAPTER AS A REFERENCE UNTIL THIS NOTE IS REMOVED.</strong></p>
<p><strong>CONTRIBUTE: This subchapter is missing an example of declaration, deployment and interaction with the contract. We would love to see your contribution! Please submit a PR.</strong></p>
<p><a href="https://github.com/joshstevens19/ethereum-multicall#readme">Multicall</a>
is a powerful technique that allows multiple constant smart contract
function calls to be aggregated into a single call, resulting in a
consolidated output. With Starknet’s account abstraction feature,
multicalls can be seamlessly integrated into account contracts.</p>
<h2 id="why-multicalls"><a class="header" href="#why-multicalls">Why Multicalls?</a></h2>
<p>Multicalls come handy in several scenarios. Here are some examples:</p>
<ol>
<li>
<p><strong>Token Swapping on Decentralized Exchanges</strong>: In a typical token
swap operation on a decentralized exchange (DEX), you first need to
approve the spending of the tokens and then initiate the swap.
Executing these operations separately could be cumbersome from a
user experience perspective. With multicall, these calls can be
combined into a single transaction, simplifying the user’s task.</p>
</li>
<li>
<p><strong>Fetching Blockchain Data</strong>: When you want to query the prices of
two different tokens from the blockchain, it’s beneficial to have
them both come from the same block for consistency. Multicall
returns the latest block number along with the aggregated results,
providing this consistency.</p>
</li>
</ol>
<p>The benefits of multicall transactions can be realized more in the
context of account abstraction.</p>
<h2 id="multicall-functionality-in-account-contracts"><a class="header" href="#multicall-functionality-in-account-contracts">Multicall Functionality in Account Contracts</a></h2>
<p>To facilitate multicalls, we can introduce specific functions in the
account contract. Here are two core functions:</p>
<h3 id="_execute_calls-function"><a class="header" href="#_execute_calls-function"><code>_execute_calls</code> Function</a></h3>
<p>The <code>_execute_calls</code> function is responsible for executing the
multicalls. It iterates over an array of calls, executes them, and
aggregates the results.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn _execute_calls(mut calls: Array&lt;AccountCall&gt;, mut res:Array::&lt;Array::&lt;felt&gt;&gt;) -&gt; Array::&lt;Array::&lt;felt&gt;&gt; {
        match calls.pop_front() {
            Option::Some(call) =&gt; {
                let _res = _call_contract(call);
                res.append(_res);
                return _execute_calls(calls, res);
            },
            Option::None(_) =&gt; {
                return res;
            },
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>Apart from the traditional <strong><code>execute</code></strong> function, adding the
<strong><code>_execute_calls</code></strong> function to your account contract can ensure that
you can make a multicall using your smart contract account.</p>
<p>The above code is a simple example snippet where the **&quot;return
<em>execute_calls(calls, res);&quot;</em> statement makes recursive calls to the
<strong><code>_execute_calls</code></strong> function thereby bundling the calls together.
The final result will be aggregated and returned in the <em><strong>res</strong></em>
variable.</p>
<h3 id="_call_contract-function"><a class="header" href="#_call_contract-function"><code>_call_contract</code> Function</a></h3>
<p>The <code>_call_contract</code> function is a helper function used to make
individual contract calls.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn _call_contract(call: AccountCall) -&gt; Array::&lt;felt&gt; {
        starknet::call_contract_syscall(
            call.to, call.selector, call.calldata
        ).unwrap_syscall()
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="considerations"><a class="header" href="#considerations">Considerations</a></h2>
<p>While multicall provides significant benefits in terms of UX and data
consistency, it’s important to note that it may not significantly reduce
gas fees compared to individual calls. However, the primary advantage of
using multicall is that it ensures results are derived from the same
block, providing a much-improved user experience.</p>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multi-signature-accounts"><a class="header" href="#multi-signature-accounts">Multi-Signature Accounts</a></h1>
<p><strong>NOTE:</strong>
<strong>THIS CHAPTER NEEDS TO BE UPDATED TO REFLECT THE NEW SYNTAX FOR ACCOUNT CONTRACTS. PLEASE DO NOT USE THIS CHAPTER AS A REFERENCE UNTIL THIS NOTE IS REMOVED.</strong></p>
<p><strong>CONTRIBUTE: This subchapter is missing an example of declaration, deployment and interaction with the contract. We would love to see your contribution! Please submit a PR.</strong></p>
<p>Multisignature (multisig) technology is an integral part of the modern
blockchain landscape. It enhances security by requiring multiple
signatures to confirm a transaction, hence reducing the risk of
fraudulent transactions and increasing control over asset management.</p>
<p>In Starknet, the concept of multisig accounts is abstracted at the
protocol level, allowing developers to implement custom account
contracts that embody this concept. In this chapter, we’ll delve into
the workings of a multisig account and see how it’s created in Starknet
using an account contract.</p>
<h2 id="what-is-a-multisig-account"><a class="header" href="#what-is-a-multisig-account">What is a Multisig Account?</a></h2>
<p>A multisig account is an account that requires more than one signature
to authorize transactions. This significantly enhances security,
requiring multiple entities' consent to transact funds or perform
critical actions.</p>
<p>Key specifications of a multisig account include:</p>
<ul>
<li>
<p>Public keys that form the account</p>
</li>
<li>
<p>Threshold number of signatures required</p>
</li>
</ul>
<p>A transaction signed by a multisig account must be individually signed
by the different keys specified for the account. If fewer than the
threshold number of signatures needed are present, the resultant
multisignature is considered invalid.</p>
<p>In Starknet, accounts are abstractions provided at the protocol level.
Therefore, to create a multisig account, one needs to code the logic
into an account contract and deploy it.</p>
<p>The contract below serves as an example of a multisig account contract.
When deployed, it can create a native multisig account using the concept
of account abstraction. Please note that this is a simplified example
and lacks comprehensive checks and validations found in a
production-grade multisig contract.</p>
<h2 id="multisig-account-contract"><a class="header" href="#multisig-account-contract">Multisig Account Contract</a></h2>
<p>This is the Rust code for a multisig account contract:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[account_contract]
    mod MultisigAccount {
        use ecdsa::check_ecdsa_signature;
        use starknet::ContractAddress;
        use zeroable::Zeroable;
        use array::ArrayTrait;
        use starknet::get_caller_address;
        use box::BoxTrait;
        use array::SpanTrait;

        struct Storage {
            index_to_owner: LegacyMap::&lt;u32, felt252&gt;,
            owner_to_index: LegacyMap::&lt;felt252, u32&gt;,
            num_owners: usize,
            threshold: usize,
            curr_tx_index: felt252,
            //Mapping between tx_index and num of confirmations
            tx_confirms: LegacyMap&lt;felt252, usize&gt;,
            //Mapping between tx_index and its execution state
            tx_is_executed: LegacyMap&lt;felt252, bool&gt;,
            //Mapping between a transaction index and its hash
            transactions: LegacyMap&lt;felt252, felt252&gt;,
            has_confirmed: LegacyMap::&lt;(ContractAddress, felt252), bool&gt;,
        }

        #[constructor]
        fn constructor(public_keys: Array::&lt;felt252&gt;, _threshold: usize) {
            assert(public_keys.len() &lt;= 3_usize, 'public_keys.len &lt;= 3');
            num_owners::write(public_keys.len());
            threshold::write(_threshold);
            _set_owners(public_keys.len(), public_keys);
        }

        //GETTERS
        //Get number of confirmations for a given transaction index
        #[view]
        fn get_confirmations(tx_index : felt252) -&gt; usize {
            tx_confirms::read(tx_index)
        }

        //Get the number of owners of this account
        #[view]
        fn get_num_owners() -&gt; usize {
            num_owners::read()
        }


        //Get the public key of the owners
        //TODO - Recursively add the owners into an array and return, maybe wait for loops to be enabled


        //EXTERNAL FUNCTIONS

        #[external]
        fn submit_tx(public_key: felt252) {

            //Need to check if caller is one of the owners.
            let tx_info = starknet::get_tx_info().unbox();
            let signature: Span&lt;felt252&gt; = tx_info.signature;
            let caller = get_caller_address();
            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');

            //Updating the transaction index
            let tx_index = curr_tx_index::read();

            //`true` if a signature is valid and `false` otherwise.
            assert(
                check_ecdsa_signature(
                    message_hash: tx_info.transaction_hash,
                    public_key: public_key,
                    signature_r: *signature.at(0_u32),
                    signature_s: *signature.at(1_u32),
                ),
                'INVALID_SIGNATURE',
            );

            transactions::write(tx_index, tx_info.transaction_hash);
            curr_tx_index::write(tx_index + 1);

        }

        #[external]
        fn confirm_tx(tx_index: felt252, public_key: felt252) {

            let transaction_hash = transactions::read(tx_index);
            //TBD: Assert that tx_hash is not null

            let num_confirmations = tx_confirms::read(tx_index);
            let executed = tx_is_executed::read(tx_index);

            assert(executed == false, 'TX_ALREADY_EXECUTED');

            let caller = get_caller_address();
            let tx_info = starknet::get_tx_info().unbox();
            let signature: Span&lt;felt252&gt; = tx_info.signature;

             assert(
                check_ecdsa_signature(
                    message_hash: tx_info.transaction_hash,
                    public_key: public_key,
                    signature_r: *signature.at(0_u32),
                    signature_s: *signature.at(1_u32),
                ),
                'INVALID_SIGNATURE',
            );

            let confirmed = has_confirmed::read((caller, tx_index));

            assert (confirmed == false, 'CALLER_ALREADY_CONFIRMED');
            tx_confirms::write(tx_index, num_confirmations+1_usize);
            has_confirmed::write((caller, tx_index), true);


        }

        //An example function to validate that there are at least two signatures
        fn validate_transaction(public_key: felt252) -&gt; felt252 {
            let tx_info = starknet::get_tx_info().unbox();
            let signature: Span&lt;felt252&gt; = tx_info.signature;
            let caller = get_caller_address();
            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');

            //`true` if a signature is valid and `false` otherwise.
            assert(
                check_ecdsa_signature(
                    message_hash: tx_info.transaction_hash,
                    public_key: public_key,
                    signature_r: *signature.at(0_u32),
                    signature_s: *signature.at(1_u32),
                ),
                'INVALID_SIGNATURE',
            );

            starknet::VALIDATED
        }

        //INTERNAL FUNCTION
        //Function to add the public keys of the multisig in permanent storage
        fn _set_owners(owners_len: usize, public_keys: Array::&lt;felt252&gt;) {
            if owners_len == 0_usize {
            }

            index_to_owner::write(owners_len, *public_keys.at(owners_len - 1_usize));
            owner_to_index::write(*public_keys.at(owners_len - 1_usize), owners_len);
            _set_owners(owners_len - 1_u32, public_keys);
        }


        #[external]
        fn __validate_deploy__(
            class_hash: felt252, contract_address_salt: felt252, public_key_: felt252
        ) -&gt; felt252 {
            validate_transaction(public_key_)
        }

        #[external]
        fn __validate_declare__(class_hash: felt252, public_key_: felt252) -&gt; felt252 {
            validate_transaction(public_key_)
        }

        #[external]
        fn __validate__(
            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::&lt;felt252&gt;, public_key_: felt252
        ) -&gt; felt252 {
            validate_transaction(public_key_)
        }

        #[external]
        #[raw_output]
        fn __execute__(
            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::&lt;felt252&gt;,
            tx_index: felt252
        ) -&gt; Span::&lt;felt252&gt; {
            // Validate caller.
            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');

            // Check the tx version here, since version 0 transaction skip the __validate__ function.
            let tx_info = starknet::get_tx_info().unbox();
            assert(tx_info.version != 0, 'INVALID_TX_VERSION');

            //Multisig check here
            let num_confirmations = tx_confirms::read(tx_index);
            let owners_len = num_owners::read();
            //Subtracting one for the submitter
            let required_confirmations = threshold::read() - 1_usize;
            assert(num_confirmations &gt;= required_confirmations, 'MINIMUM_50%_CONFIRMATIONS');

            tx_is_executed::write(tx_index, true);

            starknet::call_contract_syscall(
                contract_address, entry_point_selector, calldata.span()
            ).unwrap_syscall()
        }
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="multisig-transaction-flow"><a class="header" href="#multisig-transaction-flow">Multisig Transaction Flow</a></h2>
<p>The flow of a multisig transaction includes the following steps:</p>
<ol>
<li>
<p>Submitting a transaction: Any of the owners can submit a transaction
from the account.</p>
</li>
<li>
<p>Confirming the transaction: The owner who hasn’t submitted a
transaction can confirm the transaction.</p>
</li>
</ol>
<p>The transaction will be successfully executed if the number of
confirmations (including the submitter’s signature) is greater than or
equal to the threshold number of signatures, else it fails. This
mechanism of confirmation ensures that no single party can unilaterally
perform critical actions, thereby enhancing the security of the account.</p>
<h2 id="exploring-multisig-functions"><a class="header" href="#exploring-multisig-functions">Exploring Multisig Functions</a></h2>
<p>Let’s take a closer look at the various functions associated with
multisig functionality in the provided contract.</p>
<h3 id="_set_owners-function"><a class="header" href="#_set_owners-function"><code>_set_owners</code> Function</a></h3>
<p>This is an internal function designed to add the public keys of the
account owners to a permanent storage. Ideally, a multisig account
structure should permit adding and deleting owners as per the agreement
of the account owners. However, each change should be a transaction
requiring the threshold number of signatures.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    //INTERNAL FUNCTION
    //Function to add the public keys of the multisig in permanent storage
    fn _set_owners(owners_len: usize, public_keys: Array::&lt;felt252&gt;) {
        if owners_len == 0_usize {
        }

        index_to_owner::write(owners_len, *public_keys.at(owners_len - 1_usize));
        owner_to_index::write(*public_keys.at(owners_len - 1_usize), owners_len);
        _set_owners(owners_len - 1_u32, public_keys);
    }
<span class="boring">}</span></code></pre></pre>
<h3 id="submit_tx-function"><a class="header" href="#submit_tx-function"><code>submit_tx</code> Function</a></h3>
<p>This external function allows the owners of the account to submit
transactions. Upon submission, the function checks the validity of the
transaction, ensures the caller is one of the account owners, and adds
the transaction to the transactions map. It also increments the current
transaction index.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[external]
    fn submit_tx(public_key: felt252) {

        //Need to check if caller is one of the owners.
        let tx_info = starknet::get_tx_info().unbox();
        let signature: Span&lt;felt252&gt; = tx_info.signature;
        let caller = get_caller_address();
        assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');

        //Updating the transaction index
        let tx_index = curr_tx_index::read();

        //`true` if a signature is valid and `false` otherwise.
        assert(
            check_ecdsa_signature(
                message_hash: tx_info.transaction_hash,
                public_key: public_key,
                signature_r: *signature.at(0_u32),
                signature_s: *signature.at(1_u32),
            ),
            'INVALID_SIGNATURE',
        );

        transactions::write(tx_index, tx_info.transaction_hash);
        curr_tx_index::write(tx_index + 1);

    }
<span class="boring">}</span></code></pre></pre>
<h3 id="confirm_tx-function"><a class="header" href="#confirm_tx-function"><code>confirm_tx</code> Function</a></h3>
<p>Similarly, the <em><strong><code>confirm_tx</code></strong></em> function provides a way to record
confirmations for each transaction. An account owner, who did not submit
the transaction, can confirm it, increasing its confirmation count.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        #[external]
        fn confirm_tx(tx_index: felt252, public_key: felt252) {

            let transaction_hash = transactions::read(tx_index);
            //TBD: Assert that tx_hash is not null

            let num_confirmations = tx_confirms::read(tx_index);
            let executed = tx_is_executed::read(tx_index);

            assert(executed == false, 'TX_ALREADY_EXECUTED');

            let caller = get_caller_address();
            let tx_info = starknet::get_tx_info().unbox();
            let signature: Span&lt;felt252&gt; = tx_info.signature;

             assert(
                check_ecdsa_signature(
                    message_hash: tx_info.transaction_hash,
                    public_key: public_key,
                    signature_r: *signature.at(0_u32),
                    signature_s: *signature.at(1_u32),
                ),
                'INVALID_SIGNATURE',
            );

            let confirmed = has_confirmed::read((caller, tx_index));

            assert (confirmed == false, 'CALLER_ALREADY_CONFIRMED');
            tx_confirms::write(tx_index, num_confirmations+1_usize);
            has_confirmed::write((caller, tx_index), true);
        }
<span class="boring">}</span></code></pre></pre>
<h3 id="execute-function"><a class="header" href="#execute-function"><em><code>execute</code></em> Function</a></h3>
<p>The <em>execute</em> function serves as the final step in the transaction
process. It checks the validity of the transaction, whether it has been
previously executed, and if the threshold number of signatures has been
reached. The transaction is executed if all the checks pass.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[external]
        #[raw_output]
        fn __execute__(
            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::&lt;felt252&gt;,
            tx_index: felt252
        ) -&gt; Span::&lt;felt252&gt; {
            // Validate caller.
            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');

            // Check the tx version here, since version 0 transaction skip the __validate__ function.
            let tx_info = starknet::get_tx_info().unbox();
            assert(tx_info.version != 0, 'INVALID_TX_VERSION');

            //Multisig check here
            let num_confirmations = tx_confirms::read(tx_index);
            let owners_len = num_owners::read();
            //Subtracting one for the submitter
            let required_confirmations = threshold::read() - 1_usize;
            assert(num_confirmations &gt;= required_confirmations, 'MINIMUM_50%_CONFIRMATIONS');

            tx_is_executed::write(tx_index, true);

            starknet::call_contract_syscall(
                contract_address, entry_point_selector, calldata.span()
            ).unwrap_syscall()
        }
<span class="boring">}</span></code></pre></pre>
<h2 id="closing-thoughts"><a class="header" href="#closing-thoughts">Closing Thoughts</a></h2>
<p>This chapter has introduced you to the concept of multisig accounts in
Starknet and illustrated how they can be implemented using an account
contract. However, it’s important to note that this is a simplified
example, and a production-grade multisig contract should contain
additional checks and validations for robustness and security.</p>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="auto-payments-"><a class="header" href="#auto-payments-">Auto-Payments 🚧</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alternative-signature-schemes-"><a class="header" href="#alternative-signature-schemes-">Alternative Signature Schemes 🚧</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starks"><a class="header" href="#starks">STARKs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>By now there are quite a few theoretical constructions of proof systems,
along with implementations. Some are deployed in cryptocurrencies, like
the <a href="https://z.cash/technology/zksnarks/">SNARKs</a> used by
<a href="http://zerocash-project.org/paper">Zerocash</a>, <a href="https://z.cash/">Zcash</a>,
and <a href="https://eprint.iacr.org/2017/1066">Bulletproofs</a> (BP) deployed in
<a href="https://ww.getmonero.org/">Monero</a>. (For general information on proof
systems go <a href="https://zkp.science/">here</a>.) What distinguishes
<a href="https://eprint.iacr.org/2018/046">STARKs</a> is the combination of the
following three properties: scalability (the S in STARK), transparency
(the T in STARK), and lean cryptography.</p>
<h1 id="scalability-exponential-speedup-of-verification"><a class="header" href="#scalability-exponential-speedup-of-verification">Scalability: Exponential Speedup of Verification**</a></h1>
<p>Scalability means that two efficiency properties hold simultaneously:</p>
<ul>
<li>
<p><strong>Scalable Prover</strong>: The prover’s running time is &quot;<code>nearly-linear</code>&quot;
in the time it would take a trusted computer to check CI by just
re-executing the computation themselves and checking that the result
matches what someone is claiming. The ratio of &quot;<code>overhead</code>&quot; (time
needed to generate a proof / time needed to just run the
computation) remains reasonably low.</p>
</li>
<li>
<p><strong>Scalable Verifier</strong>: The verifier’s running time is polynomial in
the logarithm of naive replay time. In other words, the verifier’s
runtime is exponentially smaller than simply replaying the
computation (recall that <em><code>replay</code></em> is the current blockchain method
to achieve Inclusive Accountability).</p>
</li>
</ul>
<figure>
<img src="scalable.png" alt="scalable" />
</figure>
<p>Apply this notion of scalability to a blockchain. Instead of the current
mode of verification by naive replay, imagine how things will look when
a blockchain moves to verification by using proof systems. Instead of
simply sending the transactions to be added to the blockchain, a prover
node will need to generate a proof but thanks to the Scalable Prover its
running time is nearly-linear in the running time of the naive replay
solution. And the Scalable Verifier will benefit from an exponential
decrease in its verification time. Furthermore, as blockchain throughput
scales up, most of the effect will be shouldered by the prover nodes
(which could run on dedicated hardware, like miners), whereas the
verifiers, which would constitute most of the nodes in the network,
would hardly be affected.</p>
<p>Let’s consider a concrete hypothetical example, assuming verifier time
(in milliseconds) scales like the square of the logarithm of the number
of transactions (tx). Suppose we start with 10,000 tx/block. Then the
verifier’s running time is</p>
<p>$VTime = (log₂ 10,000)² <sub>(13.2)²</sub> 177 ms$.</p>
<p>Now increase the blocksize a hundredfold (to 1,000,000 tx/block). The
new running time of the verifier is</p>
<p>$VTime = (log₂ 1,000,000)² <sub>20²</sub> 400 ms$.</p>
<p>In words, a 100x increase in transaction throughput led only to a 2.25x
increase in the verifier’s running time!</p>
<p>In some cases, the verifier will still need to download and verify
<em>availability of data</em>, which is a linear-time process, but downloading
data is generally much cheaper and faster than checking its validity.</p>
<h1 id="transparency-with-trust-toward-none-with-integrity-for-all"><a class="header" href="#transparency-with-trust-toward-none-with-integrity-for-all">Transparency: With Trust Toward None, with Integrity for All</a></h1>
<p>Transparency means there is no trusted setup (formally, a transparent
proof system is one in which all verifier messages are public random
strings. Such systems are also known as <a href="https://en.wikipedia.org/wiki/Arthur%E2%80%93Merlin_protocol">Arthur-Merlin
protocols</a>) — there
is no use of secrets in the setting up of the system. Transparency
offers many benefits. It eliminates the parameter setup generation
procedure which constitutes a single point of failure. The lack of a
trusted setup allows even powerful entities — big corporations,
monopolies and governments, which control the &quot;<code>old world</code>&quot; financial
system — to prove CI and gain public acceptance of their claims because
there’s no known way to forge STARK proofs of falsities, even by the
most powerful of entities. On a more tactical level, it makes it much
easier to deploy new tools and infrastructure and change existing ones
without a need for elaborate parameter-generation ceremonies. Most
importantly, transparency aligns well with the &quot;<code>new world</code>&quot; that
demands Inclusive Accountability under no trust assumptions. <a href="https://en.wikipedia.org/wiki/Abraham_Lincoln%27s_second_inaugural_address">To
paraphrase Abraham
Lincoln</a>,
transparent systems allow to operate with trust toward none, with
integrity for all.</p>
<h1 id="lean-cryptography-secure--fast"><a class="header" href="#lean-cryptography-secure--fast">Lean Cryptography: Secure &amp; Fast</a></h1>
<p>STARK has minimal cryptographic assumptions underlying its security: the
existence of secure cryptographic and <a href="https://en.wikipedia.org/wiki/Collision_resistance">collision-resistant hash
functions</a> (this
minimality of cryptographic assumptions holds for interactive STARKs
(iSTARKs). Noninteractive STARKs (nSTARKs) require the Fiat-Shamir
heuristic which is a different beast). Many of these primitives exist
today as hardware instructions, and the lean cryptography leads to two
more benefits:</p>
<ul>
<li>
<p><strong>Post-Quantum Security</strong>: STARKs are plausibly secure against
efficient quantum computers.</p>
</li>
<li>
<p><strong>Concrete Efficiency</strong>: For a given computation, the STARK prover
is at least 10x faster than both the SNARK and Bulletproofs prover.
The STARK verifier is at least 2x faster than the SNARK verifier and
more than 10x faster than the Bulletproof verifier. As Starkware
continues to optimize STARKs these ratios will likely improve.
However, a STARK proof length is
<sub>100x\ larger\ than\ the\ corresponding\ SNARK\ and</sub> 20x
larger than BulletProofs.</p>
</li>
</ul>
<p>To understand how STARKs are computed, we need to delve into the
arithmetic of modular operations, finite fields, and polynomials. For
this we will need to touch mathematical concepts that at first glance
might seem complicated, however, you will see that it is easier than you
thought.</p>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="math-primer"><a class="header" href="#math-primer">Math Primer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eulers-theorem"><a class="header" href="#eulers-theorem">Euler’s Theorem</a></h1>
<p>In <a href="https://en.wikipedia.org/wiki/Number_theory">number theory</a>,
<strong>Euler’s theorem</strong> (also known as the <strong>Fermat–Euler theorem</strong> or
<strong>Euler’s totient theorem</strong>) states that, if <em>n</em> and <em>a</em> are
<a href="https://en.wikipedia.org/wiki/Coprime_integers">coprime</a> positive
integers, and <em>φ(n)</em> is <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function">Euler’s totient
function</a>,
then <em>a</em> raised to the power <em>φ(n)</em> is congruent to 1
<a href="https://en.wikipedia.org/wiki/Modular_arithmetic">modulo</a> <em>n</em>; that is</p>
<h1 id="modular-arithmetic"><a class="header" href="#modular-arithmetic">Modular Arithmetic</a></h1>
<p>A system of arithmetic for integers where numbers &quot;wrap around&quot; when
reaching a certain value (aka <em>modulus</em>)</p>
<p><img src="modular.png" alt="modular" /></p>
<p>A real-world example of modular arithmetic is time-keeping via a clock.
When the hour of the day exceeds the modulus(12) we &quot;wrap&quot; around and
begin at zero.</p>
<p>Example:</p>
<pre><code>python3 finite_fields/python/modular_arithmetic.py
</code></pre>
<p>In other words, of a division we sometimes are more interested in the
<strong>remainder</strong>. Here is where we use the operator named as <strong>modulo
operator</strong> or simply <strong>mod</strong>. For example, $13\bmod5 = 3$ because
$\frac{13}{5}=2$ remainder $3$.</p>
<p>Let’s go through a couple examples:</p>
<ul>
<li>$-29\bmod3 = 1$</li>
</ul>
<p>If we divide $-29$ by $3$ we get a quotient of $9$ with a remainder of
$-2$; we substract $-2$ from $3$ (our modulus) to get $1$.</p>
<ul>
<li>$-9\bmod6 = 3$</li>
</ul>
<p>Divide $-9$ by $6$ to get $-1$ as quotient with a remainder of $-3$. We
then substract $-3$ from $6$ to get $3$ as our result.</p>
<ul>
<li>$7\bmod6 = 1$</li>
</ul>
<p>Divide $7$ by $6$ to get a quotient of $1$ with a remainder of $1$, our
result.</p>
<p>Note that the mod operator only gives positive numbers.</p>
<p>Modular arithmetic is the stepping stone for Fine Field Arithmetic which
will take us to understand elliptic curve cryptography, which in turn,
gives us the signing and verification algorithms in Ethereum. Signing
and verification are key for transactions in a blockchain.</p>
<h1 id="finite-fields"><a class="header" href="#finite-fields">Finite Fields</a></h1>
<p>Much of today’s practical cryptography is based on finite fields: a
finite set of numbers with two operations (addition and multiplication
from which we can define subtraction and division too).</p>
<p>The order or size of the field is usually called $p$ and is a prime
number. This is a finite field of order $p$: $F_p = {0, 1, 2, …, p—1
}$. A finite field of order 3 would be: $F_3 = {0, 1, 2}$.</p>
<p>A finite field cannot contain sub-fields since their order is prime.
Therefore, the fine field implements the principles of modular
arithmetic over a large, irreducible prime number.</p>
<p>Example:</p>
<pre><code>python3 finite_fields/python/finite_field_arithmetic.py
</code></pre>
<p>A key property of the finite field is that if <code>a</code> and <code>b</code> are in the
set, <code>a + b</code> and <code>a ⋅ b</code> should be in the set too. This is the
<strong>closed</strong> property. Thus, if we have $F_3$ then the sum $1 + 2 = 3$
violates the closed property because $3$ is not in the set $F_3$.
Something similar happens with the multiplication.</p>
<p>We need to make our finite field closed under arithmetic operations as
addition, substraction, multiplication and division. Here is where
modular arithmetic comes in handy. Most operations with finite fields
will be using modular arithmetic. We represent a finite field addition
as $+_f$ to distinguish it from a simple addition. We will do the same
for the symbols of other arithmetic operators.</p>
<p>Now, for our finite field $F_3$, $1$ $+_f$ $2$ $=$ $(1+2) \bmod 3$ $=$
$0$. Also $2$ $⋅_f$ $2$ $=$ $(2⋅2) \bmod 3$ $=$ $1$. Now we have close
operations for our finite field.</p>
<p>What about substraction? It is the same. For a finite field $F_3$, $1$
$-_f$ $2$ $=$ $(1-2) \bmod 3$ $=$ $2$. We are basically performing
modular arithmetic where the modulo is the finite field’s order. For
multiplication the case is similar.</p>
<p>Addition, Multiplication, Exponentiation, and Substraction of fields are
intuitive. However, Division of fields can be a bit challenging at the
beginning. Let’s begin with easy operations:</p>
<ul>
<li>
<p>For the finite field $F_3$, $2$ $/_f$ $2$ $=$ $(2/2) \bmod 3$ $=$
$1$. It makes sense since $2/2=1$.</p>
</li>
<li>
<p>For the finite field $F_3$, $6$ $/_f$ $2$ $=$ $(0/2) \bmod 3$ $=$
$0$. It makes sense since $0/2=0$.</p>
</li>
<li>
<p>For the finite field $F_3$, the operation $1$ $/_f$ $0$ $=$ $(1/0)
\bmod 3$ can not be performed since we can not divide by 0.</p>
</li>
<li>
<p>For the finite field $F_3$, $8$ $/_f$ $5$ $=$ $(2/2) \bmod 3$ $=$
$1$. It makes sense since $2/2=1$.</p>
</li>
</ul>
<p>Until now everything seems ok. However, what happens when, for the
finite field $F_5$, we divide $8$ $/_f$ $4$ $=$ $(3/4) \bmod 5$? The
result is not trivial.</p>
<h1 id="congruences"><a class="header" href="#congruences">Congruences</a></h1>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polynomials"><a class="header" href="#polynomials">Polynomials</a></h1>
<p><code>Polynomials</code> have properties that are very useful in <a href="https://www.youtube.com/watch?v=iAaSQfZ-2AM">ZK
proofs</a>. A polynomial is an
expression of more than two algebraic terms. The degree of a polynomial
is the highest degree of any specific term.</p>
<p>For an example of how Polynomials can be built and expressed in code.
Run:</p>
<h1 id="bash"><a class="header" href="#bash">[,bash]</a></h1>
<p>python3 finite_fields/python/polynomial.py ---</p>
<p>Polynomial arithmetic deals with the addition, subtraction,
multiplication, and division of polynomials.</p>
<p>We can represent a bit pattern by a polynomial in, say, the variable
$x$. Each power of $x$ in the polynomial can stand for a bit position in
a bit pattern. For example, we can represent:</p>
<ul>
<li></li>
<li></li>
<li>
<p>the pattern $011$ by the polynomial $x + 1$.</p>
</li>
</ul>
<p>Representing bit patterns with polynomials will allow us to create a
finite field with bit patterns.</p>
<p>In general, a polynomial is an expression of the form:</p>
<figure>
<img src="poly1.png" alt="poly1" />
</figure>
<p>for some non-negative integer $n$ and where the coefficients $a_{0}$,
$a_{1}$, $…$, $a_{n}$ are drawn from some designated set $S$. $S$ is
called the coefficient set. $n$ marks de degree of the polynomial. A
$0$-degree polynomial is called a constant polynomial.</p>
<p>In reality, we do not have intentions of evaluating the value of a
polynomial for a certain value of $x$. We will be dealing with finding
the point at which these polynomials equal 0.</p>
<p>Polynomial arithmetic is quite simple. The more complex operation is the
division which is not in the scope of this tutorial for now.</p>
<figure>
<img src="poly2.png" alt="poly2" />
</figure>
<p>We can define several polynomials belonging to the same field. For
example, for the $F_2$ field, which only contains $0$ and $1$ as
members, we can generate an infinite number of polynomials without
caring for their degree. That is, the members of the field only populate
the coefficients of the polynomial without caring for the exponents.</p>
<figure>
<img src="poly6.png" alt="poly6" />
</figure>
<p>We can follow the same logic for polynomial arithmetic operations when
the coefficients belong to finite field. We just need to remember the
modular nature of finite fields. As an example, let’s operate with
polynomials whose coefficients belong to the $F_7$ field. You will
notice that we are simply using field arithmetic within the
coefficients.</p>
<p>Addition:</p>
<figure>
<img src="poly3.png" alt="poly3" />
</figure>
<p>Substraction:</p>
<figure>
<img src="poly4.png" alt="poly4" />
</figure>
<p>Multiplication:</p>
<figure>
<img src="poly5.png" alt="poly5" />
</figure>
<p>Again the division case is out of the scope of this tutorial for now.</p>
<p>A polynomial $f(x)$ over a field $F$ is called prime or irreducible if
$f(x)$ cannot be expressed as a product of two polynomials. Both
polynomials have to be part of $F$ and of a lower degree than $f(x)$.
That is, an irreducible polynomial as a polynomial that cannot be
factorized into lower-degree polynomials.</p>
<h1 id="points-lines-and-curves"><a class="header" href="#points-lines-and-curves">Points, Lines, and Curves</a></h1>
<h1 id="algebraic-varieties"><a class="header" href="#algebraic-varieties">Algebraic Varieties</a></h1>
<h1 id="divisors"><a class="header" href="#divisors">Divisors</a></h1>
<h1 id="algebraic-morphisms"><a class="header" href="#algebraic-morphisms">Algebraic Morphisms</a></h1>
<h1 id="sheaves"><a class="header" href="#sheaves">Sheaves</a></h1>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptographic-hash-functions"><a class="header" href="#cryptographic-hash-functions">Cryptographic Hash Functions</a></h1>
<p><em>Hashing</em> is a process that uses an algorithm to take data and convert
it to a fixed length known as a hash value, which varies widely even
with small variations in the input.</p>
<p>Here are two examples using the <code>SHA-256 hash function</code> (one of the most
broadly used hash functions in use today):</p>
<ul>
<li>If the input is <code>&quot;Starknet&quot;</code>, this would be the output:</li>
</ul>
<p><code>a22979efeb74ca6aa02eaf2be8899e65b43dca9788a45ea687a96d970c32d96b</code></p>
<ul>
<li>And if the input is <code>&quot;Starknet.&quot;</code> then the output is:</li>
</ul>
<p><code>78874a2e5dc07ce99d6fb8d71016e7edcb4fda2e64c0642762999baa6b5a0568</code></p>
<p>As you can see, the <strong>difference between the two inputs is only one
point</strong> and the two outputs differ greatly from each other.</p>
<p>Hash functions are designed to protect data integrity and this will be
very important in the <strong>STARK protocol</strong>.</p>
<p>With several data, in collaboration with hashing, we can build <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle
Trees</a> that will allow us to
generate commitments and decommitments in the protocol, guaranteeing
that a determined computation was performed correctly.</p>
<h1 id="asymmetric-encryption"><a class="header" href="#asymmetric-encryption">Asymmetric Encryption</a></h1>
<h1 id="digital-signatures"><a class="header" href="#digital-signatures">Digital Signatures</a></h1>
<h1 id="zero-knowledge-proofs"><a class="header" href="#zero-knowledge-proofs">Zero-Knowledge Proofs</a></h1>
<p>A party (P) executing a computation © on a dataset (D) may have
incentive to misreport the correct output (C(D)), raising the problem of
computational integrity (CI) (also known as delegation of computation,
certified computation, and verifiable computation). That is, ensuring
that P indeed reports C(D) rather than an output more favorable to P.</p>
<p>When the dataset D is public, any party (V) interested in verifying CI
can re-execute C on D and compare its output to that reported by P, as a
customer might inspect a restaurant bill, or as a new Ethereum node will
verify its blockchain. This solution does not scale because the time
spent by the verifier (TV) is as large as the time required to execute
the program (TC) and V must read the full dataset D. Thus, the
computational integrity solution we seek should have scalable
verification.</p>
<p>Additionally, when the dataset D contains confidential data, the
previous solution can no longer be implemented and the party P in charge
of D may conceal violations of computational integrity under the veil of
secrecy.</p>
<p>Zero knowledge (ZK) proof and argument systems are automated protocols
that guarantee computational integrity over confidential data for any
efficient computation, eliminating corruptibility (possibly of auditors)
and reducing costs. A ZK system S for a computation C is a pair of
randomized algorithms, S = (P, V); the prover P is the algorithm used to
prove computational integrity and the verifier V checks such proofs.
Ideally we want the proof to be succinct: the proof should be quicker to
verify than computing it.</p>
<p>The completeness and soundness of S imply that P can efficiently prove
all truisms but will fail to convince V of any falsities (with all but
negligible probability).</p>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<p>Zero Knowledge Proof Systems are proof systems in which there is secret
information known to the <code>prover</code> that is not known to the <code>verifier</code>,
and the verifier is still convinced of the computational claim.</p>
<p>A <code>non-interactive</code> proof system is an abstract machine that models
computation between the two parties(prover and verifier). Messages are
sent in <a href="https://www.youtube.com/watch?v=QJO3ROT-A4E">one direction</a>
until the verifier is convinced of the computational claim.</p>
<p>A <code>succinct</code> proof system is one in which the verifier can run an order
of magnitude faster than a naive re-execution of the program</p>
<p><code>SNARKS</code>: Succinct Non-Interactive Arguments of Knowledge</p>
<p><code>STARKs</code>: Scalable Transparent Arguments of Knowledge</p>
<h2 id="snarks"><a class="header" href="#snarks">SNARKs</a></h2>
<p>SNARK means Succinct Non-interactive Argument of Knowledge. They were
pushed by a 2012 paper from <a href="https://dl.acm.org/doi/10.1145/2090236.2090263">Alessandro Chiesa et.
al.</a>. Alessandro is
Co-Founder and Scientific Advisor at Starkware. SNARKs use elliptic
curves to secure the randomness required for a proof. Elliptic curves
are collision resistant, which means that it is very hard to find two
separate inputs that produce the same output (<a href="https://pseudotheos.mirror.xyz/_LAi4cCFz2gaC-3WgNmri1eTvckA32L7v31A8saJvqg">pseudotheos,
2022</a>).</p>
<p>The main limitations of SNARKs are:</p>
<ol>
<li>
<p>No post-quantum resistance.</p>
</li>
<li>
<p>Initial trust requirements.</p>
</li>
</ol>
<blockquote>
<p><a href="https://vitalik.ca/general/2017/11/09/starks_part_1.html">Vitalik
(2017)</a> -
&quot;What you might not know is that ZK-SNARKs have a newer, shinier
cousin: ZK-STARKs.&quot;</p>
</blockquote>
<p>STARKs were introduced in 2018 in a <a href="https://eprint.iacr.org/2018/046.pdf">paper by Eli Ben-Sasson et.
al.</a>. Eli is Co-Founder of
Starkware. That is right, Starkware was founded by some of the creators
of both SNARKs and STARKs.</p>
<p>The main difference between SNARKs and STARKs is that a STARK uses
collision resistant hash functions instead of elliptic curves. These are
much simpler cryptographic assumptions. STARKs rely purely on hashes and
information theory; meaning that they are secure against attackers with
quantum computers (<a href="https://vitalik.ca/general/2017/11/09/starks_part_1.html">Vitalik,
2017</a>).</p>
<p>What is the downside? Mainly that proof sizes go up from 288 bytes, in
SNARKs case, to a few hundred kilobytes. The tradeoff could be worth it
or not. Authors suggest it could be worth it because it This tradeoff is
worth STARKs allow us to have a much higher effective TPS and throughput
than a SNARK (<a href="https://pseudotheos.mirror.xyz/_LAi4cCFz2gaC-3WgNmri1eTvckA32L7v31A8saJvqg">pseudotheos,
2022</a>),
and if elliptic curves break or when quantum computers come around
(<a href="https://vitalik.ca/general/2017/11/09/starks_part_1.html">Vitalik,
2017</a>).</p>
<p>&quot;With the T standing for &quot;transparent&quot;, ZK-STARKs resolve one of the
primary weaknesses of ZK-SNARKs, its reliance on a 'trusted setup´.&quot;
<a href="https://vitalik.ca/general/2017/11/09/starks_part_1.html">(Vitalik
2017)</a>.</p>
<h1 id="commitment-schemes"><a class="header" href="#commitment-schemes">Commitment Schemes</a></h1>
<h1 id="secure-multi-party-computation-mpc"><a class="header" href="#secure-multi-party-computation-mpc">Secure Multi-Party Computation (MPC)</a></h1>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>The goal of the STARK protocol is to verify computations succinctly and
transparently. It follows three steps:</p>
<ol>
<li>
<p>The first step in a STARK is called <em>arithmetization</em>, and it is the
translation (often referred to as <em><code>reduction</code></em>) of the problem of
verifying a computation to the problem of checking that a certain
polynomial, which can be evaluated efficiently on the verifier’s
side (this is the <em><code>succinctly</code></em> part), is of low degree.
Arithmetization is useful since it enables the use of tools from the
realm of Error Correction Codes that efficiently test low
degree-ness.</p>
</li>
<li>
<p>However, arithmetization itself only translates a Computational
Integrity statement into a polynomial, setting the scene for the
next phase in STARK, which is another interactive protocol that
involves a prover that attempts to convince a verifier that the
polynomial is indeed of low degree. The verifier is convinced that
the polynomial is of low degree if and only if the original
computation is correct (except for an infinitesimally small
probability).</p>
</li>
<li>
<p>In the last step of STARK, the interactive protocol is transformed
into a single non-interactive proof, that can be posted to a
blockchain and publicly verified by anyone.</p>
</li>
</ol>
<p>Arithmetization itself is composed of two steps. The first is generating
an execution trace and polynomial constraints, the second is
transforming these two objects into a single low-degree polynomial. In
terms of prover-verifier interaction, what really goes on is that the
prover and the verifier agree on what the polynomial constraints are in
advance. The prover then generates an execution trace, and in the
subsequent interaction, the prover tries to convince the verifier that
the polynomial constraints are satisfied over this execution trace,
unseen by the verifier. Let’s review each step.</p>
<h1 id="step-1-generating-an-execution-trace-and-a-set-of-polynomial-constraints"><a class="header" href="#step-1-generating-an-execution-trace-and-a-set-of-polynomial-constraints">Step 1: Generating an execution trace and a set of polynomial constraints</a></h1>
<p>The first step takes some CI statement (such as
&quot;<code>the fifth transaction in block 7218290 is correct</code>&quot;), and translate it
into formal algebraic language. This serves two purposes: 1) it defines
the claim succinctly in an unambiguous way, and 2) it embeds the claim
in an algebraic domain. This embedding is what allows the second step of
arithmetization, which reduces the CI statement to a claim about the
degree of a specific polynomial.</p>
<p>The algebraic representation that we use has two main components: 1) an
execution trace, and 2) a set of polynomial constraints. The execution
trace is a table that represents the steps of the underlying
computation, where each row represents a single step. The set of
polynomial constraints is constructed such that all of them are
satisfied if and only if the trace represents a valid computation. While
the execution trace may be very long, we will work with a succinct set
of polynomial constraints.</p>
<p>The type of execution trace that we’re looking to generate must have the
special trait of being succinctly testable — each row can be verified
relying only on rows that are close to it in the trace, and the same
verification procedure is applied to each pair of rows. This trait
directly affects the size of the proof. To exemplify what we mean by
being succinctly testable, let’s go back to the supermarket receipt, and
add another column for the running total:</p>
<figure>
<img src="receipt2.png" alt="receipt2" />
</figure>
<p>This simple addition allows us to verify each row individually, given
its previous row.</p>
<p>We can, for example, examine these two rows:</p>
<figure>
<img src="receipt3.png" alt="receipt3" />
</figure>
<p>We would be convinced that this particular step of the computation (i.e.
the number 16.41) is correct since 12.96+3.45=16.41. Notice that the
same constraint is applied to each pair of rows. This is what we mean by
succinct constraints.</p>
<p>Let’s proceed with the polynomial constraints. We rewrite the
supermarket receipt (with the running total) in the form of a table:</p>
<figure>
<img src="receipt4.png" alt="receipt4" />
</figure>
<p>Denote the value of the cell in the $i$-th row and $j$-th column by
$A_{i,j}$. We can now rephrase the correctness conditions as this set
of polynomial constraints:</p>
<figure>
<img src="constraints.png" alt="constraints" />
</figure>
<p>These are linear polynomial constraints in Ai,j. If the set of
polynomial constraints we use are of high degree, this has an adverse
effect on the proof length and the time it takes to generate it.
Consequently, linear constraints are the best we can hope for. Notice
that (2) is really a single constraint applied multiple times, and the
whole size of the set is independent of the length of the receipt.</p>
<p>In sum, we took a CI problem of verifying a supermarket receipt, and
transformed it into a succinctly testable execution trace, and a
corresponding set of polynomial constraints that hold if and only if the
total sum in the original receipt is correct.</p>
<p>Let’s see a more complex example: the Collatz Conjecture.</p>
<p>In 1937, a German mathematician named Lothar Collatz presented a
conjecture in the field of number theory. At first glance this
conjecture might seem merely a cute math puzzle, but in fact it is a
hard open problem in number theory. It caught the attention of many
mathematicians over the years, and acquired a lot of synonyms (e.g., the
$3n + 1$ conjecture, the Ulam conjecture, Kakutani’s problem and many
more). Paul Erdős once said about this conjecture:
&quot;<code>Mathematics may not be ready for such problems</code>&quot;.</p>
<p>A Collatz sequence starts with any positive integer, where each
subsequent element in the sequence is obtained from the previous one as
follows:</p>
<p>If the previous element is even: divide it by 2. If the previous element
is odd and greater than 1: multiply it by 3 and add 1. If the previous
element is 1, stop. Let’s consider a simple example where the initial
term is 52:</p>
<p>$52 -&gt; 26 -&gt; 13 -&gt; 40 -&gt; 20 -&gt; 10 -&gt; 5 -&gt; 16 -&gt;
8 -&gt; 4 -&gt; 2 -&gt; 1$.</p>
<p><strong>Collatz Conjecture</strong>: for any positive integer we start with, the
sequence always reaches 1.</p>
<p>Unfortunately, resolving the Collatz Conjecture is beyond the scope of
this tutorial. Instead, we will consider the problem of verifying a
computation that checks the conjecture for a particular starting
integer.</p>
<p>The Collatz Sequence Execution Trace The CI statement is:
&quot;<code>A Collatz sequence that starts with 52, ends with 1 after 11 iterations</code>&quot;.</p>
<p>Let A be the execution trace of the sequence’s computation. The i-th
row, denoted by Ai, represents the i-th number in the sequence. All
numbers are represented as binary strings, to make it easier to express
the odd/even condition with polynomials. Ai,j equals to the j-th least
significant bit of the i-th number of the sequence. For example,
A0=001011: the first term is 52, its binary representation is 110100 and
then we reverse the bits`' order (bit reversal order simplifies
indexing in the polynomial constraints notation).</p>
<p>Here is the execution trace of the above Collatz sequence that starts
with 52:</p>
<figure>
<img src="collatz.png" alt="collatz" />
</figure>
<p>Note that here the trace has 6 columns because 6 bits are enough to
represent even the largest number in the sequence. Had we started the
sequence with 51, the next number would have been 154, so the trace of
such a sequence would have required at least 8 columns.</p>
<p>Recall that the polynomial constraints we are looking for are such that
all of them are satisfied if and only if the trace A describes the given
Collatz sequence (starting with 52, ending with 1, and the transition
from any two consecutive rows is done correctly). In our example, the
trace A is of size 6x12, i.e., it represents a Collatz sequence of 12
6-bit numbers. The set of polynomial constraints are the following
($n=12$, $m=6$):</p>
<figure>
<img src="collatz2.png" alt="collatz2" />
</figure>
<p>Let’s go over each of the constraints. The first three are
straightforward:</p>
<ol>
<li>
<p>holds if and only if the first row is a binary representation of 52.</p>
</li>
<li>
<p>holds if and only if the last row is a binary representation of 1.</p>
</li>
<li>
<p>holds if and only if the trace contains only bits (a number is equal
to its square if and only if it is either 0 or 1).</p>
</li>
</ol>
<p>The fourth set of constraints defines the heart of the succinct
computation of the sequence, i.e., the connection between every two
consecutive rows. The ability to express computational constraints as a
recurring pattern of local constraints (i.e. succinctness), is
fundamental to the verifier being exponentially faster than a naive
replay of the computation.</p>
<p>Let’s examine the constraints themselves carefully.</p>
<p>For any $i&lt;n-1$, denote:</p>
<figure>
<img src="collatz3.png" alt="collatz3" />
</figure>
<p>Hence, for each $i&lt;n-1$, we get the following constraint:</p>
<figure>
<img src="collatz4.png" alt="collatz4" />
</figure>
<p>$A_{i,0}$ is the least significant bit of the $i$-th number, which
determines its parity as an integer, so this constraint describes the
Collatz sequence rule.</p>
<p>To sum up, all constraints are satisfied if and only if the trace
represents a valid computation of a Collatz sequence.</p>
<p>Note that any Collatz sequence of length n, can be represented using a
trace of size n*m where m is the maximum number of bits in the
representation of a number in the sequence, and the corresponding
polynomial constraints are modified accordingly. Note that the
polynomial constraints do not grow with n and m, but remain simple and
concise.</p>
<p>Given a specific first term for a Collatz sequence, a simple computer
program can output the execution trace and the polynomial constraints.
We have seen how a CI statement about a Collatz sequence can be
transformed into an execution trace and a succinctly-described set of
polynomial constraints. Similar methods can be used to transform any
computation, and in general, any CI statement can be translated into
this form.</p>
<p>The details, however, matter a great deal. While there are many ways in
which an execution trace (and a set of polynomial constraints) may
describe a specific computation, only a handful of them result in a
small STARK proof which can be constructed efficiently. Much of the
effort in Starkware is devoted to designing reductions that lead to good
polynomial constraints, which we call AIR (Algebraic Intermediate
Representation), as much of the performance of our systems depends on
it.</p>
<h1 id="step-2-transform-the-execution-trace-and-the-set-of-polynomial-constraints-into-a-single-low-degree-polynomial"><a class="header" href="#step-2-transform-the-execution-trace-and-the-set-of-polynomial-constraints-into-a-single-low-degree-polynomial">Step 2: Transform the execution trace and the set of polynomial constraints into a single low-degree polynomial</a></h1>
<p>Using a Fibonacci sequence, we will show how the prover can combine the
execution trace and the polynomial constraints to obtain a polynomial
that is guaranteed to be of low degree if and only if the execution
trace satisfies the polynomial constraints that we started with.
Moreover, we will show how the domain over which the polynomial is
considered allows the verifier to evaluate it succinctly. We also
briefly discuss how error correction codes play a role in STARKs.</p>
<p>Recall that our goal is to make it possible for a verifier to ask a
prover a very small number of questions, and decide whether to accept or
reject the proof with a guaranteed high level of accuracy. Ideally, the
verifier would like to ask the prover to provide the values in a few
(random) places in the execution trace, and check that the polynomial
constraints hold for these places. A correct execution trace will
naturally pass this test. However, it is not hard to construct a
completely wrong execution trace, that violates the constraints only at
a single place, and, doing so, reach a completely far and different
outcome. Identifying this fault via a small number of random queries is
highly improbable.</p>
<p>Common techniques that address similar problems are <a href="https://en.wikipedia.org/wiki/Error_detection_and_correction"><strong>Error Correction
Codes</strong></a>.</p>
<p>Error Correction Codes transform a set of strings, some of which may be
very similar to one another, into a set of strings that are pairwise
very different, by replacing the original strings with longer strings.</p>
<p>Interestingly, polynomials can be used to construct good error
correction codes, since two polynomials of degree d, evaluated on a
domain that is considerably larger than $d$, are different almost
everywhere (to see this, notice that the difference between distinct
degree-$d$ polynomials is a non-zero polynomial of degree $d$, hence has
at most $d$ zeros). Such codes are called <strong>Reed-Solomon</strong> codes.</p>
<p>Observing that, we can extend the execution trace by thinking of it as
an evaluation of a polynomial on some domain, and evaluating this same
polynomial on a much larger domain. Extending in a similar fashion an
incorrect execution trace, results in a vastly different string, which
in turn makes it possible for the verifier to distinguish between these
cases using a small number of queries.</p>
<p>Our plan is therefore to 1) rephrase the execution trace as a
polynomial, 2) extend it to a large domain, and 3) transform that, using
the polynomial constraints, into yet another polynomial that is
guaranteed to be of low degree if and only if the execution trace is
valid.</p>
<p><strong>Toy Example: Boolean Execution Trace</strong></p>
<p>Suppose that the CI statement in question is
&quot;<code>The prover has a sequence of 512 numbers, all of which are either 0 or 1</code>&quot;,
which we would like to verify by reading substantially less than 512
numbers. Let’s see what kind of execution trace and polynomial
constraints express this toy example:</p>
<ol>
<li>
<p>The execution trace has $512$ rows, each row containing a single
cell with either zero or one in it.</p>
</li>
<li>
<p>The polynomial constraint we use here is simply
$A_\ᵢ}⋅A_\ᵢ}-A_\ᵢ}=0$, where $A_\ᵢ}$ denotes the $i$-th cell
in this single-column execution trace (a number is equal to its
square if and only if it is either 0 or 1).</p>
</li>
</ol>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>G</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>=512$, and some generator $g$ of $G$.
The existence of such a subgroup is guaranteed since $512$ divides the
size of this group (which is $96768$).</p></td>
</tr>
</tbody>
</table>
<p>We now think of the elements in the execution trace as evaluations of
some polynomial f(x) of degree less than 512 in the following way: the
i-th cell contains the evaluation of f on the generator’s i-th power.</p>
<p>Formally:</p>
<figure>
<img src="generator.png" alt="generator" />
</figure>
<p>Such a polynomial of degree at most 512 can be computed by
interpolation, and we then proceed to evaluate it on a much larger
domain (choosing this domain’s size directly translates into the
soundness error, the bigger it is — the smaller the soundness error),
forming a special case of Reed-Solomon codeword.</p>
<p>Lastly, we use this polynomial to create another one, whose low
degreeness depends on the constraint being satisfied over the execution
trace.</p>
<p>To do so, we must go on a tangent and discuss roots of polynomials.</p>
<p>A basic fact about polynomials and their roots is that if $p(x)$ is a
polynomial, then $p(a)=0$ for some specific value $a$, if and only if
there exists a polynomial $q(x)$ such that $(x-a)q(x)=p(x)$, and
$deg(p)=deg(q)+1$.</p>
<p>Moreover, for all $x≠a$, we can evaluate $q(x)$ by computing:</p>
<figure>
<img src="root.png" alt="root" />
</figure>
<p>By induction, a similar fact is true for $k$ roots. Namely, if $a_\ᵢ}$
is a root of p for all $i=0..k-1$, then there exists a polynomial $q$ of
degree $deg(p)-k$, and in all but these $k$ values, it is exactly equal
to:</p>
<figure>
<img src="kroots.png" alt="kroots" />
</figure>
<p>Rephrasing the polynomial constraint in terms of f yields the following
polynomial:</p>
<figure>
<img src="polConstraint.png" alt="polConstraint" />
</figure>
<p>We have defined $f$ such that the roots of this expression are $1$, $g$,
$g²$, $…$, $g⁵¹¹$ if and only if the cells in the execution trace are
$0$ or $1$. We can define:</p>
<figure>
<img src="polConstraint2.png" alt="polConstraint2" />
</figure>
<p>If there exists a protocol by which the prover can convince (such that
the verifier is convinced if and only if the prover is not cheating) the
verifier that this polynomial is of low degree, such that in it the
verifier only asks for values outside the execution trace, then indeed
the verifier will be convinced about the truthfulness of the CI
statement only when it is true. In fact, in the next post, we will show
a protocol that does exactly that, with some very small probability of
error. For the time being — let’s take a look at another example, that
is still simple, but not completely trivial, and see how the reduction
works in that case.</p>
<p><strong>Not so trivial example: Fibonacci</strong></p>
<figure>
<img src="fibonacci1.png" alt="fibonacci1" />
</figure>
<p>We can create an execution trace for this CI statement by simply writing
down all 512 numbers:</p>
<figure>
<img src="fibonacci2.png" alt="fibonacci2" />
</figure>
<p>The polynomial constraints that we use are</p>
<figure>
<img src="fibonacci3.png" alt="fibonacci3" />
</figure>
<p>Now we translate into Polynomials.</p>
<p>Here, too, we define a polynomial $f(x)$ of degree at most $512$, such
that the elements in the execution trace are evaluations of $f$ in
powers of some generator $g$.</p>
<p>Formally:</p>
<figure>
<img src="fibonacci4.png" alt="fibonacci4" />
</figure>
<p>Expressing the polynomial constraints in terms of $f$ instead of $A$, we
get:</p>
<figure>
<img src="fibonacci5.png" alt="fibonacci5" />
</figure>
<p>Since a composition of polynomials is still a polynomial — substituting
the $Aᵢ$ in the constraints with $f(gⁱ)$ still means these are
polynomial constraints.</p>
<p>Note that 1, 2, and 4 are constraints that refer to a single value of
$f$, we refer to them as boundary constraints.</p>
<p>The Fibonacci recurrence relation, in contrast, embodies a set of
constraints over the entire execution trace, and it may be alternatively
rephrased as:</p>
<figure>
<img src="fibonacci6.png" alt="fibonacci6" />
</figure>
<p>The use of a generator to index the rows of the execution trace allows
us to encode the notion of &quot;<code>next row</code>&quot; as a simple algebraic relation.
If x is some row in the execution trace, then $gx$ is the next row,
$g²x$ is the row after that, $g⁻¹x$ is the previous row and so on.</p>
<p>The recurrence relation polynomial: $f(g²x)-f(gx)-f(x)$ is zero for
every $x$ that indexes a row in the execution trace, except for the last
two. It means that 1, $g$, $g²$, $…$, $g⁵⁰⁹$ are all roots of this
recurrence relation polynomial (and it is of degree at most 510), so we
can construct $q(x)$ as follows:</p>
<figure>
<img src="fibonacci7.png" alt="fibonacci7" />
</figure>
<p>In STARK lore, this is often referred to as the composition polynomial.
Indeed, when the original execution trace obeys the Fibonacci recurrence
relation, this expression agrees with some polynomial whose degree is at
most 2 (recall that the degree of f is at most 512) on all but these 510
values: 1, $g$, $g²$, $…$, $g⁵⁰⁹$. However, the term composition
polynomial is somewhat misleading, as when the execution trace does not
satisfy the polynomial constraint — the evaluations of this expression
differ from any low degree polynomial in many places. In other
words — it is close to a low-degree polynomial if and only if the
original CI is correct, which indeed was our goal.</p>
<p>This concludes the promised reduction, that translates the problem of
checking whether certain polynomial constraints are satisfied over some
execution trace, to the problem of checking whether some polynomial
(known to the prover) is of low degree.</p>
<p>Succinctness</p>
<p>Having a very efficient verification technique is key to STARKs, and it
can be seen as comprised of two parts — using a small number of queries,
and having the verifier perform a small computation on each query. The
former is achieved by error correction codes, which allow querying in
very few places, and the latter we have sort of swept under the rug
throughout this post, until now. The verifier’s work can be summed up
as 1) querying the composition polynomial in random places, and 2)
checking low-degreeness based on these queries. Low degreeness succinct
checking will be handled in the next post, but what exactly do we mean
by &quot;<code>querying the composition polynomial</code>&quot;? The avid reader may have
been suspicious of this expression, and rightfully so. The prover, after
all, may be malicious. When the verifier asks for the evaluation of the
composition polynomial at some x, the prover may reply with the
evaluation of some truly low-degree polynomial, that will pass any
low-degree testing, but is not the composition polynomial.</p>
<p>To prevent this, the verifier explicitly queries the Fibonacci execution
trace at some row w by asking for the values of $f$ in three places:
$f(w)$, $f(gw)$, $f(g²w)$.</p>
<p>The verifier can now compute the value of the composition polynomial at
w by:</p>
<figure>
<img src="succinctness.png" alt="succintness" />
</figure>
<p>Where the numerator can be computed using the values obtained from the
prover, and the denominator… well, there’s the rub (that was swept under
the rug).</p>
<p>On the one hand the denominator is completely independent of the
execution trace, so the verifier can compute it before ever
communicating with the prover.</p>
<p>On the other hand, in practicality — the trace may be comprised of
hundreds of thousands of rows, and computing the denominator would cost
the verifier dearly in running time.</p>
<p>Here’s where the arithmetization is crucial to succinctness — since
calculating this expression for the special case where the powers of g
form a subgroup can be done very efficiently if one notices that:</p>
<figure>
<img src="succinctness2.png" alt="succinctness2" />
</figure>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>This equality is true because both
sides are polynomials of degree $</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>G</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>$ whose roots are exactly the elements
of $G$.</p></td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Computing the right hand side of this
equation seems to require a number of operations that is linear in
$</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>G</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>$. However, if we resort to <a
href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring">exponentiation
by squaring</a>, the left hand side of this equation can be computed in
running time that is logarithmic in $</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>G</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>$.</p></td>
</tr>
</tbody>
</table>
<p>And the actual denominator of the Fibonacci composition polynomial in
question can be obtained by rewriting it as:</p>
<figure>
<img src="succinctness3.png" alt="succinctness3" />
</figure>
<p>This seeming technicality stands at the core of the verifier being able
to run in polylogarithmic time, and it is enabled only because we view
the execution trace as evaluations of a polynomial over some subgroup of
the field, and that the polynomial constraints in question hold over a
subgroup.</p>
<p>Similar tricks can be applied for more sophisticated execution traces,
but it is crucial that the repeating pattern of the constraint coincides
with some subgroup of the field.</p>
<p>More Constraints, More Columns!</p>
<p>The examples in this post were deliberately simple, to highlight key
aspects of arithmetization. A natural question that arises will be: how
is the case of multiple columns and multiple constraints handled. The
answer is straightforward: multiple columns simply mean that there’s
more than one polynomial to work with, and multiple composition
polynomials — resulting from the multiple constraints — are combined
into a single polynomial, a random linear combination of all of them,
for the sake of the last phase in STARK, which is a low degree test.
With high probability, the linear combination is of low degree if and
only if so are all of its components.</p>
<p>We have shown how, given an execution trace and constraint polynomials,
the prover can construct a polynomial which is of low degree if and only
if the original CI statement holds. Furthermore, we have shown how the
verifier can query the values of this polynomial efficiently, making
sure that the prover did not replace the true polynomial with some false
low-degree one.</p>
<p>Next we will go into the details of low-degree testing, showing how this
magic, of querying a small number of values and determining whether some
polynomial is of low degree, is done.</p>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>The process of Arithmetization enabled us to reduce the CI problem to a
low degree testing problem. Low degree testing refers to the problem of
deciding whether a given function is a polynomial of some bounded
degree, by making only a small number of queries to the function. Low
degree testing has been studied for more than two decades, and is a
central tool in the theory of probabilistic proofs. The goal of this
blog post is to explain low degree testing in more detail, and to
describe FRI, the protocol that we use for low degree testing in STARK.
This post assumes familiarity with polynomials over finite fields.</p>
<p>Before we discuss low-degree testing, we first present a slightly
simpler problem as a warm-up: We are given a function and are asked to
decide whether this function is equal to some polynomial of degree less
than some constant d, by querying the function at a &quot;<code>small</code>&quot; number of
locations. Formally, given a subset L of a field F and a degree bound d,
we wish to determine if $f:L➝F$ is equal to a polynomial of degree less
than $d$, namely, if there exists a polynomial</p>
<figure>
<img src="low1.png" alt="low1" />
</figure>
<p>over $F$ for which $p(a) = f(a)$ for every $a$ in $L$. For concrete
values, you may think of a field of size which is very large, say
$2¹²⁸$, and $L$ which is of size approximately 10,000,000.</p>
<p>Solving this problem requires querying $f$ at the entire domain $L$, as
f might agree with a polynomial everywhere in $L$ except for a single
location. Even if we allow a constant probability of error, the number
of queries will still be linear in the size of $L$.</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>For this reason, the problem of low
degree testing actually refers to an approximate relaxation of the above
problem, which suffices for constructing probabilistic proofs and also
can be solved with a number of queries which is logarithmic in
$</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>L</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>$ (note that if $L≈10,000,000$, then
$log₂(L)≈23)$. In more detail, we wish to distinguish between the
following two cases.</p></td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><strong>The function $f$ is equal to a low degree polynomial</strong>. Namely,
there exists a polynomial $p(x)$ over $F$, of degree less than $d$,
that agrees with $f$ everywhere on $L$.</p>
</li>
<li>
<p><strong>The function $f$ is far from ALL low degree polynomials</strong>. For
example, we need to modify at least 10% of the values of $f$ before
we obtain a function that agrees with a polynomial of degree less
than $d$.</p>
</li>
</ul>
<p>Note that there is another possibility — the function $f$ may be mildly
close to a low degree polynomial, yet not equal to one. For example, a
function in which $5%$ of the values differ from a low-degree polynomial
does not fall in either of the two cases described above. However, the
prior arithmetization step (discussed in our previous posts) ensures the
third case never arises. In more detail, arithmetization shows that an
honest prover dealing with a true statement will land in the first case,
whereas a (possibly malicious) prover attempting to &quot;<code>prove</code>&quot; a false
claim will land, with high probability, in the second case.</p>
<p>In order to distinguish the two cases, we will use a probabilistic
polynomial-time test that queries f at a small number of locations (we
discuss what &quot;<code>small</code>&quot; means later).</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>This paragraph is optional for
understanding the big picture. If $f$ is indeed low degree, then the
test should accept with probability 1. If instead f is far from low
degree, then the test should reject with high probability. More
generally, we seek the guarantee that if f is $δ-far$ from any function
of degree less than d (i.e., one must modify at least $δ</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>L</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>$ locations to obtain a polynomial of
degree less than d), then the test rejects with probability at least
$Ω(δ)$ (or some other "<code>nice</code>" function of $δ$). Intuitively,
the closer $δ$ is to zero, the more difficult it is to distinguish
between the two cases.</p></td>
</tr>
</tbody>
</table>
<p>In the next few sections we describe a simple test, then explain why it
does not suffice in our setting, and finally we describe a more complex
test that is exponentially more efficient. This latter test is the one
that we use in STARK.</p>
<h1 id="the-direct-test"><a class="header" href="#the-direct-test">The Direct Test</a></h1>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>The first test we consider is a simple
one: it tests whether a function is (close to) a polynomial of degree
less than $d$, using $d+1$ queries. The test relies on a basic fact
about polynomials: any polynomial of degree less than d is fully
determined by its values at any d distinct locations of $F$. This fact
is a direct consequence of the fact that a polynomial of degree $k$ can
have at most $k$ roots in $F$. Importantly, the number of queries, which
is $d+1$, can be significantly less than the size of the domain of $f$,
which is $</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>L</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>$.</p></td>
</tr>
</tbody>
</table>
<p>We first discuss two simple special cases, to build intuition for how
the test will work in the general case.</p>
<ul>
<li>
<p><strong>The case of a constant function $(d=1)$.</strong> This corresponds to the
problem of distinguishing between the case where $f$ is a constant
function ($f(x)=c$ for some $c$ in $F$), and the case where $f$ is
far from any constant function. In this special case there is a
natural 2-query test that might work: query $f$ at a fixed location
$z1$ and also at a random location $w$, and then check that
$f(z1)=f(w)$. Intuitively, $f(z1)$ determines the (alleged) constant
value of $f$, and $f(w)$ tests whether all of $f$ is close to this
constant value or not.</p>
</li>
<li>
<p><strong>The case of a linear function $(d=2)$.</strong> This corresponds to the
problem of distinguishing between the case where $f$ is a linear
function ($f(x)=ax+b$ for some $a$,$b$ in $F$), and the case where
$f$ is far from any linear function. In this special case there is a
natural 3-query test that might work: query f at two fixed locations
z1,z2 and also at a random location $w$, and then check that
($z1$,$f(z1)$), ($z2$,$f(z2)$), ($w$,$f(w)$) are collinear, namely,
we can draw a line through these points. Intuitively, the values of
$f(z1)$ and $f(z2)$ determine the (alleged) line, and $f(w)$ tests
whether all of $f$ is close to this line or not.</p>
</li>
</ul>
<p>The above special cases suggest a test for the general case of a degree
bound $d$. Query $f$ at $d$ fixed locations $z1$,$z2$,$…$,$zd$ and also
at a random location $w$. The values of $f$ at $z0$,$z1$,$…$,$zd$ define
a unique polynomial $h(x)$ of degree less than $d$ over $F$ that agrees
with $f$ at these points. The test then checks that $h(w)=f(w)$. We call
this the direct test.</p>
<p>By definition, if $f(x)$ is equal to a polynomial $p(x)$ of degree less
than $d$, then $h(x)$ will be identical to $p(x)$ and thus the direct
test passes with probability 1. This property is called
&quot;<code>perfect completeness</code>&quot;, and it means that this test has only 1-sided
error.</p>
<p>We are left to argue what happens if $f$ is $δ$-far from any function of
degree less than $d$. (For example, think of $δ=10%$.) We now argue
that, in this case, the direct test rejects with probability at least δ.
Indeed, let 𝞵 be the probability, over a random choice of w, that
$h(w)≠f(w)$. Observe that $𝞵$ must be at least δ. Optional: This is
because if we assume towards contradiction that 𝞵 is smaller than δ,
then we deduce that f is δ-close to h, which contradicts our assumption
that f is δ-far from any function of degree less than d.</p>
<h1 id="the-direct-test-does-not-suffice-for-us"><a class="header" href="#the-direct-test-does-not-suffice-for-us">The Direct Test Does Not Suffice For Us</a></h1>
<p>In our setting we are interested in testing functions f:L➝F that encode
computation traces, and hence whose degree d (and domain L) are quite
large. Merely running the direct test, which makes d+1 queries, would be
too expensive. In order to gain the exponential savings of STARK (in
verification time compared to the size of the computation trace), we
need to solve this problem with only O(log d) queries, which is
exponentially less than the degree bound d.</p>
<p>This, unfortunately, is impossible because if we query f at less than
d+1 locations then we cannot conclude anything.</p>
<p>Optional: One way to see this is to consider two different distributions
of functions f:L➝F. In one distribution we uniformly pick a polynomial
of degree exactly d and evaluate it on L. In the other distribution we
uniformly pick a polynomial of degree less than d and evaluate it on L.
In both cases, for any d locations z1,z2,…,zd, the values
f(z1),f(z2),…,f(zd) are uniformly and independently distributed. (We
leave this fact as an exercise for the reader.) This implies that
information-theoretically we cannot tell these two cases apart, even
though a test would be required to (since polynomials from the first
distribution should be accepted by the test while those of degree
exactly d are very far from all polynomials of degree less than d, and
thus should be rejected).</p>
<p>We seem to have a difficult challenge to overcome.</p>
<h1 id="a-prover-comes-to-the-rescue"><a class="header" href="#a-prover-comes-to-the-rescue">A Prover Comes to the Rescue</a></h1>
<p>We have seen that we need d+1 queries to test that a function f:L➝F is
close to a polynomial of degree less than d, but we cannot afford this
many queries. We avoid this limitation by considering a slightly
different setting, which suffices for us. Namely, we consider the
problem of low degree testing when a prover is available to supply
useful auxiliary information about the function f. We will see that in
this &quot;<code>prover-aided</code>&quot; setting of low-degree testing we can achieve an
exponential improvement in the number of queries, to O(log d).</p>
<p>In more detail, we consider a protocol conducted between a prover and a
verifier, wherein the (untrusted) prover tries to convince the verifier
that the function is of low degree. On the one hand, the prover knows
the entire function f being tested. On the other hand, the verifier can
query the function f at a small number of locations, and is willing to
receive help from the prover, but does NOT trust the prover to be
honest. This means that the prover may cheat and not follow the
protocol. However, if the prover does cheat, the verifier has the
liberty to &quot;<code>reject</code>&quot;, regardless of whether the function f is of low
degree or not. The important point here is that the verifier will not be
convinced that f is of low degree unless this is true.</p>
<p>Note that the direct test described above is simply the special case of
a protocol in which the prover does nothing, and the verifier tests the
function unassisted. To do better than the direct test we will need to
leverage the help of the prover in some meaningful way.</p>
<p>Throughout the protocol the prover will want to enable the verifier to
query auxiliary functions on locations of the verifier’s choice. This
can be achieved via commitments, a mechanism that we will discuss in a
future blog post. For now it suffices to say that the prover can commit
to a function of its choice via a Merkle tree, and subsequently the
verifier can request the prover to reveal any set of locations of the
committed function. The main property of this commitment mechanism is
that once the prover commits to a function, it must reveal the correct
values and cannot cheat (for example, it cannot decide what the values
of the function are after seeing the requests from the verifier).</p>
<h1 id="halving-the-number-of-queries-for-the-case-of-two-polynomials"><a class="header" href="#halving-the-number-of-queries-for-the-case-of-two-polynomials">Halving the number of queries for the case of two polynomials</a></h1>
<p>Let’s start with a simple example that illustrates how a prover can help
to reduce the number of queries by a factor of 2. We will later build on
this example. Suppose that we have two polynomials f and g and we want
to test that they are both of degree less than d. If we simply run the
direct test individually on f and g then we would need to make 2 *
(d + 1) queries. Below we describe how with the help of a prover we can
reduce the number of queries to (d + 1) plus a smaller-order term.</p>
<p>First, the verifier samples a random value 𝛼 from the field and sends it
to the prover. Next, the prover replies by committing to the evaluation
on the domain L (recall that L is the domain of the function f) of the
polynomial h(x) = f(x) + 𝛼 g(x) (in other words, the prover will compute
and send the root of a Merkle tree whose leaves are the values of h on
L). The verifier now tests that h has degree less than d, via the direct
test, which requires d+1 queries.</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Intuitively, if f or g has degree at
least d, then with high probability so does h. For example, consider the
case where the coefficient of xⁿ in f is not zero for some n≥d. Then,
there is at most one choice of 𝛼 (sent by the verifier) for which the
coefficient of xⁿ in h is zero, which means that the probability that h
has degree less than d is roughly 1/</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>F</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>. If the field is large enough
(say,</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>F</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>&gt;2¹²⁸), the probability of error is
negligible.</p></td>
</tr>
</tbody>
</table>
<p>The situation, however, is not this simple. The reason is that, as we
explained, we cannot literally check that h is a polynomial of degree
less than d. Instead we only can check that h is close to such a
polynomial. This means that the analysis above is not accurate. Is it
possible that f will be far from a low degree polynomial and the linear
combination h will be close to one with a non-negligible probability
over 𝛼? Under mild conditions the answer is no (which is what we want),
but it is outside the scope for this post; we refer the interested
reader to <a href="https://acmccs.github.io/papers/p2087-amesA.pdf">this paper</a>
and <a href="https://eccc.weizmann.ac.il/report/2017/134/">this paper</a>.</p>
<p>Moreover, how does the verifier know that the polynomial h sent by the
prover has the form f(x)+𝛼 g(x)? A malicious prover may cheat by sending
a polynomial which is indeed of low degree, but is different from the
linear combination that the verifier asked for. If we already know that
h is close to a low degree polynomial, then testing that this low degree
polynomial has the correct form is straightforward: the verifier samples
a location z in L at random, queries f, g, h at z, and checks that the
equation h(z)=f(z)+𝛼 g(z) holds. This test should be repeated multiple
times to increase accuracy of the test, but the error shrinks
exponentially with the number of samples we make. Hence this step
increases the number of queries (which so far was d+1) only by a
smaller-order term.</p>
<h1 id="splitting-a-polynomial-into-two-smaller-degree-polynomials"><a class="header" href="#splitting-a-polynomial-into-two-smaller-degree-polynomials">Splitting a polynomial into two smaller-degree polynomials</a></h1>
<p>We saw that, with the prover’s help, we can test that two polynomials
are of degree less than d with less than 2*(d+1) queries. We now
describe how we can turn one polynomial of degree less than d into two
polynomials of degree less than d/2.</p>
<p>Let f(x) be a polynomial of degree less than d and assume that d is even
(in our setting this comes without loss of generality). We can write
f(x)=g(x²)+xh(x²) for two polynomials g(x) and h(x) of degree less than
d/2. Indeed, we can let g(x) be the polynomial obtained from the even
coefficients of f(x), and h(x) be the polynomial obtained from the odd
coefficients of f(x). For example, if d=6 we can write</p>
<figure>
<img src="smallerPol1.png" alt="smallerPol1" />
</figure>
<p>which means that</p>
<figure>
<img src="smallerPol2.png" alt="smallerPol2" />
</figure>
<p>and</p>
<figure>
<img src="smallerPol3.png" alt="smallerPol3" />
</figure>
<p>which is an n*log(n) algorithm for polynomial evaluation (improving
over the naive n2 algorithm).</p>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>We now combine the two above ideas (testing two polynomials with half
the queries, and splitting a polynomial into two smaller ones) into a
protocol that only uses O(log d) queries to test that a function f has
(more precisely, is close to a function of) degree less than d. This
protocol is known as FRI (which stands for Fast Reed — Solomon
Interactive Oracle Proof of Proximity), and the interested reader can
read more about it <a href="https://eccc.weizmann.ac.il/report/2017/134/">here</a>.
For simplicity, below we assume that d is a power of 2. The protocol
consists of two phases: a commit phase and a query phase.</p>
<h1 id="commit-phase"><a class="header" href="#commit-phase">Commit phase</a></h1>
<p>The prover splits the original polynomial f₀(x)=f(x) into two
polynomials of degree less than d/2, g₀(x) and h₀(x), satisfying
f₀(x)=g₀(x²)+xh₀(x²). The verifier samples a random value 𝛼₀, sends it
to the prover, and asks the prover to commit to the polynomial
f₁(x)=g₀(x) + 𝛼₀h₀(x). Note that f₁(x) is of degree less than d/2.</p>
<p>We can continue recursively by splitting f₁(x) into g₁(x) and h₁(x),
then choosing a value 𝛼₁, constructing f₂(x) and so on. Each time, the
degree of the polynomial is halved. Hence, after log(d) steps we are
left with a constant polynomial, and the prover can simply send the
constant value to the verifier.</p>
<h1 id="query-phase"><a class="header" href="#query-phase">Query phase</a></h1>
<p>We now have to check that the prover did not cheat. The verifier samples
a random z in L and queries f₀(z) and f₀(-z). These two values suffice
to determine the values of g₀(z²) and h₀(z²), as can be seen by the
following two linear equations in the two &quot;<code>variables</code>&quot; g₀(z²) and
h₀(z²):</p>
<figure>
<img src="query1.png" alt="query1" />
</figure>
<p>The verifier can solve this system of equations and deduce the values of
g₀(z²) and h₀(z²). It follows that it can compute the value of f₁(z²)
which is a linear combination of the two. Now the verifier queries
f₁(z²) and makes sure that it is equal to the value computed above. This
serves as an indication that the commitment to f₁(x), which was sent by
the prover in the commit phase, is indeed the correct one. The verifier
may continue, by querying f₁(-z²) (recall that (-z²)∊ L² and that the
commitment on f₁(x) was given on L²) and deduce from it f₂(z⁴).</p>
<p>The verifier continues in this way until it uses all these queries to
finally deduce the value of f_{log d}(z) (denoting f with a subscript
log d, that we can’t write due to Medium’s lack of support for fully
fledged mathematical notation). But, recall that f_{log d}(z) is a
constant polynomial whose constant value was sent by the prover in the
commit phase, prior to choosing z. The verifier should check that the
value sent by the prover is indeed equal to the value that the verifier
computed from the queries to the previous functions.</p>
<p>Overall, the number of queries is only logarithmic in the degree bound
d.</p>
<p>Optional: To get a feeling why the prover cannot cheat, consider the toy
problem where f₀ is zero on 90% of the pairs of the form {z,-z}, i.e.,
f₀(z) = f₀(-z) = 0 (call these the &quot;<code>good</code>&quot; pairs), and non-zero on the
remaining 10% (the &quot;<code>bad</code>&quot; pairs). With probability 10% the randomly
selected z falls in a bad pair. Note that only one 𝛼 will lead to
f₁(z²)=0, and the rest will lead to f₁(z²)≠0. If the prover cheats on
the value of f₁(z²), it will be caught, so we assume otherwise. Thus,
with a high probability (f₁(z²), f₁(-z²)) will also be a bad pair in the
next layer (the value of f₁(-z²) is not important as f₁(z²)≠0). This
continues until the last layer where the value will be non-zero with
high probability.</p>
<p>On the other hand, since we started with a function with 90% zeros, it
is unlikely that the prover will be able to get close to a low degree
polynomial other than the zero polynomial (we will not prove this fact
here). In particular, this implies that the prover must send 0 as the
value of the last layer. But then, the verifier has a probability of
roughly 10% to catch the prover. This was only an informal argument, the
interested reader may find a rigorous proof
<a href="https://eccc.weizmann.ac.il/report/2017/134/">here</a>.</p>
<p>In summary, the direct solution (test) requires too many queries to
achieve the succinctness required by STARK. To attain logarithmic query
complexity, we use an interactive protocol called FRI, in which the
prover adds more information in order to convince the verifier that the
function is indeed of low degree. Crucially, FRI enables the verifier to
solve the low-degree testing problem with a number of queries (and
rounds of interaction) that is logarithmic in the prescribed degree.</p>
<p>The Book is a community-driven effort created for the community.</p>
<ul>
<li>
<p>If you’ve learned something, or not, please take a moment to provide
feedback through <a href="https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=">this 3-question
survey</a>.</p>
</li>
<li>
<p>If you discover any errors or have additional suggestions, don’t
hesitate to open an <a href="https://github.com/starknet-edu/starknetbook/issues">issue on our GitHub
repository</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="micali-construction"><a class="header" href="#micali-construction">Micali Construction</a></h1>
<h1 id="interactive-oracle-proofs-iops"><a class="header" href="#interactive-oracle-proofs-iops">Interactive Oracle Proofs (IOPs)</a></h1>
<h1 id="bcs-construction"><a class="header" href="#bcs-construction">BCS Construction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starks-protocol-python"><a class="header" href="#starks-protocol-python">STARKs Protocol (Python)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p><em>Copyright 2019 Starkware Industries Ltd. Licensed under the Apache
License, Version 2.0 (the &quot;License&quot;). You may not use this file except
in compliance with the License. You may obtain a copy of the License at
<a href="https://www.starkware.co/open-source-license/">https://www.starkware.co/open-source-license/</a> Unless required by
applicable law or agreed to in writing, software distributed under the
License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License.</em></p>
<h1 id="part-1-trace-and-low-degree-extension"><a class="header" href="#part-1-trace-and-low-degree-extension">Part 1: Trace and Low-Degree Extension</a></h1>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=Y0uJz9VL3Fo">Video Lecture
(youtube)</a></p>
</li>
<li>
<p><a href="https://starkware.co/wp-content/uploads/2021/12/STARK101-Part1.pdf">Slides
(PDF)</a></p>
</li>
</ul>
<p>Today we will develop a STARK prover for the FibonacciSq sequence over a
finite field. The FibonacciSq sequence is defined by the recurrence
relation . By the end of the day, your code will produce a <em>STARK</em> proof
attesting to the following statement: <strong>I know a field element such that
the 1023rd element of the FibonacciSq sequence starting with is</strong> .</p>
<h2 id="the-basics"><a class="header" href="#the-basics">The Basics</a></h2>
<h3 id="fieldelement-class"><a class="header" href="#fieldelement-class">FieldElement class</a></h3>
<p>We use our <code>+FieldElement+</code> class to represent field elements. You can
construct instances of <code>+FieldElement+</code> from integers, and then add,
multiply, divide, get inverse, and so on. The underlying field of this
class is (), so all operations are done modulo 3221225473. Try it by
running the following cell (shift<br />
enter):</p>
<pre><code>from field import FieldElement
FieldElement(3221225472) + FieldElement(10)
</code></pre>
<h1 id="fibonaccisq-trace"><a class="header" href="#fibonaccisq-trace">FibonacciSq Trace</a></h1>
<p>To start, let’s construct a list <code>+a+</code> of length 1023, whose first two
elements will be FieldElement objects representing 1 and 3141592,
respectively. The next 1021 elements will be the FibonacciSq sequence
induced by these two elements. <code>+a+</code> is called the trace of FibonacciSq,
or, when the context is clear, the trace. We can calculate <code>+a+</code> as
follows:</p>
<pre><code>a = [FieldElement(1), FieldElement(3141592)]
while len(a) &lt; 1023:
    a.append(a[-2] * a[-2] + a[-1] * a[-1])
</code></pre>
<h1 id="test-your-code"><a class="header" href="#test-your-code">Test Your Code</a></h1>
<p>Run the next cell to test that you have filled <code>+a+</code> correctly. Note
that this is in fact a verifier, albeit very naive and non-succinct one,
as it goes over the sequence, element by element, making sure it is
correct.</p>
<pre><code>assert len(a) == 1023, 'The trace must consist of exactly 1023 elements.'
assert a[0] == FieldElement(1), 'The first element in the trace must be the unit element.'
for i in range(2, 1023):
    assert a[i] == a[i - 1] * a[i - 1] + a[i - 2] * a[i - 2], f'The FibonacciSq recursion rule does not apply for index {i}'
assert a[1022] == FieldElement(2338775057), 'Wrong last element!'
print('Success!')
</code></pre>
<h1 id="thinking-of-polynomials"><a class="header" href="#thinking-of-polynomials">Thinking of Polynomials</a></h1>
<p>We now want to think of the sequence as the evaluation of some, yet
unknown, polynomial of degree 1022 (due to the Unisolvence Theorem). We
will choose the domain to be some subgroup of size 1024, for reasons
that will become clear later.</p>
<p>(Recall that denotes the multiplicative group of , which we get from by
omitting the zero element with the induced multiplication from the
field. A subgroup of size 1024 exists because is a cyclic group of size
, so it contains a subgroup of size for any ).</p>
<h2 id="find-a-group-of-size-1024"><a class="header" href="#find-a-group-of-size-1024">Find a Group of Size 1024</a></h2>
<p>If we find an element whose (multiplicative) order is 1024, then will
generate such a group. The class <code>+FieldElement+</code> provides a static
method <code>+generator()+</code> which returns an element that generates (whose
order is ).</p>
<ol>
<li>
<p>Use it to obtain a generator for .</p>
</li>
<li>
<p>Create a list called <code>+G+</code> with all the elements of , such that :=
g^i].</p>
</li>
</ol>
<p><em>Hint: When divides , generates a group of size , and the n-th power of
some <code>+FieldElement+</code> can be computed by calling <code>+x ** n+</code>.</em></p>
<p>Solution:</p>
<pre><code>g = FieldElement.generator() ** (3 * 2 ** 20)
G = [g ** i for i in range(1024)]
</code></pre>
<p>Run the next cell to test your code.</p>
<pre><code># Checks that g and G are correct.
assert g.is_order(1024), 'The generator g is of wrong order.'
b = FieldElement(1)
for i in range(1023):
    assert b == G[i], 'The i-th place in G is not equal to the i-th power of g.'
    b = b * g
    assert b != FieldElement(1), f'g is of order {i + 1}'

if b * g == FieldElement(1):
    print('Success!')
else:
    print('g is of order &gt; 1024')
</code></pre>
<h1 id="polynomial-class"><a class="header" href="#polynomial-class">Polynomial class</a></h1>
<p>We provide you with a class called <code>+Polynomial+</code>. The simplest way to
construct a <code>+Polynomial+</code> is by using the variable <code>+X+</code> (note that
it’s a capital <code>+X+</code>) which represents the formal variable :</p>
<pre><code>from polynomial import X
# The polynomial 2x^2 + 1.
p = 2*X**2 + 1
# Evaluate p at 2:
print(p(2))
</code></pre>
<h1 id="interpolating-a-polynomial"><a class="header" href="#interpolating-a-polynomial">Interpolating a Polynomial</a></h1>
<p>Our <code>+polynomial+</code> module provides a Lagrange interpolation function,
whose arguments are:</p>
<ul>
<li>
<p>x_values: x-values of G that the polynomial’s values for them is
known. [List]</p>
</li>
<li>
<p>y_values: the corresponding y-values. [List]</p>
</li>
</ul>
<p>It returns the unique <code>+Polynomial+</code> of degree &lt; <code>+len(x_values)+</code>
instance that evaluates to <code>+y_values[i]+</code> on <code>+x_values[i]+</code> for all i.</p>
<p>Run the following cell to get help on the function <code>+interpolate_poly+</code>.</p>
<pre><code>from polynomial import interpolate_poly
interpolate_poly?
</code></pre>
<p>Suppose that <code>+a+</code> contains the values of some polynomial over <code>+G+</code>
(except for <code>+G[-1]+</code>, since <code>+a+</code> is one element shorter). Use
<code>+interpolate_poly()+</code> to get <code>+f+</code> and get its value at
<code>+FieldElement(2)+</code>.</p>
<p>Solution:</p>
<pre><code>f = interpolate_poly(G[:-1], a)
v = f(2)
</code></pre>
<p>Run test:</p>
<pre><code>assert v == FieldElement(1302089273)
print('Success!')
</code></pre>
<h1 id="evaluating-on-a-larger-domain"><a class="header" href="#evaluating-on-a-larger-domain">Evaluating on a Larger Domain</a></h1>
<p>The trace, viewed as evaluations of a polynomial on , can now be
extended by evaluating over a larger domain, thereby creating a
Reed-Solomon error correction code.</p>
<h2 id="cosets"><a class="header" href="#cosets">Cosets</a></h2>
<p>To that end, we must decide on a larger domain on which will be
evaluated. We will work with a domain that is 8 times larger than . A
natural choice for such a domain is to take some group of size 8192
(which exists because 8192 divides ), and shift it by the generator of ,
thereby obtaining a <a href="https://en.wikipedia.org/wiki/Coset">coset</a> of .</p>
<p>Create a list called <code>+H+</code> of the elements of , and multiply each of
them by the generator of to obtain a list called <code>+eval_domain+</code>. In
other words, eval_domain = for the generator of and the generator of .</p>
<p>Hint: You already know how to obtain - similarly to the way we got a few
minutes ago.</p>
<p>Solution:</p>
<pre><code>w = FieldElement.generator()
h = w ** ((2 ** 30 * 3) // 8192)
H = [h ** i for i in range(8192)]
eval_domain = [w * x for x in H]
</code></pre>
<p>Run test:</p>
<pre><code>from hashlib import sha256
assert len(set(eval_domain)) == len(eval_domain)
w = FieldElement.generator()
w_inv = w.inverse()
assert '55fe9505f35b6d77660537f6541d441ec1bd919d03901210384c6aa1da2682ce' == sha256(str(H[1]).encode()).hexdigest(),\
    'H list is incorrect. H[1] should be h (i.e., the generator of H).'
for i in range(8192):
    assert ((w_inv * eval_domain[1]) ** i) * w == eval_domain[i]
print('Success!')
</code></pre>
<h1 id="evaluate-on-a-coset"><a class="header" href="#evaluate-on-a-coset">Evaluate on a Coset</a></h1>
<p>Time to use <code>+interpolate_poly+</code> and <code>+Polynomial.poly+</code> to evaluate
over the coset. Note that it is implemented fairly naively in our Python
module, so interpolation may take up to a minute. Indeed - interpolating
and evaluating the trace polynomial is one of the most
computationally-intensive steps in the STARK protocol, even when using
more efficient methods (e.g. FFT).</p>
<p>Solution:</p>
<pre><code>f = interpolate_poly(G[:-1], a)
f_eval = [f(d) for d in eval_domain]
</code></pre>
<p>Run test:</p>
<pre><code># Test against a precomputed hash.
from hashlib import sha256
from channel import serialize
assert '1d357f674c27194715d1440f6a166e30855550cb8cb8efeb72827f6a1bf9b5bb' == sha256(serialize(f_eval).encode()).hexdigest()
print('Success!')
</code></pre>
<h1 id="commitments"><a class="header" href="#commitments">Commitments</a></h1>
<p>We will use <a href="https://en.wikipedia.org/wiki/SHA-2">Sha256</a>-based <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle
Trees</a> as our commitment
scheme. A simple implementation of it is available to you in the
<code>+MerkleTree+</code> class. Run the next cell (for the sake of this tutorial,
this also serves as a test for correctness of the entire computation so
far):</p>
<pre><code>from merkle import MerkleTree
f_merkle = MerkleTree(f_eval)
assert f_merkle.root == '6c266a104eeaceae93c14ad799ce595ec8c2764359d7ad1b4b7c57a4da52be04'
print('Success!')
</code></pre>
<h1 id="channel"><a class="header" href="#channel">Channel</a></h1>
<p>Theoretically, a STARK proof system is a protocol for interaction
between two parties - a prover and a verifier. In practice, we convert
this interactive protocol into a non-interactive proof using the
<a href="https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic">Fiat-Shamir
Heuristic</a>.
In this tutorial you will use the <code>+Channel+</code> class, which implements
this transformation. This channel replaces the verifier in the sense
that the prover (which you are writing) will send data, and receive
random numbers or random <code>+FieldElement+</code> instances.</p>
<p>This simple piece of code instantiates a channel object, sends the root
of your Merkle Tree to it. Later, the channel object can be called to
provide random numbers or random field elements.</p>
<pre><code>from channel import Channel
channel = Channel()
channel.send(f_merkle.root)
</code></pre>
<p>Lastly - you can retrieve the proof-so-far (i.e., everything that was
passed in the channel up until a certain point) by printing the member
<code>+Channel.proof+</code>.</p>
<pre><code>print(channel.proof)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><em>Copyright 2019 Starkware Industries Ltd. Licensed under the Apache
License, Version 2.0 (the &quot;License&quot;). You may not use this file except
in compliance with the License. You may obtain a copy of the License at
<a href="https://www.starkware.co/open-source-license/">https://www.starkware.co/open-source-license/</a> Unless required by
applicable law or agreed to in writing, software distributed under the
License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License.</em></p>
<h1 id="part-2-constraints"><a class="header" href="#part-2-constraints">Part 2: Constraints</a></h1>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=fg3mFPXEYQY">Video Lecture
(youtube)</a></p>
</li>
<li>
<p><a href="https://starkware.co/wp-content/uploads/2021/12/STARK101-Part2.pdf">Slides
(PDF)</a></p>
</li>
</ul>
<p>In this part, we are going to create a set of constraints over the trace
<code>a</code>. The constraints will be expressions in the trace’s cells that are
polynomials (rather than <a href="https://en.wikipedia.org/wiki/Rational_function">rational
functions</a>) if and only
if the trace represents a valid computation of the FibonacciSq. We will
get there in three steps:</p>
<ol>
<li>
<p>Start by specifying the constraints we care about (the <strong>FibonacciSq
constraints</strong>).</p>
</li>
<li>
<p>Translate the FibonacciSq constraints into <strong>polynomial
constraints</strong>.</p>
</li>
<li>
<p>Translate those into <strong>rational functions</strong> that represent
polynomials if and only if the original constraints hold.</p>
</li>
</ol>
<h1 id="step-1---fibonaccisq-constraints"><a class="header" href="#step-1---fibonaccisq-constraints">Step 1 - FibonacciSq Constraints</a></h1>
<p>For <code>a</code> to be a correct trace of a FibonacciSq sequence that proves our
claim:</p>
<ol>
<li>
<p>The first element has to be 1, namely = 1].</p>
</li>
<li>
<p>The last element has to be 2338775057, namely = 2338775057].</p>
</li>
<li>
<p>The FibonacciSq rule must apply, that is - for every ,
[i+2]=a[i+1]²+a[i]².</p>
</li>
</ol>
<h1 id="step-2---polynomial-constraints"><a class="header" href="#step-2---polynomial-constraints">Step 2 - Polynomial Constraints</a></h1>
<p>Recall that <code>f</code> is a polynomial over the trace domain, that evaluates
exactly to <code>a</code> over where is the &quot;small&quot; group generated by .</p>
<p>We now rewrite the above three constraints in a form of polynomial
constraints over <code>f</code>:</p>
<ol>
<li>
<p>= 1$] is translated to the polynomial , which evalutes to 0 for
(note that is ).</p>
</li>
<li>
<p>= 2338775057$] is translated to the polynomial , which evalutes to
0 for .</p>
</li>
<li>
<p>=a<sup><span class="i+1">2+a[i]</span></sup>2$] for every is
translated to the polynomial , which evaluates to 0 for .</p>
</li>
</ol>
<h1 id="hands-on"><a class="header" href="#hands-on">Hands on</a></h1>
<p>First, since this is a separate notebook from Part 1, let’s run the
following piece of code to have all the variables here with their
correct values. Note that it may take up to 30 seconds, since it reruns
the polynomial interpolation.</p>
<pre><code>from channel import Channel
from field import FieldElement
from merkle import MerkleTree
from polynomial import interpolate_poly, X, prod
from tutorial_sessions import part1

a, g, G, h, H, eval_domain, f, f_eval, f_merkle, channel = part1()
print('Success!')
</code></pre>
<p>You will obtain each of the three constraints as a quotient of two
polynomials, making sure the remainder is the zero polynomial.</p>
<h1 id="step-3---rational-functions-that-are-in-fact-polynomials"><a class="header" href="#step-3---rational-functions-that-are-in-fact-polynomials">Step 3 - Rational Functions (That are in Fact Polynomials)</a></h1>
<p>Each of the constraints above is represented by a polynomial that
supposedly evaluates to on certain elements of the group . That is, for
some , we claim that</p>
<p>(note that for the first two constraints, because they only refer to one
point and for the third ).</p>
<p>This is equivalent to saying that is divisible, as a polynomial, by all
of , or, equivalently, by</p>
<p>Therefore, each of the three constraints above can be written as a
rational function of the form:</p>
<p>for the corresponding and . In this step we will construct these three
rational functions and show that they are indeed polynomials.</p>
<h1 id="the-first-constraint"><a class="header" href="#the-first-constraint">The First Constraint:</a></h1>
<p>In the first constraint, and .</p>
<p>We will now construct the <strong>polynomial</strong> , making sure that is indeed
divisible by .</p>
<p>Solution:</p>
<pre><code>numer0 = f - 1
denom0 = X - 1
</code></pre>
<p>Convince yourself that vanishes at by making sure that evaluating this
polynomial at yields .</p>
<p>The fact that has a root at implies that it is divisible by . Run the
following cell to convince yourself that the remainder of <code>numer0</code>
modulo <code>denom0</code> is , and therefore division indeed yields a polynomial:</p>
<pre><code>numer0 % denom0
</code></pre>
<p>Run the following cell to construct <code>p0</code>, the polynomial representing
the first constraint, by dividing <code>numer0</code> by <code>denom0</code>:</p>
<pre><code>p0 = numer0 / denom0
</code></pre>
<p>Run test:</p>
<pre><code>assert p0(2718) == 2509888982
print('Success!')
</code></pre>
<h1 id="the-second-constraint"><a class="header" href="#the-second-constraint">The Second Constraint</a></h1>
<p>Construct the polynomial <code>p1</code> representing the second constraint, ,
similarly.</p>
<p>Solution:</p>
<pre><code>numer1 = f - 2338775057
denom1 = X - g**1022
p1 = numer1 / denom1
</code></pre>
<p>Run test:</p>
<pre><code>assert p1(5772) == 232961446
print('Success!')
</code></pre>
<h1 id="the-third-constraint---succinctness"><a class="header" href="#the-third-constraint---succinctness">The Third Constraint - Succinctness</a></h1>
<p>The last constraint’s rational function is slightly more complicated:</p>
<p>whose denominator can be rewritten, so that the entire expression is
easier to compute:</p>
<p>This follows from the equality</p>
<p>Convince yourself of this equality using the function <code>prod</code> that takes
a list and computes its product.</p>
<p>Solution:</p>
<pre><code>lst = [(X - g**i) for i in range(1024)]
prod(lst)
</code></pre>
<p>For more information, see our blog post titled <a href="https://medium.com/starkware/arithmetization-ii-403c3b3f4355">Arithmetization
II</a>.</p>
<p>Let’s pause for a moment, and look at a simple example on how
polynomials are composed. After that we will generate the third
constraint.</p>
<h1 id="composing-polynomials-a-detour"><a class="header" href="#composing-polynomials-a-detour">Composing Polynomials (a detour)</a></h1>
<p>Create the two polynomials , :</p>
<pre><code>q = 2*X ** 2 + 1
r = X - 3
</code></pre>
<p>Composing on yields a new polynomial: Run the following cell to create a
third polynomial <code>cmp</code> by composing <code>q</code> on <code>r</code> and convince yourself
that <code>cmp</code> is indeed the composition of <code>q</code> and <code>r</code>:</p>
<pre><code>cmp = q(r)
cmp
</code></pre>
<h1 id="back-to-polynomial-constraints"><a class="header" href="#back-to-polynomial-constraints">Back to Polynomial Constraints</a></h1>
<p>Construct the third constraint <code>p2</code> in a similar manner to the
construction of <code>p0</code> and <code>p1</code>, using polynomial composition. Along the
way, verify that is a root of the <strong>numerator</strong> while is not.</p>
<p>Solution:</p>
<pre><code>numer2 = f(g**2 * X) - f(g * X)**2 - f**2
print(&quot;Numerator at g^1020 is&quot;, numer2(g**1020))
print(&quot;Numerator at g^1021 is&quot;, numer2(g**1021))
denom2 = (X**1024 - 1) / ((X - g**1021) * (X - g**1022) * (X - g**1023))

p2 = numer2 / denom2
</code></pre>
<p>Run test:</p>
<pre><code>assert p2.degree() == 1023, f'The degree of the third constraint is {p2.degree()} when it should be 1023.'
assert p2(31415) == 2090051528
print('Success!')
</code></pre>
<p>Run the following cell to observe the degrees of the constraint
polynomials <code>p0</code>, <code>p1</code> and <code>p2</code>, all less than . This will be important
in the next part.</p>
<pre><code>print('deg p0 =', p0.degree())
print('deg p1 =', p1.degree())
print('deg p2 =', p2.degree())
</code></pre>
<h1 id="step-4---composition-polynomial"><a class="header" href="#step-4---composition-polynomial">Step 4 - Composition Polynomial</a></h1>
<p>Recall that we’re translating a problem of checking the validity of
three polynomial constraints to checking that each of the rational
functions are polynomials.</p>
<p>Our protocol uses an algorithm called
<a href="https://eccc.weizmann.ac.il/report/2017/134/">FRI</a> to do so, which will
be discussed in the next part. In order for the proof to be succinct
(short), we prefer to work with just one rational function instead of
three. For that, we take a random linear combination of called the
<strong>composition polynomial</strong> (CP for short):</p>
<p>where are random field elements obtained from the verifier, or in our
case - from the channel.</p>
<p>Proving that (the rational function) is a polynomial guarantees, with
high probability, that each of , , are themselves polynomials.</p>
<p>In the next part, you will generate a proof for an equivalent fact. But
first, let’s create <code>CP</code> using <code>Channel.receive_random_field_element</code> to
obtain .</p>
<p>Solution:</p>
<pre><code>def get_CP(channel):
    alpha0 = channel.receive_random_field_element()
    alpha1 = channel.receive_random_field_element()
    alpha2 = channel.receive_random_field_element()
    return alpha0*p0 + alpha1*p1 + alpha2*p2
</code></pre>
<p>Run test:</p>
<pre><code>test_channel = Channel()
CP_test = get_CP(test_channel)
assert CP_test.degree() == 1023, f'The degree of cp is {CP_test.degree()} when it should be 1023.'
assert CP_test(2439804) == 838767343, f'cp(2439804) = {CP_test(2439804)}, when it should be 838767343'
print('Success!')
</code></pre>
<h1 id="commit-on-the-composition-polynomial"><a class="header" href="#commit-on-the-composition-polynomial">Commit on the Composition Polynomial</a></h1>
<p>Lastly, we evaluate over the evaluation domain (<code>eval_domain</code>), build a
Merkle tree on top of that and send its root over the channel. This is
similar to committing on the LDE trace, as we did at the end of part 1.</p>
<p>Solution:</p>
<pre><code>def CP_eval(channel):
    CP = get_CP(channel)
    return [CP(d) for d in eval_domain]
</code></pre>
<p>Construct a Merkle Tree over the evaluation and send its root over the
channel.</p>
<p>Solution:</p>
<pre><code>channel = Channel()
CP_merkle = MerkleTree(CP_eval(channel))
channel.send(CP_merkle.root)
</code></pre>
<p>Test your code:</p>
<pre><code>assert CP_merkle.root == 'a8c87ef9764af3fa005a1a2cf3ec8db50e754ccb655be7597ead15ed4a9110f1', 'Merkle tree root is wrong.'
print('Success!')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><em>Copyright 2019 Starkware Industries Ltd. Licensed under the Apache
License, Version 2.0 (the &quot;License&quot;). You may not use this file except
in compliance with the License. You may obtain a copy of the License at
<a href="https://www.starkware.co/open-source-license/">https://www.starkware.co/open-source-license/</a> Unless required by
applicable law or agreed to in writing, software distributed under the
License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License.</em></p>
<h1 id="part-3-fri-commitments"><a class="header" href="#part-3-fri-commitments">Part 3: FRI Commitments</a></h1>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=gd1NbKUOJwA">Video Lecture
(youtube)</a></p>
</li>
<li>
<p><a href="https://starkware.co/wp-content/uploads/2021/12/STARK101-Part3.pdf">Slides
(PDF)</a></p>
</li>
</ul>
<h1 id="load-previous-session"><a class="header" href="#load-previous-session">Load Previous Session</a></h1>
<p>Run the next cell to load the relevant variables. As usual - it will
take a while to run.</p>
<pre><code>from channel import Channel
from field import FieldElement
from merkle import MerkleTree
from polynomial import interpolate_poly, Polynomial
from tutorial_sessions import part1, part2

cp, cp_eval, cp_merkle, channel, eval_domain = part2()
print(&quot;Success&quot;)
</code></pre>
<h1 id="fri-folding"><a class="header" href="#fri-folding">FRI Folding</a></h1>
<p>Our goal in this part is to construct the FRI layers and commit on them.
To obtain each layer we need:</p>
<ol>
<li>
<p>To generate a domain for the layer (from the previous layer’s
domain).</p>
</li>
<li>
<p>To generate a polynomial for the layer (from the previous layer’s
polynomial and domain).</p>
</li>
<li>
<p>To evaluate said polynomial on said domain - <strong>this is the next FRI
layer</strong>.</p>
</li>
</ol>
<h1 id="domain-generation"><a class="header" href="#domain-generation">Domain Generation</a></h1>
<p>The first FRI domain is simply the <code>eval_domain</code> that you already
generated in Part 1, namely a coset of a group of order 8192. Each
subsequent FRI domain is obtained by taking the first half of the
previous FRI domain (dropping the second half), and squaring each of its
elements.</p>
<p>Formally - we got <code>eval_domain</code> by taking:</p>
<p>The next layer will therefore be:</p>
<p>Note that taking the squares of the second half of each elements in
<code>eval_domain</code> yields exactly the same result as taking the squares of
the first half. This is true for the next layers as well. For example:</p>
<pre><code>print(eval_domain[100] ** 2)
half_domain_size = len(eval_domain) // 2
print(eval_domain[half_domain_size + 100] ** 2)
</code></pre>
<p>Similarly, the domain of the third layer will be:</p>
<p>And so on.</p>
<p>Write a function <code>next_fri_domain</code> that takes the previous domain as an
argument, and outputs the next one.</p>
<p>Solution:</p>
<pre><code>def next_fri_domain(fri_domain):
    return [x ** 2 for x in fri_domain[:len(fri_domain) // 2]]
</code></pre>
<p>Run test:</p>
<pre><code># Test against a precomputed hash.
from hashlib import sha256
next_domain = next_fri_domain(eval_domain)
assert '5446c90d6ed23ea961513d4ae38fc6585f6614a3d392cb087e837754bfd32797' == sha256(','.join([str(i) for i in next_domain]).encode()).hexdigest()
print('Success!')
</code></pre>
<h1 id="fri-folding-operator"><a class="header" href="#fri-folding-operator">FRI Folding Operator</a></h1>
<p>The first FRI polynomial is simply the composition polynomial, i.e.,
<code>cp</code>. Each subsequent FRI polynomial is obtained by:</p>
<ol>
<li>
<p>Getting a random field element (by calling
<code>Channel.receive_random_field_element</code>).</p>
</li>
<li>
<p>Multiplying the odd coefficients of the previous polynomial by .</p>
</li>
<li>
<p>Summing together consecutive pairs (even-odd) of coefficients.</p>
</li>
</ol>
<p>Formally, let’s say that the k-th polynomial is of degree (for some
which is a power of 2):</p>
<p>Then the (k+1)-th polynomial, whose degree is will be:</p>
<p>Write a function <code>next_fri_polynomial</code> that takes as arguments a
polynomial and a field element (the one we referred to as ), and returns
the &quot;folded&quot; next polynomial.</p>
<p>Note that:</p>
<ol>
<li>
<p><code>Polynomial.poly</code> contains a list of a polynomial’s coefficients,
the free term first, and the highest degree last, so
<code>p.poly[i] == u</code> if the coefficient of is .*</p>
</li>
<li>
<p><code>Polynomial</code>'s default constructor takes the list of coefficients as
argument. So a polynomial can be instantiated from a list of
coefficients <code>l</code> by calling <code>Polynomial(l)</code>.</p>
</li>
</ol>
<p>Solution:</p>
<pre><code>def next_fri_polynomial(poly,  beta):
    odd_coefficients = poly.poly[1::2]
    even_coefficients = poly.poly[::2]
    odd = beta * Polynomial(odd_coefficients)
    even = Polynomial(even_coefficients)
    return odd + even
</code></pre>
<p>Run test:</p>
<pre><code>next_p = next_fri_polynomial(cp, FieldElement(987654321))
assert '6bff4c35e1aa9693f9ceb1599b6a484d7636612be65990e726e52a32452c2154' == sha256(','.join([str(i) for i in next_p.poly]).encode()).hexdigest()
print('Success!')
</code></pre>
<h1 id="putting-it-together-to-get-the-next-fri-layer"><a class="header" href="#putting-it-together-to-get-the-next-fri-layer">Putting it Together to Get the Next FRI Layer</a></h1>
<p>Write a function <code>next_fri_layer</code> that takes a polynomial, a domain, and
a field element (again - ), and returns the next polynomial, the next
domain, and the evaluation of this next polynomial on this next domain.</p>
<p>Solution:</p>
<pre><code>def next_fri_layer(poly, domain, beta):
    next_poly = next_fri_polynomial(poly, beta)
    next_domain = next_fri_domain(domain)
    next_layer = [next_poly(x) for x in next_domain]
    return next_poly, next_domain, next_layer
</code></pre>
<p>Run test:</p>
<pre><code>test_poly = Polynomial([FieldElement(2), FieldElement(3), FieldElement(0), FieldElement(1)])
test_domain = [FieldElement(3), FieldElement(5)]
beta = FieldElement(7)
next_p, next_d, next_l = next_fri_layer(test_poly, test_domain, beta)
assert next_p.poly == [FieldElement(23), FieldElement(7)]
assert next_d == [FieldElement(9)]
assert next_l == [FieldElement(86)]
print('Success!')
</code></pre>
<h1 id="generating-fri-commitments"><a class="header" href="#generating-fri-commitments">Generating FRI Commitments</a></h1>
<p>We have now developed the tools to write the <code>FriCommit</code> method, that
contains the main FRI commitment loop.</p>
<p>It takes the following 5 arguments:</p>
<ol>
<li>
<p>The composition polynomial, that is also the first FRI polynomial,
that is - <code>cp</code>.</p>
</li>
<li>
<p>The coset of order 8192 that is also the first FRI domain, that is -
<code>eval_domain</code>.</p>
</li>
<li>
<p>The evaluation of the former over the latter, which is also the
first FRI layer, that is - <code>cp_eval</code>.</p>
</li>
<li>
<p>The first Merkle tree (we will have one for each FRI layer)
constructed from these evaluations, that is - <code>cp_merkle</code>.</p>
</li>
<li>
<p>A channel object, that is <code>channel</code>.</p>
</li>
</ol>
<p>The method accordingly returns 4 lists:</p>
<ol>
<li>
<p>The FRI polynomials.</p>
</li>
<li>
<p>The FRI domains.</p>
</li>
<li>
<p>The FRI layers.</p>
</li>
<li>
<p>The FRI Merkle trees.</p>
</li>
</ol>
<p>The method contains a loop, in each iteration of which we extend these
four lists, using the last element in each. The iteration should stop
once the last FRI polynomial is of degree 0, that is - when the last FRI
polynomial is just a constant. It should then send over the channel this
constant (i.e. - the polynomial’s free term). The <code>Channel</code> class only
supports sending strings, so make sure you convert anything you wish to
send over the channel to a string before sending.</p>
<p>Solution:</p>
<pre><code>def FriCommit(cp, domain, cp_eval, cp_merkle, channel):
    fri_polys = [cp]
    fri_domains = [domain]
    fri_layers = [cp_eval]
    fri_merkles = [cp_merkle]
    while fri_polys[-1].degree() &gt; 0:
        beta = channel.receive_random_field_element()
        next_poly, next_domain, next_layer = next_fri_layer(fri_polys[-1], fri_domains[-1], beta)
        fri_polys.append(next_poly)
        fri_domains.append(next_domain)
        fri_layers.append(next_layer)
        fri_merkles.append(MerkleTree(next_layer))
        channel.send(fri_merkles[-1].root)
    channel.send(str(fri_polys[-1].poly[0]))
    return fri_polys, fri_domains, fri_layers, fri_merkles
</code></pre>
<p>Run test:</p>
<pre><code>test_channel = Channel()
fri_polys, fri_domains, fri_layers, fri_merkles = FriCommit(cp, eval_domain, cp_eval, cp_merkle, test_channel)
assert len(fri_layers) == 11, f'Expected number of FRI layers is 11, whereas it is actually {len(fri_layers)}.'
assert len(fri_layers[-1]) == 8, f'Expected last layer to contain exactly 8 elements, it contains {len(fri_layers[-1])}.'
assert all([x == FieldElement(-1138734538) for x in fri_layers[-1]]), f'Expected last layer to be constant.'
assert fri_polys[-1].degree() == 0, 'Expected last polynomial to be constant (degree 0).'
assert fri_merkles[-1].root == '1c033312a4df82248bda518b319479c22ea87bd6e15a150db400eeff653ee2ee', 'Last layer Merkle root is wrong.'
assert test_channel.state == '61452c72d8f4279b86fa49e9fb0fdef0246b396a4230a2bfb24e2d5d6bf79c2e', 'The channel state is not as expected.'
print('Success!')
</code></pre>
<p>Run the following cell to execute the function with your channel object
and print the proof so far:</p>
<pre><code>fri_polys, fri_domains, fri_layers, fri_merkles = FriCommit(cp, eval_domain, cp_eval, cp_merkle, channel)
print(channel.proof)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><em>Copyright 2019 Starkware Industries Ltd. Licensed under the Apache
License, Version 2.0 (the &quot;License&quot;). You may not use this file except
in compliance with the License. You may obtain a copy of the License at
<a href="https://www.starkware.co/open-source-license/">https://www.starkware.co/open-source-license/</a> Unless required by
applicable law or agreed to in writing, software distributed under the
License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License.</em></p>
<h1 id="part-4-query-phase"><a class="header" href="#part-4-query-phase">Part 4: Query Phase</a></h1>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=CxP28qM4tAc">Video Lecture
(youtube)</a></p>
</li>
<li>
<p><a href="https://starkware.co/wp-content/uploads/2021/12/STARK101-Part4.pdf">Slides
(PDF)</a></p>
</li>
</ul>
<h1 id="load-the-previous-session"><a class="header" href="#load-the-previous-session">Load the Previous Session</a></h1>
<p>Run the next cell to load the variables we’ll use in this part. Since it
repeats everything done in previous parts - it will take a while to run.</p>
<pre><code>from channel import Channel
from tutorial_sessions import part1, part3

_, _, _, _, _, _, _, f_eval, f_merkle, _ = part1()
fri_polys, fri_domains, fri_layers, fri_merkles, _ = part3()

print('Success!')
</code></pre>
<h1 id="decommit-on-a-query"><a class="header" href="#decommit-on-a-query">Decommit on a Query</a></h1>
<p>Our goal in this part is to generate all the information needed for
verifying the commitments of the three previous parts. In this part we
write two functions:</p>
<ol>
<li>
<p><code>decommit_on_fri_layers</code> - sends over the channel data showing that
each FRI layer is consistent with the others, when sampled at a
specified index.</p>
</li>
<li>
<p><code>decommit_on_query</code> - sends data required for decommiting on the
trace and then calls <code>decommit_on_fri_layers</code>.</p>
</li>
</ol>
<h1 id="decommit-on-the-fri-layers"><a class="header" href="#decommit-on-the-fri-layers">Decommit on the FRI Layers</a></h1>
<p>Implement <code>decommit_on_fri_layers</code> function. The function gets an index
and a channel, and sends over the channel the relevant data for
verifying the correctness of the FRI layers. More specifically, it
iterates over <code>fri_layers</code> and <code>fri_merkles</code> and in each iteration it
sends the following data (in the stated order):</p>
<ol>
<li>
<p>The element of the FRI layer at the given index (using
<code>fri_layers</code>).</p>
</li>
<li>
<p>Its authentication path (using the corresponding Merkle tree from
<code>fri_merkles</code>).</p>
</li>
<li>
<p>The element’s FRI sibling (i.e., if the element is , then its
sibling is , where is the current layer’s polynomial, and is an
element from the current layer’s domain).</p>
</li>
<li>
<p>The authentication path of the element’s sibling (using the same
merkle tree).</p>
</li>
</ol>
<p>To get an authentication path of an element, use
<code>get_authentication_path()</code> of the <code>MerkleTree</code> class, with the
corresponding index each time. Note that the index of the element’s
sibling equals to (idx + ) mod , where is the length of the relevant FRI
layer. Note that we do <strong>not</strong> send the authentication path for the
element in the last layer. In the last layer, all the elements are
equal, regardless of the query, as they are evaluations of a constant
polynomial.</p>
<p><em>(Remember to convert non-string variables into string before sending
over the channel.)</em></p>
<p>Solution:</p>
<pre><code>def decommit_on_fri_layers(idx, channel):
    for layer, merkle in zip(fri_layers[:-1], fri_merkles[:-1]):
        length = len(layer)
        idx = idx % length
        sib_idx = (idx + length // 2) % length
        channel.send(str(layer[idx]))
        channel.send(str(merkle.get_authentication_path(idx)))
        channel.send(str(layer[sib_idx]))
        channel.send(str(merkle.get_authentication_path(sib_idx)))
    channel.send(str(fri_layers[-1][0]))
</code></pre>
<p>Test your code:</p>
<pre><code># Test against a precomputed hash.
test_channel = Channel()
for query in [7527, 8168, 1190, 2668, 1262, 1889, 3828, 5798, 396, 2518]:
    decommit_on_fri_layers(query, test_channel)
assert test_channel.state == 'ad4fe9aaee0fbbad0130ae0fda896393b879c5078bf57d6c705ec41ce240861b', 'State of channel is wrong.'
print('Success!')
</code></pre>
<h1 id="decommit-on-the-trace-polynomial"><a class="header" href="#decommit-on-the-trace-polynomial">Decommit on the Trace Polynomial</a></h1>
<p>To prove that indeed the FRI layers we decommit on were generated from
evaluation of the composition polynomial, we must also send:</p>
<ol>
<li>
<p>The value with its authentication path.</p>
</li>
<li>
<p>The value with its authentication path.</p>
</li>
<li>
<p>The value with its authentication path. The verifier, knowing the
random coefficients of the composition polynomial, can compute its
evaluation at , and compare it with the first element sent from the
first FRI layer.</p>
</li>
</ol>
<p>The function <code>decommit_on_query</code> should therefore send the above (1, 2,
and 3) over the channel, and then call <code>decommit_on_fri_layers</code>.</p>
<p>Importantly, even though are consecutive elements (modulo the group size
) in the trace, the evaluations of <code>f_eval</code> in these points are actually
8 elements apart. The reason for this is that we &quot;blew up&quot; the trace to
8 times its size in part I, to obtain a Reed Solomon codeword.</p>
<p><em>Reminder: <code>f_eval</code> is the evaluation of the composition polynomial, and
<code>f_merkle</code> is the corresponding Merkle tree.</em></p>
<p>Solution:</p>
<pre><code>def decommit_on_query(idx, channel):
    assert idx + 16 &lt; len(f_eval), f'query index: {idx} is out of range. Length of layer: {len(f_eval)}.'
    channel.send(str(f_eval[idx])) # f(x).
    channel.send(str(f_merkle.get_authentication_path(idx))) # auth path for f(x).
    channel.send(str(f_eval[idx + 8])) # f(gx).
    channel.send(str(f_merkle.get_authentication_path(idx + 8))) # auth path for f(gx).
    channel.send(str(f_eval[idx + 16])) # f(g^2x).
    channel.send(str(f_merkle.get_authentication_path(idx + 16))) # auth path for f(g^2x).
    decommit_on_fri_layers(idx, channel)
</code></pre>
<p>Test your code:</p>
<pre><code># Test against a precomputed hash.
test_channel = Channel()
for query in [8134, 1110, 1134, 6106, 7149, 4796, 144, 4738, 957]:
    decommit_on_query(query, test_channel)
assert test_channel.state == '16a72acce8d10ffb318f8f5cd557930e38cdba236a40439c9cf04aaf650cfb96', 'State of channel is wrong.'
print('Success!')
</code></pre>
<h1 id="decommit-on-a-set-of-queries"><a class="header" href="#decommit-on-a-set-of-queries">Decommit on a Set of Queries</a></h1>
<p>To finish the proof, the prover gets a set of random queries from the
channel, i.e., indices between 0 to 8191, and decommits on each query.</p>
<p>Use the function that you just implemented <code>decommit_on_query()</code>, and
<code>Channel.receive_random_int</code> to generate 3 random queries and decommit
on each.</p>
<p>Solution:</p>
<pre><code>def decommit_fri(channel):
    for query in range(3):
        # Get a random index from the verifier and send the corresponding decommitment.
        decommit_on_query(channel.receive_random_int(0, 8191-16), channel)
</code></pre>
<p>Test your code:</p>
<pre><code>test_channel = Channel()
decommit_fri(test_channel)
assert test_channel.state == 'eb96b3b77fe6cd48cfb388467c72440bdf035c51d0cfe8b4c003dd1e65e952fd', 'State of channel is wrong.'
print('Success!')
</code></pre>
<h1 id="proving-time"><a class="header" href="#proving-time">Proving Time!</a></h1>
<p>Run the following cell that ties it all together, running all previous
code, as well as the functions you wrote in this part, and prints the
proof.</p>
<pre><code>import time
from tutorial_sessions import part1, part3

start = time.time()
start_all = start
print(&quot;Generating the trace...&quot;)
_, _, _, _, _, _, _, f_eval, f_merkle, _ = part1()
print(f'{time.time() - start}s')
start = time.time()
print(&quot;Generating the composition polynomial and the FRI layers...&quot;)
fri_polys, fri_domains, fri_layers, fri_merkles, channel = part3()
print(f'{time.time() - start}s')
start = time.time()
print(&quot;Generating queries and decommitments...&quot;)
decommit_fri(channel)
print(f'{time.time() - start}s')
start = time.time()
print(channel.proof)
print(f'Overall time: {time.time() - start_all}s')
print(f'Uncompressed proof length in characters: {len(str(channel.proof))}')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starks-protocol-rust"><a class="header" href="#starks-protocol-rust">STARKs Protocol (Rust)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p><em>Copyright 2019 StarkWare Industries Ltd. Licensed under the Apache
License, Version 2.0 (the &quot;License&quot;). You may not use this file except
in compliance with the License. You may obtain a copy of the License at
<a href="https://www.starkware.co/open-source-license/">https://www.starkware.co/open-source-license/</a> Unless required by
applicable law or agreed to in writing, software distributed under the
License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License.</em></p>
<h1 id="part-1-trace-and-low-degree-extension-1"><a class="header" href="#part-1-trace-and-low-degree-extension-1">Part 1: Trace and Low-Degree Extension</a></h1>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=Y0uJz9VL3Fo">Video Lecture
(youtube)</a></p>
</li>
<li>
<p><a href="https://starkware.co/wp-content/uploads/2021/12/STARK101-Part1.pdf">Slides
(PDF)</a></p>
</li>
</ul>
<p>Today we will develop a STARK prover for the FibonacciSq sequence over a
finite field. The FibonacciSq sequence is defined by the recurrence
relation . By the end of the day, your code will produce a <em>STARK</em> proof
attesting to the following statement: <strong>I know a field element such that
the 1023rd element of the FibonacciSq sequence starting with is</strong> .</p>
<h2 id="the-basics-1"><a class="header" href="#the-basics-1">The Basics</a></h2>
<h3 id="fieldelement-class-1"><a class="header" href="#fieldelement-class-1">FieldElement class</a></h3>
<p>We use our <code>+FieldElement+</code> struct to represent field elements. You can
construct values of type <code>+FieldElement+</code> from integers, and then add,
multiply, divide, get inverse, and so on. The underlying field of this
class is (), so all operations are done modulo 3221225473.</p>
<p>Try it by running the following cell (shift + enter):</p>
<pre><code>:dep stark101-rs = { path = &quot;stark101&quot; }
:dep sha256 = &quot;1.1.2&quot;

use stark101_rs::field::*;
println!(&quot;The result is: {:?}&quot;, FieldElement::new(3221225472) + FieldElement::new(10));

The result is: FieldElement(9)
</code></pre>
<h1 id="fibonaccisq-trace-1"><a class="header" href="#fibonaccisq-trace-1">FibonacciSq Trace</a></h1>
<p>To start, let’s construct a vector <code>+a+</code> of length 1023, whose first two
elements will be FieldElement objects representing 1 and 3141592,
respectively. The next 1021 elements will be the FibonacciSq sequence
induced by these two elements. <code>+a+</code> is called the trace of FibonacciSq,
or, when the context is clear, the trace. Correct the code below to fill
<code>+a+</code>:</p>
<pre><code>let mut a = vec![FieldElement::new(1), FieldElement::new(3141592)];
todo!(&quot;Put your code here&quot;);

thread '&lt;unnamed&gt;' panicked at 'not yet implemented: Put your code here', src/lib.rs:160:1
stack backtrace:
   0: _rust_begin_unwind
   1: core::panicking::panic_fmt
   2: &lt;unknown&gt;
   3: &lt;unknown&gt;
   4: evcxr::runtime::Runtime::run_loop
   5: evcxr::runtime::runtime_hook
   6: evcxr_jupyter::main
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p>Solution (click to the … to unhide):</p>
<pre><code>let mut a = vec![FieldElement::new(1), FieldElement::new(3141592)];
let mut n = 2usize;
while a.len() &lt; 1023 {
    a.push(a[n-2] * a[n-2] + a[n-1] * a[n-1]);
    n += 1;
}

()
</code></pre>
<h1 id="test-your-code-1"><a class="header" href="#test-your-code-1">Test Your Code</a></h1>
<p>Run the next cell to test that you have filled <code>+a+</code> correctly. Note
that this is in fact a <strong>verifier</strong>, albeit very naive and non-succinct
one, as it goes over the sequence, element by element, making sure it is
correct.</p>
<pre><code>assert_eq!(a.len(), 1023, &quot;The trace must consist of exactly 1023 elements.&quot;);
assert_eq!(a[0], FieldElement::new(1), &quot;The first element in the trace must be the unit element.&quot;);
for i in 2..1023 {
    assert_eq!(a[i], a[i - 1] * a[i - 1] + a[i - 2] * a[i - 2], &quot;The FibonacciSq recursion rule does not apply for index {i}&quot;);
}
assert_eq!(a[1022], FieldElement::new(2338775057), &quot;Wrong last element!&quot;);
println!(&quot;Success!&quot;);

Success!
</code></pre>
<h1 id="thinking-of-polynomials-1"><a class="header" href="#thinking-of-polynomials-1">Thinking of Polynomials</a></h1>
<p>We now want to think of the sequence as the evaluation of some, yet
unknown, polynomial of degree 1022 (due to the Unisolvence Theorem). We
will choose the domain to be some subgroup of size 1024, for reasons
that will become clear later.</p>
<p>(Recall that denotes the multiplicative group of , which we get from by
omitting the zero element with the induced multiplication from the
field. A subgroup of size 1024 exists because is a cyclic group of size
, so it contains a subgroup of size for any ).</p>
<h2 id="find-a-group-of-size-1024-1"><a class="header" href="#find-a-group-of-size-1024-1">Find a Group of Size 1024</a></h2>
<p>If we find an element whose (multiplicative) order is 1024, then will
generate such a group. The struct <code>+FieldElement+</code> provides a method
<code>+generator()+</code> which returns an element that generates (whose order is
).</p>
<ol>
<li>
<p>Use it to obtain a generator for .</p>
</li>
<li>
<p>Create a vec called <code>+G+</code> with all the elements of , such that :=
g^i].</p>
</li>
</ol>
<p><em>Hint: When divides , generates a group of size , and the n-th power of
some <code>+FieldElement+</code> can be computed by calling <code>+x ** n+</code>.</em></p>
<pre><code>// Change the following line so that g will generate a group of size 1024
let g = FieldElement::generator();
// Fill G with the elements of G such that G[i] := g ** i
let G: Vec&lt;FieldElement&gt; = vec![];
</code></pre>
<p>Solution:</p>
<pre><code>let g = FieldElement::generator().pow(3 * 2usize.pow(20));
let G: Vec&lt;FieldElement&gt; = (0..1024).into_iter().map(|i| g.pow(i)).collect();
</code></pre>
<p>Run the next cell to test your code.</p>
<pre><code>// Checks that g and G are correct.
assert!(g.is_order(1024), &quot;The generator g is of wrong order.&quot;);
let mut b = FieldElement::one();
for i in 0..1023 {
    assert_eq!(b, G[i], &quot;The i-th place in G is not equal to the i-th power of g.&quot;);
    b = b * g;
    let wrong_order = i + 1;
    assert!(b != FieldElement::one(), &quot;g is of order {wrong_order}&quot;);
}
if b * g == FieldElement::one() {
    println!(&quot;Success!&quot;);
} else {
    println!(&quot;g is of order &gt; 1024&quot;);
}

Success!

()
</code></pre>
<h1 id="polynomial-class-1"><a class="header" href="#polynomial-class-1">Polynomial class</a></h1>
<p>We provide you with a struct called <code>+Polynomial+</code>. The simplest way to
construct a <code>+Polynomial+</code> is by using the function <strong>x()</strong> which
represents the formal variable :</p>
<pre><code>use stark101_rs::polynomial::*;
// The polynomial 2x^2 + 1.
let p: Polynomial = 2*x().pow(2) + 1;
// Evaluate p at 2:
println!(&quot;{:?}&quot;, p(2));

FieldElement(9)
</code></pre>
<h1 id="interpolating-a-polynomial-1"><a class="header" href="#interpolating-a-polynomial-1">Interpolating a Polynomial</a></h1>
<p>Our <code>+Polynomial+</code> datatype provides a Lagrange interpolation method,
whose arguments are:</p>
<ul>
<li>
<p>x_values: x-values of G that the polynomial’s values for them is
known. &amp;[FieldElement]</p>
</li>
<li>
<p>y_values: the corresponding y-values. &amp;[FieldElement]</p>
</li>
</ul>
<p>It returns the unique <code>+Polynomial+</code> of degree &lt; <code>+x_values.len()+</code>
instance that evaluates to <code>+y_values[i]+</code> on <code>+x_values[i]+</code> for all i.</p>
<p>Suppose that <code>+a+</code> contains the values of some polynomial over <code>+G+</code>
(except for <code>+G[-1]+</code>, since <code>+a+</code> is one element shorter). Use
<code>+Polynomial::interpolate()+</code> to get <code>+f+</code> and get its value at
<code>+FieldElement::new(2)+</code>.</p>
<pre><code>// Fix the following so that you create a variable called v that will contain the value of f at FieldElement(2)
// Note that Polynomial::interpolate may take up to a minute to run.
todo!(&quot;Put your code here.&quot;);

thread '&lt;unnamed&gt;' panicked at 'not yet implemented: Put your code here.', src/lib.rs:162:1
stack backtrace:
   0: _rust_begin_unwind
   1: core::panicking::panic_fmt
   2: &lt;unknown&gt;
   3: &lt;unknown&gt;
   4: evcxr::runtime::Runtime::run_loop
   5: evcxr::runtime::runtime_hook
   6: evcxr_jupyter::main
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p>Solution:</p>
<pre><code>let xs: Vec&lt;FieldElement&gt; = G.into_iter().rev().skip(1).rev().collect();
let f: Polynomial = Polynomial::interpolate(&amp;xs, &amp;a);
let v = f(2);
</code></pre>
<p>Run test:</p>
<pre><code>assert_eq!(v, FieldElement::new(1302089273));
println!(&quot;Success!&quot;);

Success!
</code></pre>
<h1 id="evaluating-on-a-larger-domain-1"><a class="header" href="#evaluating-on-a-larger-domain-1">Evaluating on a Larger Domain</a></h1>
<p>The trace, viewed as evaluations of a polynomial on , can now be
extended by evaluating over a larger domain, thereby creating a
<strong>Reed-Solomon error correction code</strong>.</p>
<h2 id="cosets-1"><a class="header" href="#cosets-1">Cosets</a></h2>
<p>To that end, we must decide on a larger domain on which will be
evaluated. We will work with a domain that is 8 times larger than . A
natural choice for such a domain is to take some group of size 8192
(which exists because 8192 divides ), and shift it by the generator of ,
thereby obtaining a <a href="https://en.wikipedia.org/wiki/Coset">coset</a> of .</p>
<p>Create a vec called <code>+H+</code> of the elements of , and multiply each of them
by the generator of to obtain a vec called <code>+eval_domain+</code>. In other
words, eval_domain = for the generator of and the generator of .</p>
<p>Hint: You already know how to obtain - similarly to the way we got a few
minutes ago.</p>
<pre><code>// Fix the following, make sure that the element of H are powers of its generator (let's call it h) in
// order, that is - H[0] will be the unit (i.e 1), H[1] will be h (H's generator), H[2] will be H's
// generator squared (h^2), etc.
let h: FieldElement = todo!();
let H: Vec&lt;FieldElement&gt; = todo!();
let eval_domain: Vec&lt;FieldElement&gt; = todo!();

thread '&lt;unnamed&gt;' panicked at 'not yet implemented', src/lib.rs:160:23
stack backtrace:
   0: _rust_begin_unwind
   1: core::panicking::panic_fmt
   2: core::panicking::panic
   3: &lt;unknown&gt;
   4: &lt;unknown&gt;
   5: evcxr::runtime::Runtime::run_loop
   6: evcxr::runtime::runtime_hook
   7: evcxr_jupyter::main
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p>Solution:</p>
<pre><code>let w = FieldElement::generator();
let exp = (2usize.pow(30) * 3) / 8192;
let h = w.pow(exp);
let H: Vec&lt;FieldElement&gt; = (0..8192).into_iter().map(|i| h.pow(i)).collect();
let eval_domain: Vec&lt;FieldElement&gt; = H.into_iter().map(|x| w * x).collect();
</code></pre>
<p>Run test:</p>
<pre><code>let field_generator = FieldElement::generator();
let w_inverse = w.inverse();

for i in 0..8192 {
    assert_eq!((w_inverse * eval_domain[1]).pow(i) * field_generator, eval_domain[i]);
}
println!(&quot;Success!&quot;);

Success!
</code></pre>
<h1 id="evaluate-on-a-coset-1"><a class="header" href="#evaluate-on-a-coset-1">Evaluate on a Coset</a></h1>
<p>Time to use <code>+interpolate+</code> and <code>+eval+</code> to evaluate over the coset.
Note that it is implemented fairly naively in our Rust module, so
interpolation may take some seconds. Indeed - interpolating and
evaluating the trace polynomial is one of the most
computationally-intensive steps in the STARK protocol, even when using
more efficient methods (e.g. FFT).</p>
<pre><code>// Fill f_eval with the evaluations of f on eval_domain.
let f_eval: FieldElement = todo!();

thread '&lt;unnamed&gt;' panicked at 'not yet implemented', src/lib.rs:162:28
stack backtrace:
   0: _rust_begin_unwind
   1: core::panicking::panic_fmt
   2: core::panicking::panic
   3: &lt;unknown&gt;
   4: &lt;unknown&gt;
   5: evcxr::runtime::Runtime::run_loop
   6: evcxr::runtime::runtime_hook
   7: evcxr_jupyter::main
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p>Solution:</p>
<pre><code>let G_values: Vec&lt;FieldElement&gt; = (0..1024).into_iter().map(|i| g.pow(i)).collect();;
let x_values: Vec&lt;FieldElement&gt; = G_values.into_iter().rev().skip(1).rev().collect();
let interpolated_f: Polynomial = Polynomial::interpolate(&amp;x_values, &amp;a);
let interpolated_f_eval: Vec&lt;FieldElement&gt; = eval_domain.into_iter().map(|d| interpolated_f.clone().eval(d)).collect();
</code></pre>
<p>Run test:</p>
<pre><code>// Test against a precomputed hash.
use sha256::digest;
let hashed = digest(format!(&quot;{:?}&quot;, interpolated_f_eval));
assert_eq!(&quot;d78b6a5f70e91dd8fa448f628528434dbfaf3caefab0a26519e1f2d8ac992f23&quot;.to_string(), hashed);
println!(&quot;Success!&quot;);

Success!
</code></pre>
<h1 id="commitments-1"><a class="header" href="#commitments-1">Commitments</a></h1>
<p>We will use <a href="https://en.wikipedia.org/wiki/SHA-2">Sha256</a>-based <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle
Trees</a> as our commitment
scheme. A simple implementation of it is available to you in the
<code>+MerkleTree+</code> class. Run the next cell (for the sake of this tutorial,
this also serves as a test for correctness of the entire computation so
far):</p>
<pre><code>//from merkle import MerkleTree
//f_merkle = MerkleTree(f_eval)
//assert f_merkle.root == '6c266a104eeaceae93c14ad799ce595ec8c2764359d7ad1b4b7c57a4da52be04'
//print('Success!')
</code></pre>
<h1 id="channel-1"><a class="header" href="#channel-1">Channel</a></h1>
<p>Theoretically, a STARK proof system is a protocol for interaction
between two parties - a prover and a verifier. In practice, we convert
this interactive protocol into a non-interactive proof using the
<a href="https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic">Fiat-Shamir
Heuristic</a>.
In this tutorial you will use the <code>+Channel+</code> class, which implements
this transformation. This channel replaces the verifier in the sense
that the prover (which you are writing) will send data, and receive
random numbers or random <code>+FieldElement+</code> instances.</p>
<p>This simple piece of code instantiates a channel object, sends the root
of your Merkle Tree to it. Later, the channel object can be called to
provide random numbers or random field elements.</p>
<pre><code>///from channel import Channel
//channel = Channel()
//channel.send(f_merkle.root)
</code></pre>
<p>Lastly - you can retrieve the proof-so-far (i.e., everything that was
passed in the channel up until a certain point) by printing the member
<code>+Channel.proof+</code>.</p>
<pre><code>//print(channel.proof)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><em>Copyright 2019 StarkWare Industries Ltd. Licensed under the Apache
License, Version 2.0 (the &quot;License&quot;). You may not use this file except
in compliance with the License. You may obtain a copy of the License at
<a href="https://www.starkware.co/open-source-license/">https://www.starkware.co/open-source-license/</a> Unless required by
applicable law or agreed to in writing, software distributed under the
License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License.</em></p>
<h1 id="part-2-constraints-1"><a class="header" href="#part-2-constraints-1">Part 2: Constraints</a></h1>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=fg3mFPXEYQY">Video Lecture
(youtube)</a></p>
</li>
<li>
<p><a href="https://starkware.co/wp-content/uploads/2021/12/STARK101-Part2.pdf">Slides
(PDF)</a></p>
</li>
</ul>
<p>In this part, we are going to create a set of constraints over the trace
<code>a</code>. The constraints will be expressions in the trace’s cells that are
polynomials (rather than <a href="https://en.wikipedia.org/wiki/Rational_function">rational
functions</a>) if and only
if the trace represents a valid computation of the FibonacciSq. We will
get there in three steps:</p>
<ol>
<li>
<p>Start by specifying the constraints we care about (the <strong>FibonacciSq
constraints</strong>).</p>
</li>
<li>
<p>Translate the FibonacciSq constraints into <strong>polynomial
constraints</strong>.</p>
</li>
<li>
<p>Translate those into <strong>rational functions</strong> that represent
polynomials if and only if the original constraints hold.</p>
</li>
</ol>
<h1 id="step-1---fibonaccisq-constraints-1"><a class="header" href="#step-1---fibonaccisq-constraints-1">Step 1 - FibonacciSq Constraints</a></h1>
<p>For <code>a</code> to be a correct trace of a FibonacciSq sequence that proves our
claim:</p>
<ol>
<li>
<p>The first element has to be 1, namely = 1].</p>
</li>
<li>
<p>The last element has to be 2338775057, namely = 2338775057].</p>
</li>
<li>
<p>The FibonacciSq rule must apply, that is - for every ,
[i+2]=a[i+1]²+a[i]².</p>
</li>
</ol>
<h1 id="step-2---polynomial-constraints-1"><a class="header" href="#step-2---polynomial-constraints-1">Step 2 - Polynomial Constraints</a></h1>
<p>Recall that <code>f</code> is a polynomial over the trace domain, that evaluates
exactly to <code>a</code> over where is the &quot;small&quot; group generated by .</p>
<p>We now rewrite the above three constraints in a form of polynomial
constraints over <code>f</code>:</p>
<ol>
<li>
<p>= 1] is translated to the polynomial , which evalutes to 0 for
(note that is ).</p>
</li>
<li>
<p>= 2338775057] is translated to the polynomial , which evalutes to 0
for .</p>
</li>
<li>
<p>[i+2]=a[i+1]²+a[i]² for every is translated to the polynomial
, which evaluates to 0 for .</p>
</li>
</ol>
<h1 id="hands-on-1"><a class="header" href="#hands-on-1">Hands on</a></h1>
<p>First, since this is a separate notebook from Part 1, let’s run the
following piece of code to have all the variables here with their
correct values. Note that it may take up to 30 seconds, since it reruns
the polynomial interpolation.</p>
<pre><code>:dep stark101-rs = { path = &quot;stark101&quot; }
:dep sha256 = &quot;1.1.2&quot;
use stark101_rs::{field::FieldElement, channel::Channel, polynomial::{Polynomial, x}};
use stark101_rs::parts::part1();

let (a, g, G, h, H, eval_domain, f, f_eval, f_merkle, channel) = part1();
println!(&quot;Success!&quot;);

Success!
</code></pre>
<p>You will obtain each of the three constraints as a quotient of two
polynomials, making sure the remainder is the zero polynomial.</p>
<h1 id="step-3---rational-functions-that-are-in-fact-polynomials-1"><a class="header" href="#step-3---rational-functions-that-are-in-fact-polynomials-1">Step 3 - Rational Functions (That are in Fact Polynomials)</a></h1>
<p>Each of the constraints above is represented by a polynomial that
supposedly evaluates to on certain elements of the group . That is, for
some , we claim that</p>
<p>(note that for the first two constaints, because they only refer to one
point and for the third ).</p>
<p>This is equivalent to saying that is divisible, as a polynomial, by all
of , or, equivalently, by</p>
<p>Therefore, each of the three constraints above can be written as a
rational function of the form:</p>
<p>for the corresponding and . In this step we will construct these three
rational functions and show that they are indeed polynomials.</p>
<h1 id="the-first-constraint-1"><a class="header" href="#the-first-constraint-1">The First Constraint:</a></h1>
<p>In the first constraint, and .</p>
<p>We will now construct the <strong>polynomial</strong> , making sure that is indeed
divisible by .</p>
<pre><code>// First constraint. Construct numer0 and denom0.
let numer0: Polynomial = todo!();
let denom0: Polynomial = todo!();
</code></pre>
<p>Solution:</p>
<pre><code>let numer0: Polynomial = f.clone() - FieldElement::one();
let denom0: Polynomial = x() - FieldElement::one();
</code></pre>
<p>Convince yourself that vanishes at by making sure that evaluating this
polynomial at yields :</p>
<pre><code>todo!(&quot;You should evaluate f(x) - 1 at x = 1&quot;);
</code></pre>
<p>The fact that has a root at implies that it is divisible by . Run the
following cell to convince yourself that the remainder of <code>numer0</code>
modulo <code>denom0</code> is , and therefore division indeed yields a polynomial:</p>
<pre><code>numer0.clone() % denom0.clone()

Polynomial([])
</code></pre>
<p>Run the following cell to construct <code>p0</code>, the polynomial representing
the first constraint, by dividing <code>numer0</code> by <code>denom0</code>:</p>
<pre><code>let p0: Polynomial = numer0 / denom0;
</code></pre>
<p>Run test:</p>
<pre><code>assert_eq!(p0(2718), 2509888982);
println!(&quot;Success!&quot;);

Success!
</code></pre>
<h1 id="the-second-constraint-1"><a class="header" href="#the-second-constraint-1">The Second Constraint</a></h1>
<p>Construct the polynomial <code>p1</code> representing the second constraint, ,
similarly:</p>
<pre><code>// Second constraint.
let p1: Polynomial = todo!();
</code></pre>
<p>Solution:</p>
<pre><code>let numer1: Polynomial = f.clone() - FieldElement::new(2338775057);
let denom1: Polynomial = x() - g.pow(1022usize);
let p1: Polynomial = numer1 / denom1.clone();
</code></pre>
<p>Run test:</p>
<pre><code>assert_eq!(p1(5772), 232961446);
println!(&quot;Success!&quot;);

Success!
</code></pre>
<h1 id="the-third-constraint---succinctness-1"><a class="header" href="#the-third-constraint---succinctness-1">The Third Constraint - Succinctness</a></h1>
<p>The last constraint’s rational function is slightly more complicated:</p>
<p>whose denominator can be rewritten, so that the entire expression is
easier to compute:</p>
<p>This follows from the equality</p>
<p>Convince yourself of this equality using the function <code>prod</code> that takes
a list and computes its product:</p>
<pre><code>// Construct a list `lst` of the linear terms (x-g**i):
let lst: Vec&lt;Polynomial&gt; = todo!();
// Compute the product of `lst` and see that it is indeed the succinct polynomial x**1024 - 1
Polynomial::prod(&amp;lst);

thread '&lt;unnamed&gt;' panicked at 'not yet implemented', src/lib.rs:134:28
stack backtrace:
   0: _rust_begin_unwind
   1: core::panicking::panic_fmt
   2: core::panicking::panic
   3: &lt;core::panic::unwind_safe::AssertUnwindSafe&lt;F&gt; as core::ops::function::FnOnce&lt;()&gt;&gt;::call_once
   4: _run_user_code_14
   5: evcxr::runtime::Runtime::run_loop
   6: evcxr::runtime::runtime_hook
   7: evcxr_jupyter::main
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p>Solution:</p>
<pre><code>let lst: Vec&lt;Polynomial&gt; = (0..1024).into_iter().map(|i| x() - g.pow(i)).collect();
Polynomial::prod(&amp;lst)

Polynomial([FieldElement(3221225472), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(1)])
</code></pre>
<p>For more information, see our blog post titled <a href="https://medium.com/starkware/arithmetization-ii-403c3b3f4355">Arithmetization
II</a>.</p>
<p>Let’s pause for a moment, and look at a simple example on how
polynomials are composed. After that we will generate the third
constraint.</p>
<h1 id="composing-polynomials-a-detour-1"><a class="header" href="#composing-polynomials-a-detour-1">Composing Polynomials (a detour)</a></h1>
<p>Create the two polynomials , :</p>
<pre><code>let q: Polynomial = x().pow(2)*2usize + 1;
let r = x() - 3usize;
</code></pre>
<p>Composing on yields a new polynomial: Run the following cell to create a
third polynomial <code>cmp</code> by composing <code>q</code> on <code>r</code> and convince yourself
that <code>cmp</code> is indeed the composition of <code>q</code> and <code>r</code>:</p>
<pre><code>let cmp = q(r);
cmp

Polynomial([FieldElement(19), FieldElement(3221225461), FieldElement(2)])
</code></pre>
<h1 id="back-to-polynomial-constraints-1"><a class="header" href="#back-to-polynomial-constraints-1">Back to Polynomial Constraints</a></h1>
<p>Construct the third constraint <code>p2</code> in a similar manner to the
construction of <code>p0</code> and <code>p1</code>, using polynomial composition. Along the
way, verify that is a root of the <strong>numerator</strong> while is not.</p>
<pre><code>let p2: Polynomial = todo!();
</code></pre>
<p>Solution:</p>
<pre><code>let numer_1: Polynomial = f(x() * g.pow(2));
let numer_2: Polynomial = f(x() * g).pow(2) * FieldElement::new((-1 + FieldElement::k_modulus() as i128) as usize);
let numer_3: Polynomial = f.pow(2) * FieldElement::new((-1 + FieldElement::k_modulus() as i128) as usize);
let numer2: Polynomial = numer_1 + numer_2 + numer_3;
println!(&quot;Numerator at g^1020 is {:?}&quot;, numer2.clone()(g.pow(1020)));
println!(&quot;Numerator at g^1021 is {:?}&quot;, numer2(g.pow(1021usize)));
let denom2 = (x().pow(1024usize) - 1) / ((x() - g.pow(1021)) * (x() - g.pow(1022)) * (x() - g.pow(1023)));

let p2: Polynomial = numer2 / denom2;

Numerator at g^1020 is FieldElement(0)
Numerator at g^1021 is FieldElement(230576507)
</code></pre>
<p>Run test:</p>
<pre><code>let p2_degree = p2.degree();
assert_eq!(p2.degree(), 1023, &quot;The degree of the third constraint is {p2_degree} when it should be 1023.&quot;);
assert_eq!(p2(31415), 2090051528);
println!(&quot;Success!&quot;);

Success!
</code></pre>
<p>Run the following cell to observe the degrees of the constraint
polynomials <code>p0</code>, <code>p1</code> and <code>p2</code>, all less than . This will be important
in the next part.</p>
<pre><code>println!(&quot;deg p0 = {}&quot;, p0.degree());
println!(&quot;deg p1 = {}&quot;, p1.degree());
println!(&quot;deg p2 = {}&quot;, p2.degree());

deg p0 = 1021
deg p1 = 1021
deg p2 = 1023
</code></pre>
<h1 id="step-4---composition-polynomial-1"><a class="header" href="#step-4---composition-polynomial-1">Step 4 - Composition Polynomial</a></h1>
<p>Recall that we’re translating a problem of checking the validity of
three polynomial constraints to checking that each of the rational
functions are polynomials.</p>
<p>Our protocol uses an algorithm called
<a href="https://eccc.weizmann.ac.il/report/2017/134/">FRI</a> to do so, which will
be discussed in the next part. In order for the proof to be succinct
(short), we prefer to work with just one rational function instead of
three. For that, we take a random linear combination of called the
<strong>compostion polynomial</strong> (CP for short):</p>
<p>where are random field elements obtained from the verifier, or in our
case - from the channel.</p>
<p>Proving that (the rational function) is a polynomial guarantees, with
high probability, that each of , , are themselves polynomials.</p>
<p>In the next part, you will generate a proof for an equivalent fact. But
first, let’s create <code>CP</code> using <code>Channel.receive_random_field_element</code> to
obtain :</p>
<pre><code>// Note that alpha0, alpha1, alpha2 have to be drawn from the channel in this order.
fn get_CP(p1: Polynomial, p2: Polynomial, p3: Polynomial, channel: Channel) -&gt; Polynomial {
    todo!();
}
</code></pre>
<p>Solution:</p>
<pre><code>fn get_CP(p0: Polynomial, p1: Polynomial, p2: Polynomial, channel: &amp;mut Channel) -&gt; Polynomial {
    let alpha0 = channel.receive_random_field_element();
    let alpha1 = channel.receive_random_field_element();
    let alpha2 = channel.receive_random_field_element();
    (p0 * alpha0) + (p1 * alpha1) + (p2 * alpha2)
}
</code></pre>
<p>Run test:</p>
<pre><code>let mut test_channel: Channel = Channel::new();
let cp_test = get_CP(p0, p1, p2, &amp;mut test_channel);
let cp_test_degree = cp_test.degree();
assert_eq!(cp_test.degree(), 1023, &quot;The degree of cp is {cp_test_degree} when it should be 1023.&quot;);
let expected = cp_test(2439804);
assert_eq!(cp_test(2439804), 838767343, &quot;cp(2439804) = {expected:?}, when it should be 838767343&quot;);
println!(&quot;Success!&quot;);

Success!
</code></pre>
<h1 id="commit-on-the-composition-polynomial-1"><a class="header" href="#commit-on-the-composition-polynomial-1">Commit on the Composition Polynomial</a></h1>
<p>Lastly, we evaluate over the evaluation domain (<code>eval_domain</code>), build a
Merkle tree on top of that and send its root over the channel. This is
similar to committing on the LDE trace, as we did at the end of part 1.</p>
<pre><code>// Fix this. CP_eval is the evaluation of CP on all the points in domain. For a hint - look at &quot;Evaluate on a Coset&quot; on part 1.
fn cp_eval(p0: Polynomial, p1: Polynomial, p2: Polynomial, domain: Vec&lt;FieldElement&gt;, channel: &amp;mut Channel) {
    let cp = get_CP(p0, p1, p2, channel);
    todo!();
}
</code></pre>
<p>Solution:</p>
<pre><code>fn cp_eval(p0: Polynomial, p1: Polynomial, p2: Polynomial, domain: Vec&lt;FieldElement&gt;, channel: &amp;mut Channel) -&gt; Vec&lt;FieldElement&gt; {
    let cp = get_CP(p0, p1, p2, channel);
    domain.into_iter().map(|d| cp(d)).collect()
}
</code></pre>
<p>Construct a Merkle Tree over the evaluation and send its root over the
channel.</p>
<pre><code>let channel = Channel::new();
let cp_merkle = MerkleTree::new(todo!()); // Fix this line
channel.send(cp_merkle.root);
</code></pre>
<p>Solution:</p>
<pre><code>use stark101_rs::merkle_tree::MerkleTree;
let mut channel = Channel::new();
let cp_merkle: MerkleTree = MerkleTree::new(cp_eval(p0, p1, p2, eval_domain, &amp;mut channel));
channel.send(cp_merkle.root());
</code></pre>
<p>Test your code:</p>
<pre><code>assert_eq!(cp_merkle.root(), &quot;26db4de93f69af9591eac0bf224a26f5ffd99d07a325b82ee34381069a205a53&quot;, &quot;Merkle tree root is wrong.&quot;);
println!(&quot;Success!&quot;);

Success!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><em>Copyright 2019 StarkWare Industries Ltd. Licensed under the Apache
License, Version 2.0 (the &quot;License&quot;). You may not use this file except
in compliance with the License. You may obtain a copy of the License at
<a href="https://www.starkware.co/open-source-license/">https://www.starkware.co/open-source-license/</a> Unless required by
applicable law or agreed to in writing, software distributed under the
License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License.</em></p>
<h1 id="part-3-fri-commitments-1"><a class="header" href="#part-3-fri-commitments-1">Part 3: FRI Commitments</a></h1>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=gd1NbKUOJwA">Video Lecture
(youtube)</a></p>
</li>
<li>
<p><a href="https://starkware.co/wp-content/uploads/2021/12/STARK101-Part3.pdf">Slides
(PDF)</a></p>
</li>
</ul>
<h1 id="load-previous-session-1"><a class="header" href="#load-previous-session-1">Load Previous Session</a></h1>
<p>Run the next cell to load the relevant variables. As usual - it will
take a while to run.</p>
<pre><code>:dep stark101-rs = { path = &quot;stark101&quot; }
:dep sha256 = &quot;1.1.2&quot;
use stark101_rs::{field::FieldElement, channel::Channel, polynomial::{Polynomial, x}, merkle_tree::MerkleTree};
use stark101_rs::parts::part2;

let (cp, cp_eval, cp_merkle, channel, eval_domain) = part2();
println!(&quot;Success!&quot;);

Success!
</code></pre>
<h1 id="fri-folding-1"><a class="header" href="#fri-folding-1">FRI Folding</a></h1>
<p>Our goal in this part is to construct the FRI layers and commit on them.
To obtain each layer we need:</p>
<ol>
<li>
<p>To generate a domain for the layer (from the previous layer’s
domain).</p>
</li>
<li>
<p>To generate a polynomial for the layer (from the previous layer’s
polynomial and domain).</p>
</li>
<li>
<p>To evaluate said polynomial on said domain - <strong>this is the next FRI
layer</strong>.</p>
</li>
</ol>
<h1 id="domain-generation-1"><a class="header" href="#domain-generation-1">Domain Generation</a></h1>
<p>The first FRI domain is simply the <code>eval_domain</code> that you already
generated in Part 1, namely a coset of a group of order 8192. Each
subsequent FRI domain is obtained by taking the first half of the
previous FRI domain (dropping the second half), and squaring each of its
elements.</p>
<p>Formally - we got <code>eval_domain</code> by taking:</p>
<p>The next layer will therefore be:</p>
<p>Note that taking the squares of the second half of each elements in
<code>eval_domain</code> yields exactly the same result as taking the squares of
the first half. This is true for the next layers as well. For example:</p>
<pre><code>println!(&quot;{:?}&quot;, eval_domain[100].pow(2));
let half_domain_size: usize = eval_domain.len() / 2;
println!(&quot;{:?}&quot;, eval_domain[half_domain_size + 100].pow(2));

FieldElement(2848063603)
FieldElement(2848063603)
</code></pre>
<p>Similarly, the domain of the third layer will be:</p>
<p>And so on.</p>
<p>Write a function <code>next_fri_domain</code> that takes the previous domain as an
argument, and outputs the next one.</p>
<pre><code>fn next_fri_domain(fri_domain: Vec&lt;FieldElement&gt;) -&gt; Vec&lt;FieldElement&gt; {
    // Fix this.
}
</code></pre>
<p>Solution:</p>
<pre><code>fn next_fri_domain(fri_domain: Vec&lt;FieldElement&gt;) -&gt; Vec&lt;FieldElement&gt; {
    let fri_domain_len = fri_domain.len();
    fri_domain.into_iter().take(fri_domain_len / 2).map(|x| x.pow(2)).collect()
}
</code></pre>
<p>Run test:</p>
<pre><code>// Test against a precomputed hash.
let next_domain = next_fri_domain(eval_domain);
assert_eq!(&quot;5446c90d6ed23ea961513d4ae38fc6585f6614a3d392cb087e837754bfd32797&quot;, sha256(','.join([str(i) for i in next_domain]).encode()).hexdigest());
println!(&quot;Success!&quot;);

Error: expected `;`, found `println`
   ╭─[command_5:1:1]
   │
 3 │ assert_eq!(&quot;5446c90d6ed23ea961513d4ae38fc6585f6614a3d392cb087e837754bfd32797&quot;, sha256(','.join([str(i) for i in next_domain]).encode()).hexdigest())
   ·                                                                                                                                                     │
   ·                                                                                                                                                     ╰─ error: expected `;`, found `println`
   ·                                                                                                                                                     │
   ·                                                                                                                                                     ╰─ help: add `;` here: `;`
 4 │ println!(&quot;Success!&quot;);
   · ───┬───
   ·    ╰───── unexpected token
───╯
</code></pre>
<h1 id="fri-folding-operator-1"><a class="header" href="#fri-folding-operator-1">FRI Folding Operator</a></h1>
<p>The first FRI polynomial is simply the composition polynomial, i.e.,
<code>cp</code>. Each subsequent FRI polynomial is obtained by:</p>
<ol>
<li>
<p>Getting a random field element (by calling
<code>Channel.receive_random_field_element</code>).</p>
</li>
<li>
<p>Multiplying the odd coefficients of the previous polynomial by .</p>
</li>
<li>
<p>Summing together consecutive pairs (even-odd) of coefficients.</p>
</li>
</ol>
<p>Formally, let’s say that the k-th polynomial is of degree (for some
which is a power of 2):</p>
<p>Then the (k+1)-th polynomial, whose degree is will be:</p>
<p>Write a function <code>next_fri_polynomial</code> that takes as arguments a
polynomial and a field element (the one we referred to as ), and returns
the &quot;folded&quot; next polynomial.</p>
<p>Note that:</p>
<ol>
<li>
<p><code>Polynomial.poly</code> contains a list of a polynomial’s coefficients,
the free term first, and the highest degree last, so
<code>p.poly[i] == u</code> if the coefficient of is .*</p>
</li>
<li>
<p><code>Polynomial</code>'s default constructor takes the list of coefficients as
argument. So a polynomial can be instantiated from a list of
coefficients <code>l</code> by calling <code>Polynomial(l)</code>.</p>
</li>
</ol>
<!-- -->
<pre><code>fn next_fri_polynomial(poly: Polynomial, beta: FieldElement) -&gt; Polynomial {
    let odd_coefficients = poly.poly[1::2]; // fix this line.
    let even_coefficients = poly.poly[::2]; // No need to fix this line either.
    let multiplied_by_beta: Vec&lt;FieldElement&gt; = odd_coefficients.into_iter().map(|c| c * beta).collect();
    let odd = Polynomial::new(&amp;multiplied_by_beta);
    let even = Polynomial(even_coefficients);
    odd + even
}

Error: expected one of `.`, `?`, `]`, or an operator, found `::`
   ╭─[command_39:1:1]
   │
 2 │     let odd_coefficients = poly.poly[1::2]; // fix this line.
   ·                                       ─┬
   ·                                        ╰── expected one of `.`, `?`, `]`, or an operator
───╯
</code></pre>
<p>Solution:</p>
<pre><code>fn next_fri_polynomial(poly: Polynomial,  beta: FieldElement) -&gt; Polynomial {
    let odd_coefficients: Vec&lt;FieldElement&gt; = poly.0.clone().into_iter().skip(1).step_by(2).collect();
    let even_coefficients: Vec&lt;FieldElement&gt; = poly.0.into_iter().step_by(2).collect();
    let odd = Polynomial::new(&amp;odd_coefficients) * beta;
    let even = Polynomial::new(&amp;even_coefficients);
    odd + even
}
</code></pre>
<p>Run test:</p>
<pre><code>let next_p = next_fri_polynomial(cp, FieldElement::new(987654321));
assert_eq!(&quot;6bff4c35e1aa9693f9ceb1599b6a484d7636612be65990e726e52a32452c2154&quot;, sha256(','.join([str(i) for i in next_p.poly]).encode()).hexdigest());
println!(&quot;Success!&quot;);

Success!
</code></pre>
<h1 id="putting-it-together-to-get-the-next-fri-layer-1"><a class="header" href="#putting-it-together-to-get-the-next-fri-layer-1">Putting it Together to Get the Next FRI Layer</a></h1>
<p>Write a function <code>next_fri_layer</code> that takes a polynomial, a domain, and
a field element (again - ), and returns the next polynomial, the next
domain, and the evaluation of this next polynomial on this next domain.</p>
<pre><code>fn next_fri_layer(poly: Polynomial, domain: Vec&lt;FieldElement&gt;, beta: FieldElement) -&gt; (Polynomial, Vec&lt;FieldElement&gt;, Vec&lt;FieldElement&gt;) {
    todo!()
}
</code></pre>
<p>Solution:</p>
<pre><code>fn next_fri_layer(poly: Polynomial, domain: Vec&lt;FieldElement&gt;, beta: FieldElement) -&gt; (Polynomial, Vec&lt;FieldElement&gt;, Vec&lt;FieldElement&gt;) {
    let next_poly = next_fri_polynomial(poly, beta);
    let next_domain = next_fri_domain(domain);
    let next_layer: Vec&lt;FieldElement&gt; = next_domain.clone().into_iter().map(|x| next_poly(x)).collect();
    (next_poly, next_domain, next_layer)
}
</code></pre>
<p>Run test:</p>
<pre><code>let test_poly = Polynomial::new(&amp;[FieldElement::new(2), FieldElement::new(3), FieldElement::new(0), FieldElement::new(1)]);
let test_domain = vec![FieldElement::new(3), FieldElement::new(5)];
let beta = FieldElement::new(7);
let (next_p, next_d, next_l) = next_fri_layer(test_poly, test_domain, beta);
assert_eq!(next_p, Polynomial::new(&amp;[FieldElement::new(23), FieldElement::new(7)]));
assert_eq!(next_d, vec![FieldElement::new(9)]);
assert_eq!(next_l, vec![FieldElement::new(86)]);
println!(&quot;Success!&quot;);

Success!
</code></pre>
<h1 id="generating-fri-commitments-1"><a class="header" href="#generating-fri-commitments-1">Generating FRI Commitments</a></h1>
<p>We have now developed the tools to write the <code>FriCommit</code> method, that
contains the main FRI commitment loop.</p>
<p>It takes the following 5 arguments:</p>
<ol>
<li>
<p>The composition polynomial, that is also the first FRI polynomial,
that is - <code>cp</code>.</p>
</li>
<li>
<p>The coset of order 8192 that is also the first FRI domain, that is -
<code>eval_domain</code>.</p>
</li>
<li>
<p>The evaluation of the former over the latter, which is also the
first FRI layer , that is - <code>cp_eval</code>.</p>
</li>
<li>
<p>The first Merkle tree (we will have one for each FRI layer)
constructed from these evaluations, that is - <code>cp_merkle</code>.</p>
</li>
<li>
<p>A channel object, that is <code>channel</code>.</p>
</li>
</ol>
<p>The method accordingly returns 4 lists:</p>
<ol>
<li>
<p>The FRI polynomials.</p>
</li>
<li>
<p>The FRI domains.</p>
</li>
<li>
<p>The FRI layers.</p>
</li>
<li>
<p>The FRI Merkle trees.</p>
</li>
</ol>
<p>The method contains a loop, in each iteration of which we extend these
four lists, using the last element in each. The iteration should stop
once the last FRI polynomial is of degree 0, that is - when the last FRI
polynomial is just a constant. It should then send over the channel this
constant (i.e. - the polynomial’s free term). The <code>Channel</code> class only
supports sending strings, so make sure you convert anything you wish to
send over the channel to a string before sending.</p>
<pre><code>// Fix this according to the instructions (lines with no specific comments are okay).
fn fri_commit(cp, domain, cp_eval, cp_merkle, channel) -&gt; (Vec&lt;Polynomial&gt;, Vec&lt;Vec&lt;FieldElement&gt;&gt;, Vec&lt;Vec&lt;FieldElement&gt;&gt;, Vec&lt;MerkleTree&gt;) {
    let fri_polys: Vec&lt;Polynomial&gt; = vec![cp];
    let fri_domains: Vec&lt;Vec&lt;FieldElement&gt;&gt; = vec![domain];
    let fri_layers: Vec&lt;Vec&lt;FieldElement&gt;&gt; = vec![cp_eval];
    let fri_merkles: Vec&lt;MerkleTree&gt; = vec![cp_merkle];
    while cp.degree() &gt; 1 { // Replace this with the correct halting condition.
        let beta = channel.receive_random_field_element(); // Change to obtain a random element from the channel.
        let (next_poly, next_domain, next_layer) = next_fri_layer(cp, domain, beta); // Fix to obtain the next FRI polynomial, domain, and layer.
        fri_polys.push(next_poly);
        fri_domains.push(next_domain);
        fri_layers.push(next_layer);
        fri_merkles.push(MerkleTree::new(next_layer)); // Fix to construct the correct Merkle tree.
        channel.send(fri_merkles.last().unwrap().root()); // Fix to send the correct commitment.
    }
    channel.send(fri_polys.last().unwrap()) // Fix to send the last layer's free term.
    (fri_polys, fri_domains, fri_layers, fri_merkles)
}
</code></pre>
<p>Solution:</p>
<pre><code>fn fri_commit(cp: Polynomial, domain: Vec&lt;FieldElement&gt;, cp_eval: Vec&lt;FieldElement&gt;, cp_merkle: MerkleTree, channel: &amp;mut Channel) -&gt; (Vec&lt;Polynomial&gt;, Vec&lt;Vec&lt;FieldElement&gt;&gt;, Vec&lt;Vec&lt;FieldElement&gt;&gt;, Vec&lt;MerkleTree&gt;) {
    let mut fri_polys: Vec&lt;Polynomial&gt; = vec![cp];
    let mut fri_domains: Vec&lt;Vec&lt;FieldElement&gt;&gt; = vec![domain];
    let mut fri_layers: Vec&lt;Vec&lt;FieldElement&gt;&gt; = vec![cp_eval];
    let mut fri_merkles: Vec&lt;MerkleTree&gt; = vec![cp_merkle];
    while fri_polys.last().unwrap().degree() &gt; 0 {
        let beta = channel.receive_random_field_element();
        let last_poly = fri_polys.last().unwrap().clone();
        let last_domain = fri_domains.last().unwrap().clone();
        let (next_poly, next_domain, next_layer) = next_fri_layer(last_poly, last_domain, beta);
        fri_polys.push(next_poly.clone());
        fri_domains.push(next_domain.clone());
        fri_layers.push(next_layer.clone());
        fri_merkles.push(MerkleTree::new(next_layer));
        channel.send(fri_merkles.last().unwrap().root())
    }
    channel.send(fri_polys.last().unwrap().0[0].0.to_string());

    (fri_polys, fri_domains, fri_layers, fri_merkles)
}
</code></pre>
<p>Run test:</p>
<pre><code>let mut test_channel = Channel::new();
let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp.clone(), eval_domain.clone(), cp_eval.clone(), cp_merkle.clone(), &amp;mut test_channel);
let fri_layers_len = fri_layers.len();
assert_eq!(fri_layers_len, 11, &quot;Expected number of FRI layers is 11, whereas it is actually {fri_layers_len}&quot;);
assert_eq!(fri_layers.last().unwrap().len(), 8, &quot;Expected last layer to contain exactly 8 elements&quot;);
assert_eq!(fri_polys.last().unwrap().degree(), 0, &quot;Expected last polynomial to be constant (degree 0).&quot;);
assert_eq!(fri_merkles.last().unwrap().root(), &quot;6e09c7e19275df2155bd575833aa441f3058446726938420c0acabb1c332c40f&quot;, &quot;Last layer Merkle root is wrong.&quot;);

println!(&quot;Success!&quot;);

[E0425] Error: cannot find value `cp` in this scope
   ╭─[command_60:1:1]
   │
 2 │ let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp.clone(), eval_domain.clone(), cp_eval.clone(), cp_merkle.clone(), &amp;mut test_channel);
   ·                                                                    ─┬
   ·                                                                     ╰── not found in this scope
───╯

[E0425] Error: cannot find value `eval_domain` in this scope
   ╭─[command_60:1:1]
   │
 2 │ let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp.clone(), eval_domain.clone(), cp_eval.clone(), cp_merkle.clone(), &amp;mut test_channel);
   ·                                                                                ─────┬─────
   ·                                                                                     ╰─────── not found in this scope
───╯

[E0425] Error: cannot find value `cp_eval` in this scope
   ╭─[command_60:1:1]
   │
 2 │ let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp.clone(), eval_domain.clone(), cp_eval.clone(), cp_merkle.clone(), &amp;mut test_channel);
   ·                                                                                                     ───┬───
   ·                                                                                                        ╰───── not found in this scope
───╯

[E0425] Error: cannot find value `cp_merkle` in this scope
   ╭─[command_60:1:1]
   │
 2 │ let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp.clone(), eval_domain.clone(), cp_eval.clone(), cp_merkle.clone(), &amp;mut test_channel);
   ·                                                                                                                      ────┬────
   ·                                                                                                                          ╰────── not found in this scope
───╯
</code></pre>
<p>Run the following cell to execute the function with your channel object
and print the proof so far:</p>
<pre><code>let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp, eval_domain, cp_eval, cp_merkle, channel);
println!(&quot;{}&quot;, channel.proof);

[E0425] Error: cannot find value `cp` in this scope
   ╭─[command_59:1:1]
   │
 1 │ let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp, eval_domain, cp_eval, cp_merkle, channel);
   ·                                                                    ─┬
   ·                                                                     ╰── not found in this scope
───╯

[E0425] Error: cannot find value `eval_domain` in this scope
   ╭─[command_59:1:1]
   │
 1 │ let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp, eval_domain, cp_eval, cp_merkle, channel);
   ·                                                                        ─────┬─────
   ·                                                                             ╰─────── not found in this scope
───╯

[E0425] Error: cannot find value `cp_eval` in this scope
   ╭─[command_59:1:1]
   │
 1 │ let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp, eval_domain, cp_eval, cp_merkle, channel);
   ·                                                                                     ───┬───
   ·                                                                                        ╰───── not found in this scope
───╯

[E0425] Error: cannot find value `cp_merkle` in this scope
   ╭─[command_59:1:1]
   │
 1 │ let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp, eval_domain, cp_eval, cp_merkle, channel);
   ·                                                                                              ────┬────
   ·                                                                                                  ╰────── not found in this scope
───╯

[E0308] Error: mismatched types
   ╭─[command_59:1:1]
   │
 1 │ let (fri_polys, fri_domains, fri_layers, fri_merkles) = fri_commit(cp, eval_domain, cp_eval, cp_merkle, channel);
   ·                                                         ─────┬────                                      ───┬───
   ·                                                              ╰─────────────────────────────────────────────────── arguments to this function are incorrect
   ·                                                                                                            │
   ·                                                                                                            ╰───── expected `&amp;mut Channel`, found `Channel`
   ·                                                                                                            │
   ·                                                                                                            ╰───── help: consider mutably borrowing here: `&amp;mut channel`
───╯

[E0277] Error: `Vec&lt;String&gt;` doesn't implement `std::fmt::Display`
   ╭─[command_59:1:1]
   │
 2 │ println!(&quot;{}&quot;, channel.proof);
   ·                ──────┬──────
   ·                      ╰──────── `Vec&lt;String&gt;` cannot be formatted with the default formatter
───╯
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><em>Copyright 2019 StarkWare Industries Ltd. Licensed under the Apache
License, Version 2.0 (the &quot;License&quot;). You may not use this file except
in compliance with the License. You may obtain a copy of the License at
<a href="https://www.starkware.co/open-source-license/">https://www.starkware.co/open-source-license/</a> Unless required by
applicable law or agreed to in writing, software distributed under the
License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License.</em></p>
<h1 id="part-4-query-phase-1"><a class="header" href="#part-4-query-phase-1">Part 4: Query Phase</a></h1>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=CxP28qM4tAc">Video Lecture
(youtube)</a></p>
</li>
<li>
<p><a href="https://starkware.co/wp-content/uploads/2021/12/STARK101-Part4.pdf">Slides
(PDF)</a></p>
</li>
</ul>
<h1 id="load-the-previous-session-1"><a class="header" href="#load-the-previous-session-1">Load the Previous Session</a></h1>
<p>Run the next cell to load the variables we’ll use in this part. Since it
repeats everything done in previous parts - it will take a while to run.</p>
<pre><code>:dep stark101-rs = { path = &quot;stark101&quot; }
:dep sha256 = &quot;1.1.2&quot;
use stark101_rs::{field::FieldElement, channel::Channel, polynomial::{Polynomial, x}, merkle_tree::MerkleTree};
use stark101_rs::parts::{part1, part3};

let (_, _, _, _, _, _, _, f_eval, f_merkle, _) = part1();
let (fri_polys, fri_domains, fri_layers, fri_merkles, _ch): (Vec&lt;Polynomial&gt;, Vec&lt;Vec&lt;FieldElement&gt;&gt;, Vec&lt;Vec&lt;FieldElement&gt;&gt;, Vec&lt;MerkleTree&gt;, Channel) = part3();

println!(&quot;Success!&quot;);

Success!
</code></pre>
<h1 id="decommit-on-a-query-1"><a class="header" href="#decommit-on-a-query-1">Decommit on a Query</a></h1>
<p>Our goal in this part is to generate all the information needed for
verifying the commitments of the three previous parts. In this part we
write two functions:</p>
<ol>
<li>
<p><code>decommit_on_fri_layers</code> - sends over the channel data showing that
each FRI layer is consistent with the others, when sampled at a
specified index.</p>
</li>
<li>
<p><code>decommit_on_query</code> - sends data required for decommiting on the
trace and then calls <code>decommit_on_fri_layers</code>.</p>
</li>
</ol>
<h1 id="decommit-on-the-fri-layers-1"><a class="header" href="#decommit-on-the-fri-layers-1">Decommit on the FRI Layers</a></h1>
<p>Implement <code>decommit_on_fri_layers</code> function. The function gets an index
and a channel, and sends over the channel the relevant data for
verifying the correctness of the FRI layers. More specifically, it
iterates over <code>fri_layers</code> and <code>fri_merkles</code> and in each iteration it
sends the following data (in the stated order):</p>
<ol>
<li>
<p>The element of the FRI layer at the given index (using
<code>fri_layers</code>).</p>
</li>
<li>
<p>Its authentication path (using the corresponding Merkle tree from
<code>fri_merkles</code>).</p>
</li>
<li>
<p>The element’s FRI sibling (i.e., if the element is , then its
sibling is , where is the current layer’s polynomial, and is an
element from the current layer’s domain).</p>
</li>
<li>
<p>The authentication path of the element’s sibling (using the same
merkle tree).</p>
</li>
</ol>
<p>To get an authentication path of an element, use
<code>get_authentication_path()</code> of the <code>MerkleTree</code> class, with the
corresponding index each time. Note that the index of the element’s
sibling equals to (idx + ) mod , where is the length of the relevant FRI
layer. Note that we do <strong>not</strong> send the authentication path for the
element in the last layer. In the last layer, all the elements are
equal, regardless of the query, as they are evaluations of a constant
polynomial.</p>
<p><em>(Remember to convert non-string variables into string before sending
over the channel.)</em></p>
<pre><code>// Fix this.
fn decommit_on_fri_layers(idx: usize, channel: &amp;mut Channel, fri_layers: Vec&lt;Vec&lt;FieldElement&gt;&gt;, fri_merkles: Vec&lt;MerkleTree&gt;) {
    for layer, merkle in zip(fri_layers[:-1], fri_merkles[:-1]) {
        // Fix this: send elements and authentication pathes of all the FRI layers but the last one.
        channel.send(&quot;The element from the current layer&quot;) // TODO
        channel.send(&quot;The authentication path for this element&quot;) // TODO
        channel.send(&quot;The element\'s sibling in the current layer&quot;) // TODO
        channel.send(&quot;The sibling\'s authentication path&quot;) // TODO
    }
    // Send the element in the last FRI layer.
    channel.send(&quot;The last element&quot;)
}
</code></pre>
<p>Solution:</p>
<pre><code>fn decommit_on_fri_layers(idx: usize, channel: &amp;mut Channel, fri_layers: Vec&lt;Vec&lt;FieldElement&gt;&gt;, fri_merkles: Vec&lt;MerkleTree&gt;) {
    for (layer, merkle) in zip(fri_layers[:-1], fri_merkles[:-1]) {
        let length = layer.len();
        let idx = idx % length;
        let sib_idx = (idx + length / 2) % length
        channel.send(layer[idx].to_string());
        channel.send(merkle.get_authentication_path(idx));
        channel.send(str(layer[sib_idx]));
        channel.send(str(merkle.get_authentication_path(sib_idx)));
    }
    channel.send(str(fri_layers[-1][0]))
}
</code></pre>
<p>Test your code:</p>
<pre><code>// Test against a precomputed hash.
let mut test_channel = Channel();
for query in vec![7527, 8168, 1190, 2668, 1262, 1889, 3828, 5798, 396, 2518] {
    decommit_on_fri_layers(query, &amp;mut test_channel, fri_layers.clone());
}
assert_eq!(test_channel.state, &quot;ad4fe9aaee0fbbad0130ae0fda896393b879c5078bf57d6c705ec41ce240861b&quot;, &quot;State of channel is wrong.&quot;);
println!(&quot;Success!&quot;);
</code></pre>
<h1 id="decommit-on-the-trace-polynomial-1"><a class="header" href="#decommit-on-the-trace-polynomial-1">Decommit on the Trace Polynomial</a></h1>
<p>To prove that indeed the FRI layers we decommit on were generated from
evaluation of the composition polynomial, we must also send:</p>
<ol>
<li>
<p>The value with its authentication path.</p>
</li>
<li>
<p>The value with its authentication path.</p>
</li>
<li>
<p>The value with its authentication path. The verifier, knowing the
random coefficients of the composition polynomial, can compute its
evaluation at , and compare it with the first element sent from the
first FRI layer.</p>
</li>
</ol>
<p>The function <code>decommit_on_query</code> should therefore send the above (1, 2,
and 3) over the channel, and then call <code>decommit_on_fri_layers</code>.</p>
<p>Importantly, even though are consecutive elements (modulo the group size
) in the trace, the evaluations of <code>f_eval</code> in these points are actually
8 elements apart. The reason for this is that we &quot;blew up&quot; the trace to
8 times its size in part I, to obtain a Reed Solomon codeword.</p>
<p><em>Reminder: <code>f_eval</code> is the evaluation of the composition polynomial, and
<code>f_merkle</code> is the corresponding Merkle tree.</em></p>
<pre><code>fn decommit_on_query(idx: usize, channel: &amp;mut Channel, fri_layers: Vec&lt;Vec&lt;FieldElement&gt;&gt;) {
    // Send elements and authentication pathes for f(x), f(gx) and f(g^2x) over the channel.
    channel.send(&quot;f(x)&quot;); // TODO
    channel.send(&quot;f(x)\'s authentication path&quot;); // TODO
    channel.send(&quot;f(gx)&quot;); // TODO
    channel.send(&quot;f(gx)\'s authentication path&quot;); // TODO
    channel.send(&quot;f(g^2x)&quot;); // TODO
    channel.send(&quot;f(g^2x)\'s authentication path&quot;); // TODO
    decommit_on_fri_layers(idx, &amp;mut channel, fri_layers) // No need to fix this line.
}
</code></pre>
<p>Solution:</p>
<pre><code>fn decommit_on_query(idx: usize, channel: &amp;mut Channel, fri_layers: Vec&lt;Vec&lt;FieldElement&gt;&gt;) {
    let f_eval_len = f_eval.len();
    assert!(idx + 16 &lt; f_eval.len(), &quot;query index: {idx} is out of range. Length of layer: {f_eval_len}.&quot;);
    channel.send(f_eval[idx].to_string()); // f(x).
    channel.send(f_merkle.get_authentication_path(idx).to_string())); // auth path for f(x).
    channel.send(f_eval[idx + 8].to_string()); // f(gx).
    channel.send(f_merkle.get_authentication_path(idx + 8).to_string()); // auth path for f(gx).
    channel.send(f_eval[idx + 16].to_string()); // f(g^2x).
    channel.send(f_merkle.get_authentication_path(idx + 16).to_string()); // auth path for f(g^2x).
    decommit_on_fri_layers(idx, channel, fri_layers);
}
</code></pre>
<p>Test your code:</p>
<pre><code>// Test against a precomputed hash.
let mut test_channel = Channel();
for query in vec![8134, 1110, 1134, 6106, 7149, 4796, 144, 4738, 957] {
    decommit_on_query(query, test_channel)
}
assert_eq!(test_channel.state, &quot;16a72acce8d10ffb318f8f5cd557930e38cdba236a40439c9cf04aaf650cfb96&quot;, &quot;State of channel is wrong.&quot;);
println!(&quot;Success!&quot;);
</code></pre>
<h1 id="decommit-on-a-set-of-queries-1"><a class="header" href="#decommit-on-a-set-of-queries-1">Decommit on a Set of Queries</a></h1>
<p>To finish the proof, the prover gets a set of random queries from the
channel, i.e., indices between 0 to 8191, and decommits on each query.</p>
<p>Use the function that you just implemented <code>decommit_on_query()</code>, and
<code>Channel.receive_random_int</code> to generate 3 random queries and decommit
on each.</p>
<pre><code>// Fix this.
fn decommit_fri(channel: &amp;mut Channel) {
    for query in 0..3 {
        todo!(); // Get a random index from the channel and send the corresponding decommitment.
    }
}
</code></pre>
<p>Solution:</p>
<pre><code>fn decommit_fri(channel: &amp;mut Channel) {
    for query in 0..3 {
        // Get a random index from the verifier and send the corresponding decommitment.
        decommit_on_query(channel.receive_random_int(0, 8191-16), channel);
    }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
